/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(299);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*istanbul ignore next*/"use strict";
	
	/*istanbul ignore next*/__webpack_require__(2);
	
	/*istanbul ignore next*/__webpack_require__(294);
	
	/*istanbul ignore next*/__webpack_require__(296);
	
	/* eslint max-len: 0 */
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	// Should be removed in the next major release:
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(96);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(211);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(292);
	__webpack_require__(293);
	module.exports = __webpack_require__(9);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(4)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , META           = __webpack_require__(22).KEY
	  , $fails         = __webpack_require__(7)
	  , shared         = __webpack_require__(23)
	  , setToStringTag = __webpack_require__(24)
	  , uid            = __webpack_require__(19)
	  , wks            = __webpack_require__(25)
	  , wksExt         = __webpack_require__(26)
	  , wksDefine      = __webpack_require__(27)
	  , keyOf          = __webpack_require__(29)
	  , enumKeys       = __webpack_require__(42)
	  , isArray        = __webpack_require__(45)
	  , anObject       = __webpack_require__(12)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , createDesc     = __webpack_require__(17)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(49)
	  , $GOPD          = __webpack_require__(51)
	  , $DP            = __webpack_require__(11)
	  , $keys          = __webpack_require__(30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f  = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , core      = __webpack_require__(9)
	  , hide      = __webpack_require__(10)
	  , redefine  = __webpack_require__(18)
	  , ctx       = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11)
	  , createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , toPrimitive    = __webpack_require__(16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function(){
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , document = __webpack_require__(4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , hide      = __webpack_require__(10)
	  , has       = __webpack_require__(5)
	  , SRC       = __webpack_require__(19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(19)('meta')
	  , isObject = __webpack_require__(13)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(23)('wks')
	  , uid        = __webpack_require__(19)
	  , Symbol     = __webpack_require__(4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(4)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(26)
	  , defineProperty = __webpack_require__(11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(31)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(32)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33)
	  , defined = __webpack_require__(35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys')
	  , uid    = __webpack_require__(19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30)
	  , gOPS    = __webpack_require__(43)
	  , pIE     = __webpack_require__(44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(12)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(11)
	  , anObject = __webpack_require__(12)
	  , getKeys  = __webpack_require__(30);
	
	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4).document && document.documentElement;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32)
	  , gOPN      = __webpack_require__(50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(31)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(44)
	  , createDesc     = __webpack_require__(17)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(46)});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(11).f});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(47)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(32)
	  , $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(9)
	  , fails   = __webpack_require__(7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(58)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(58)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58)
	  , $keys    = __webpack_require__(30);
	
	__webpack_require__(56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function(){
	  return __webpack_require__(49).f;
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(30)
	  , gOPS     = __webpack_require__(43)
	  , pIE      = __webpack_require__(44)
	  , toObject = __webpack_require__(58)
	  , IObject  = __webpack_require__(33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {is: __webpack_require__(71)});

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13)
	  , anObject = __webpack_require__(12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75)
	  , test    = {};
	test[__webpack_require__(25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34)
	  , TAG = __webpack_require__(25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(77)});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(21)
	  , isObject   = __webpack_require__(13)
	  , invoke     = __webpack_require__(78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11).f
	  , createDesc = __webpack_require__(17)
	  , has        = __webpack_require__(5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(13)
	  , getPrototypeOf = __webpack_require__(59)
	  , HAS_INSTANCE   = __webpack_require__(25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt
	  , $trim     = __webpack_require__(83).trim
	  , ws        = __webpack_require__(84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , defined = __webpack_require__(35)
	  , fails   = __webpack_require__(7)
	  , spaces  = __webpack_require__(84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat
	  , $trim       = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , has               = __webpack_require__(5)
	  , cof               = __webpack_require__(34)
	  , inheritIfRequired = __webpack_require__(88)
	  , toPrimitive       = __webpack_require__(16)
	  , fails             = __webpack_require__(7)
	  , gOPN              = __webpack_require__(50).f
	  , gOPD              = __webpack_require__(51).f
	  , dP                = __webpack_require__(11).f
	  , $trim             = __webpack_require__(83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(13)
	  , setPrototypeOf = __webpack_require__(73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , anInstance   = __webpack_require__(90)
	  , toInteger    = __webpack_require__(38)
	  , aNumberValue = __webpack_require__(91)
	  , repeat       = __webpack_require__(92)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $fails       = __webpack_require__(7)
	  , aNumberValue = __webpack_require__(91)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(8)
	  , _isFinite = __webpack_require__(4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(97)});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(8)
	  , isInteger = __webpack_require__(97)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8)
	  , log1p   = __webpack_require__(105)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 105 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8)
	  , sign    = __webpack_require__(109);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 109 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8)
	  , $expm1  = __webpack_require__(113);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 113 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(8)
	  , sign      = __webpack_require__(109)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(105)});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(109)});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(8)
	  , toIndex        = __webpack_require__(39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(128)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(129)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(130)
	  , $iterCreate    = __webpack_require__(131)
	  , setToStringTag = __webpack_require__(24)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(17)
	  , setToStringTag = __webpack_require__(24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(128)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(8)
	  , toLength  = __webpack_require__(37)
	  , context   = __webpack_require__(134)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(135)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13)
	  , cof      = __webpack_require__(34)
	  , MATCH    = __webpack_require__(25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(8)
	  , context  = __webpack_require__(134)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(136)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(92)
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(8)
	  , toLength    = __webpack_require__(37)
	  , context     = __webpack_require__(134)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(141)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , defined = __webpack_require__(35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(141)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(141)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(141)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(141)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(141)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(141)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(141)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(141)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(141)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(141)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(141)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(141)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);
	
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(159));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(45)});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(20)
	  , $export        = __webpack_require__(8)
	  , toObject       = __webpack_require__(58)
	  , call           = __webpack_require__(162)
	  , isArrayIter    = __webpack_require__(163)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(164)
	  , getIterFn      = __webpack_require__(165);
	
	$export($export.S + $export.F * !__webpack_require__(166)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(130)
	  , ITERATOR   = __webpack_require__(25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11)
	  , createDesc      = __webpack_require__(17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(8)
	  , createProperty = __webpack_require__(164);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(169)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(8)
	  , html       = __webpack_require__(48)
	  , cof        = __webpack_require__(34)
	  , toIndex    = __webpack_require__(39)
	  , toLength   = __webpack_require__(37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , fails     = __webpack_require__(7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(169)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(173)(0)
	  , STRICT   = __webpack_require__(169)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(20)
	  , IObject  = __webpack_require__(33)
	  , toObject = __webpack_require__(58)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(174);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(175);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , isArray  = __webpack_require__(45)
	  , SPECIES  = __webpack_require__(25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(173)(1);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(173)(2);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(173)(3);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $every  = __webpack_require__(173)(4);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , IObject   = __webpack_require__(33)
	  , toLength  = __webpack_require__(37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , toIObject     = __webpack_require__(32)
	  , toInteger     = __webpack_require__(38)
	  , toLength      = __webpack_require__(37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(186)});
	
	__webpack_require__(187)('copyWithin');

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(189)});
	
	__webpack_require__(187)('fill');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(173)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(173)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(193)('Array');

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(4)
	  , dP          = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(6)
	  , SPECIES     = __webpack_require__(25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(187)
	  , step             = __webpack_require__(195)
	  , Iterators        = __webpack_require__(130)
	  , toIObject        = __webpack_require__(32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(129)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(4)
	  , inheritIfRequired = __webpack_require__(88)
	  , dP                = __webpack_require__(11).f
	  , gOPN              = __webpack_require__(50).f
	  , isRegExp          = __webpack_require__(135)
	  , $flags            = __webpack_require__(197)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function(){
	  re2[__webpack_require__(25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(193)('RegExp');

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(199);
	var anObject    = __webpack_require__(12)
	  , $flags      = __webpack_require__(197)
	  , DESCRIPTORS = __webpack_require__(6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(197)
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(201)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(10)
	  , redefine = __webpack_require__(18)
	  , fails    = __webpack_require__(7)
	  , defined  = __webpack_require__(35)
	  , wks      = __webpack_require__(25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(201)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(201)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(201)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(135)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(28)
	  , global             = __webpack_require__(4)
	  , ctx                = __webpack_require__(20)
	  , classof            = __webpack_require__(75)
	  , $export            = __webpack_require__(8)
	  , isObject           = __webpack_require__(13)
	  , anObject           = __webpack_require__(12)
	  , aFunction          = __webpack_require__(21)
	  , anInstance         = __webpack_require__(90)
	  , forOf              = __webpack_require__(206)
	  , setProto           = __webpack_require__(73).set
	  , speciesConstructor = __webpack_require__(207)
	  , task               = __webpack_require__(208).set
	  , microtask          = __webpack_require__(209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(24)($Promise, PROMISE);
	__webpack_require__(193)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(166)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(20)
	  , call        = __webpack_require__(162)
	  , isArrayIter = __webpack_require__(163)
	  , anObject    = __webpack_require__(12)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(165)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(12)
	  , aFunction = __webpack_require__(21)
	  , SPECIES   = __webpack_require__(25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(20)
	  , invoke             = __webpack_require__(78)
	  , html               = __webpack_require__(48)
	  , cel                = __webpack_require__(15)
	  , global             = __webpack_require__(4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , macrotask = __webpack_require__(208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(11).f
	  , create      = __webpack_require__(46)
	  , hide        = __webpack_require__(10)
	  , redefineAll = __webpack_require__(210)
	  , ctx         = __webpack_require__(20)
	  , anInstance  = __webpack_require__(90)
	  , defined     = __webpack_require__(35)
	  , forOf       = __webpack_require__(206)
	  , $iterDefine = __webpack_require__(129)
	  , step        = __webpack_require__(195)
	  , setSpecies  = __webpack_require__(193)
	  , DESCRIPTORS = __webpack_require__(6)
	  , fastKey     = __webpack_require__(22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , $export           = __webpack_require__(8)
	  , redefine          = __webpack_require__(18)
	  , redefineAll       = __webpack_require__(210)
	  , meta              = __webpack_require__(22)
	  , forOf             = __webpack_require__(206)
	  , anInstance        = __webpack_require__(90)
	  , isObject          = __webpack_require__(13)
	  , fails             = __webpack_require__(7)
	  , $iterDetect       = __webpack_require__(166)
	  , setToStringTag    = __webpack_require__(24)
	  , inheritIfRequired = __webpack_require__(88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(173)(0)
	  , redefine     = __webpack_require__(18)
	  , meta         = __webpack_require__(22)
	  , assign       = __webpack_require__(69)
	  , weak         = __webpack_require__(216)
	  , isObject     = __webpack_require__(13)
	  , has          = __webpack_require__(5)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(210)
	  , getWeak           = __webpack_require__(22).getWeak
	  , anObject          = __webpack_require__(12)
	  , isObject          = __webpack_require__(13)
	  , anInstance        = __webpack_require__(90)
	  , forOf             = __webpack_require__(206)
	  , createArrayMethod = __webpack_require__(173)
	  , $has              = __webpack_require__(5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $typed       = __webpack_require__(219)
	  , buffer       = __webpack_require__(220)
	  , anObject     = __webpack_require__(12)
	  , toIndex      = __webpack_require__(39)
	  , toLength     = __webpack_require__(37)
	  , isObject     = __webpack_require__(13)
	  , TYPED_ARRAY  = __webpack_require__(25)('typed_array')
	  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(193)(ARRAY_BUFFER);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , hide   = __webpack_require__(10)
	  , uid    = __webpack_require__(19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(4)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , LIBRARY        = __webpack_require__(28)
	  , $typed         = __webpack_require__(219)
	  , hide           = __webpack_require__(10)
	  , redefineAll    = __webpack_require__(210)
	  , fails          = __webpack_require__(7)
	  , anInstance     = __webpack_require__(90)
	  , toInteger      = __webpack_require__(38)
	  , toLength       = __webpack_require__(37)
	  , gOPN           = __webpack_require__(50).f
	  , dP             = __webpack_require__(11).f
	  , arrayFill      = __webpack_require__(189)
	  , setToStringTag = __webpack_require__(24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , parseInt       = global.parseInt
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , min            = Math.min
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(219).ABV, {
	  DataView: __webpack_require__(220).DataView
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(6)){
	  var LIBRARY             = __webpack_require__(28)
	    , global              = __webpack_require__(4)
	    , fails               = __webpack_require__(7)
	    , $export             = __webpack_require__(8)
	    , $typed              = __webpack_require__(219)
	    , $buffer             = __webpack_require__(220)
	    , ctx                 = __webpack_require__(20)
	    , anInstance          = __webpack_require__(90)
	    , propertyDesc        = __webpack_require__(17)
	    , hide                = __webpack_require__(10)
	    , redefineAll         = __webpack_require__(210)
	    , isInteger           = __webpack_require__(97)
	    , toInteger           = __webpack_require__(38)
	    , toLength            = __webpack_require__(37)
	    , toIndex             = __webpack_require__(39)
	    , toPrimitive         = __webpack_require__(16)
	    , has                 = __webpack_require__(5)
	    , same                = __webpack_require__(71)
	    , classof             = __webpack_require__(75)
	    , isObject            = __webpack_require__(13)
	    , toObject            = __webpack_require__(58)
	    , isArrayIter         = __webpack_require__(163)
	    , create              = __webpack_require__(46)
	    , getPrototypeOf      = __webpack_require__(59)
	    , gOPN                = __webpack_require__(50).f
	    , isIterable          = __webpack_require__(224)
	    , getIterFn           = __webpack_require__(165)
	    , uid                 = __webpack_require__(19)
	    , wks                 = __webpack_require__(25)
	    , createArrayMethod   = __webpack_require__(173)
	    , createArrayIncludes = __webpack_require__(36)
	    , speciesConstructor  = __webpack_require__(207)
	    , ArrayIterators      = __webpack_require__(194)
	    , Iterators           = __webpack_require__(130)
	    , $iterDetect         = __webpack_require__(166)
	    , setSpecies          = __webpack_require__(193)
	    , arrayFill           = __webpack_require__(189)
	    , arrayCopyWithin     = __webpack_require__(186)
	    , $DP                 = __webpack_require__(11)
	    , $GOPD               = __webpack_require__(51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(9).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , _apply    = Function.apply;
	
	$export($export.S, 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    return _apply.call(aFunction(target), thisArgument, anObject(argumentsList));
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export   = __webpack_require__(8)
	  , create    = __webpack_require__(46)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , isObject  = __webpack_require__(13)
	  , bind      = __webpack_require__(77);
	
	// MS Edge supports only 2 arguments
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Reflect.construct(function(){}, [], F) instanceof F);
	}), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(11)
	  , $export     = __webpack_require__(8)
	  , anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(8)
	  , gOPD     = __webpack_require__(51).f
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(131)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , isObject       = __webpack_require__(13)
	  , anObject       = __webpack_require__(12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(51)
	  , $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(8)
	  , getProto = __webpack_require__(59)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(8)
	  , anObject      = __webpack_require__(12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(244)});

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(50)
	  , gOPS     = __webpack_require__(43)
	  , anObject = __webpack_require__(12)
	  , Reflect  = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(8)
	  , anObject           = __webpack_require__(12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(11)
	  , gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , createDesc     = __webpack_require__(17)
	  , anObject       = __webpack_require__(12)
	  , isObject       = __webpack_require__(13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(8)
	  , setProto = __webpack_require__(73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(8)
	  , $includes = __webpack_require__(36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(187)('includes');

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(128)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37)
	  , repeat   = __webpack_require__(92)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(8)
	  , defined     = __webpack_require__(35)
	  , toLength    = __webpack_require__(37)
	  , isRegExp    = __webpack_require__(135)
	  , getFlags    = __webpack_require__(197)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(131)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('asyncIterator');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('observable');

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(8)
	  , ownKeys        = __webpack_require__(244)
	  , toIObject      = __webpack_require__(32)
	  , gOPD           = __webpack_require__(51)
	  , createProperty = __webpack_require__(164);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key, D;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8)
	  , $values = __webpack_require__(260)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32)
	  , isEnum    = __webpack_require__(44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(8)
	  , $entries = __webpack_require__(260)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(28)|| !__webpack_require__(7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(4)[K];
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(268)('Map')});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75)
	  , from    = __webpack_require__(269);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(268)('Set')});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(8);
	
	$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8)
	  , cof     = __webpack_require__(34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(211)
	  , $export = __webpack_require__(8)
	  , shared  = __webpack_require__(23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(214)
	  , from                    = __webpack_require__(269)
	  , metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(12)
	  , getPrototypeOf          = __webpack_require__(59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(12)
	  , aFunction                 = __webpack_require__(21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(8)
	  , microtask = __webpack_require__(209)()
	  , process   = __webpack_require__(4).process
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(8)
	  , global      = __webpack_require__(4)
	  , core        = __webpack_require__(9)
	  , microtask   = __webpack_require__(209)()
	  , OBSERVABLE  = __webpack_require__(25)('observable')
	  , aFunction   = __webpack_require__(21)
	  , anObject    = __webpack_require__(12)
	  , anInstance  = __webpack_require__(90)
	  , redefineAll = __webpack_require__(210)
	  , hide        = __webpack_require__(10)
	  , forOf       = __webpack_require__(206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(193)('Observable');

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(4)
	  , $export    = __webpack_require__(8)
	  , invoke     = __webpack_require__(78)
	  , partial    = __webpack_require__(290)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(291)
	  , invoke    = __webpack_require__(78)
	  , aFunction = __webpack_require__(21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , $task   = __webpack_require__(208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(194)
	  , redefine      = __webpack_require__(18)
	  , global        = __webpack_require__(4)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(130)
	  , wks           = __webpack_require__(25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(295)))

/***/ },
/* 295 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(297);
	module.exports = __webpack_require__(9).RegExp.escape;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8)
	  , $re     = __webpack_require__(298)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	__webpack_require__(300);
	
	var _jsCookie = __webpack_require__(301);
	
	var _jsCookie2 = _interopRequireDefault(_jsCookie);
	
	var _core = __webpack_require__(302);
	
	var _core2 = _interopRequireDefault(_core);
	
	var _bar = __webpack_require__(464);
	
	var bar = _interopRequireWildcard(_bar);
	
	var _jquery = __webpack_require__(477);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _select = __webpack_require__(478);
	
	var _select2 = _interopRequireDefault(_select);
	
	var _urijs = __webpack_require__(479);
	
	var _urijs2 = _interopRequireDefault(_urijs);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	_core2.default.register([bar]);
	
	__webpack_require__(483);
	__webpack_require__(487);
	__webpack_require__(489);
	
	var Figure = function () {
	  function Figure(element) {
	    _classCallCheck(this, Figure);
	
	    if (new.target === Figure) {
	      throw new TypeError("Figure class is abstract and should not be instantiated");
	    }
	    this.element = element;
	    this.layout = { showlegend: true };
	    this.traces = [];
	  }
	
	  _createClass(Figure, [{
	    key: 'plot',
	    value: function plot() {
	      _core2.default.newPlot(this.element, this.traces, this.layout, { displaylogo: false });
	    }
	  }, {
	    key: 'newTrace',
	    value: function newTrace() {
	      return { x: [], y: [], name: 'No Name', type: 'bar' };
	    }
	  }, {
	    key: 'handleResponse',
	    value: function handleResponse(json) {
	      console.log(json);
	    }
	  }, {
	    key: 'getRequestFigure',
	    value: function getRequestFigure(url) {
	      var _this = this;
	
	      fetch(url).then(function (response) {
	        return response.json();
	      }).then(function (json) {
	        return _this.handleResponse(json);
	      });
	    }
	  }, {
	    key: 'postRequestFigure',
	    value: function postRequestFigure(url, requestJson) {
	      var _this2 = this;
	
	      // console.log(requestJson);
	      fetch(url, {
	        credentials: 'same-origin',
	        method: 'POST',
	        headers: {
	          'X-CSRFToken': _jsCookie2.default.get('csrftoken'),
	          'Accept': 'application/json',
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify(requestJson)
	      }).then(function (response) {
	        return response.json();
	      }).then(function (json) {
	        return _this2.handleResponse(json);
	      });
	    }
	  }]);
	
	  return Figure;
	}();
	
	var SingleProjectFigure = function (_Figure) {
	  _inherits(SingleProjectFigure, _Figure);
	
	  function SingleProjectFigure(element) {
	    _classCallCheck(this, SingleProjectFigure);
	
	    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(SingleProjectFigure).call(this, element));
	
	    _this3.traceTypes = [];
	    return _this3;
	  }
	
	  _createClass(SingleProjectFigure, [{
	    key: 'handleResponse',
	    value: function handleResponse(json) {
	      _get(Object.getPrototypeOf(SingleProjectFigure.prototype), 'handleResponse', this).call(this, json);
	      SingleProjectFigure.data = json;
	      this.makeTraces();
	      this.plot();
	    }
	  }, {
	    key: 'makeTraces',
	    value: function makeTraces() {
	
	      if (this.traceTypes.indexOf('staff_split') > -1) {
	        this.makeTrace('cs_perc', '% Civil Servants');
	        this.makeTrace('contr_perc', '% Contractors');
	        this.layout.barmode = 'stack';
	        return;
	      }
	
	      if (this.traceTypes.indexOf('cost') > -1) {
	        this.makeTrace('cost', 'Monthly Cost £');
	      }
	      if (this.traceTypes.indexOf('time') > -1) {
	        this.makeTrace('time', 'Person Days');
	      }
	      if (this.traceTypes.indexOf('cumulative') > -1) {
	        this.makeTrace('cumul_cost', 'Cumulative Cost £', 'line');
	      }
	
	      console.log(this.traces);
	    }
	  }, {
	    key: 'updateData',
	    value: function updateData(url) {
	      console.log('>>>Requesting data');
	      this.postRequestFigure(url, SingleProjectFigure.requestData);
	    }
	  }, {
	    key: 'init',
	    value: function init(url, traceTypes) {
	      this.traceTypes = traceTypes;
	      if (SingleProjectFigure.data != {}) {
	        this.updateData(url);
	      } else {
	        console.log('>>>Using stored data');
	        this.plot();
	      }
	    }
	  }, {
	    key: 'makeTrace',
	    value: function makeTrace(key, name) {
	      var type = arguments.length <= 2 || arguments[2] === undefined ? 'bar' : arguments[2];
	
	
	      var trace = this.newTrace();
	      trace.name = name;
	      trace.type = type;
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = SingleProjectFigure.data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var timeWindow = _step.value;
	
	
	          trace.x.push(timeWindow.label);
	          trace.y.push(timeWindow[key]);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      this.traces.push(trace);
	    }
	  }]);
	
	  return SingleProjectFigure;
	}(Figure);
	
	SingleProjectFigure.data = {};
	
	SingleProjectFigure.requestData = {
	
	  request_type: 'single_project',
	  project_id: 52, // Now set from select box
	  start_date: '2015-01-01',
	  end_date: '2016-06-01',
	  time_increment: 'month', // month, week or day
	  filter_empty: false
	
	};
	
	function plot() {
	
	  var figA = document.getElementById('fig-a');
	  var figB = document.getElementById('fig-b');
	  var figC = document.getElementById('fig-c');
	
	  var fA = new SingleProjectFigure(figA);
	  var fB = new SingleProjectFigure(figB);
	  var fC = new SingleProjectFigure(figC);
	
	  fA.init('/getdata/', ['cost', 'cumulative']);
	  fB.init('/getdata/', ['time']);
	  fC.init('/getdata/', ['staff_split']);
	}
	
	/**
	 * get projectId based on the query string
	 */
	function getProjectId() {
	  var projectId = (0, _urijs2.default)(window.location.href).query(true).projectid;
	  console.log('projectId:', projectId);
	  return projectId;
	};
	
	function loadProject(id) {
	  var url = [location.protocol, '//', location.host, location.pathname].join('');
	
	  window.location.href = url + '?projectid=' + id;
	};
	
	(0, _jquery2.default)(function () {
	  var projectId = getProjectId();
	  // plot project
	  SingleProjectFigure.requestData.project_id = projectId;
	  plot();
	  // dropdown project selector
	  (0, _jquery2.default)('#projects').select2().on("select2:select", function (e) {
	    loadProject(e.params.data.id);
	  });
	});

/***/ },
/* 300 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * JavaScript Cookie v2.1.1
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */
	;(function (factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			module.exports = factory();
		} else {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend () {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[ i ];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}
	
		function init (converter) {
			function api (key, value, attributes) {
				var result;
				if (typeof document === 'undefined') {
					return;
				}
	
				// Write
	
				if (arguments.length > 1) {
					attributes = extend({
						path: '/'
					}, api.defaults, attributes);
	
					if (typeof attributes.expires === 'number') {
						var expires = new Date();
						expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
						attributes.expires = expires;
					}
	
					try {
						result = JSON.stringify(value);
						if (/^[\{\[]/.test(result)) {
							value = result;
						}
					} catch (e) {}
	
					if (!converter.write) {
						value = encodeURIComponent(String(value))
							.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
					} else {
						value = converter.write(value, key);
					}
	
					key = encodeURIComponent(String(key));
					key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
					key = key.replace(/[\(\)]/g, escape);
	
					return (document.cookie = [
						key, '=', value,
						attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
						attributes.path    && '; path=' + attributes.path,
						attributes.domain  && '; domain=' + attributes.domain,
						attributes.secure ? '; secure' : ''
					].join(''));
				}
	
				// Read
	
				if (!key) {
					result = {};
				}
	
				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all. Also prevents odd result when
				// calling "get()"
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var rdecode = /(%[0-9A-Z]{2})+/g;
				var i = 0;
	
				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var name = parts[0].replace(rdecode, decodeURIComponent);
					var cookie = parts.slice(1).join('=');
	
					if (cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}
	
					try {
						cookie = converter.read ?
							converter.read(cookie, name) : converter(cookie, name) ||
							cookie.replace(rdecode, decodeURIComponent);
	
						if (this.json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}
	
						if (key === name) {
							result = cookie;
							break;
						}
	
						if (!key) {
							result[name] = cookie;
						}
					} catch (e) {}
				}
	
				return result;
			}
	
			api.set = api;
			api.get = function (key) {
				return api(key);
			};
			api.getJSON = function () {
				return api.apply({
					json: true
				}, [].slice.call(arguments));
			};
			api.defaults = {};
	
			api.remove = function (key, attributes) {
				api(key, '', extend(attributes, {
					expires: -1
				}));
			};
	
			api.withConverter = init;
	
			return api;
		}
	
		return init(function () {});
	}));


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	module.exports = __webpack_require__(303);


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	/*
	 * Export the plotly.js API methods.
	 */
	
	var Plotly = __webpack_require__(304);
	
	// package version injected by `npm run preprocess`
	exports.version = '1.11.0';
	
	// plot api
	exports.plot = Plotly.plot;
	exports.newPlot = Plotly.newPlot;
	exports.restyle = Plotly.restyle;
	exports.relayout = Plotly.relayout;
	exports.redraw = Plotly.redraw;
	exports.extendTraces = Plotly.extendTraces;
	exports.prependTraces = Plotly.prependTraces;
	exports.addTraces = Plotly.addTraces;
	exports.deleteTraces = Plotly.deleteTraces;
	exports.moveTraces = Plotly.moveTraces;
	exports.purge = Plotly.purge;
	exports.setPlotConfig = __webpack_require__(463);
	exports.register = Plotly.register;
	exports.toImage = __webpack_require__(453);
	exports.downloadImage = __webpack_require__(452);
	
	// plot icons
	exports.Icons = __webpack_require__(426);
	
	// unofficial 'beta' plot methods, use at your own risk
	exports.Plots = Plotly.Plots;
	exports.Fx = Plotly.Fx;
	exports.Snapshot = Plotly.Snapshot;
	exports.PlotSchema = Plotly.PlotSchema;
	exports.Queue = Plotly.Queue;
	
	// export d3 used in the bundle
	exports.d3 = __webpack_require__(310);


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	/*
	 * Pack internal modules unto an object.
	 *
	 * This object is require'ed in as 'Plotly' in numerous src and test files.
	 * Require'ing 'Plotly' bypasses circular dependencies.
	 *
	 * Future development should move away from this pattern.
	 *
	 */
	
	// promise polyfill
	__webpack_require__(305).polyfill();
	
	// lib functions
	exports.Lib = __webpack_require__(309);
	exports.util = __webpack_require__(326);
	exports.Queue = __webpack_require__(328);
	
	// plot css
	__webpack_require__(329);
	
	// configuration
	exports.MathJaxConfig = __webpack_require__(330);
	exports.defaultConfig = __webpack_require__(331);
	
	// plots
	var Plots = exports.Plots = __webpack_require__(332);
	
	exports.Axes = __webpack_require__(338);
	exports.Fx = __webpack_require__(382);
	exports.micropolar = __webpack_require__(393);
	
	// components
	exports.Color = __webpack_require__(333);
	exports.Drawing = __webpack_require__(340);
	exports.Colorscale = __webpack_require__(341);
	exports.Colorbar = __webpack_require__(396);
	exports.ErrorBars = __webpack_require__(398);
	exports.Annotations = __webpack_require__(405);
	exports.Shapes = __webpack_require__(408);
	exports.Legend = __webpack_require__(412);
	exports.Images = __webpack_require__(421);
	exports.ModeBar = __webpack_require__(425);
	
	exports.register = function register(_modules) {
	    if(!_modules) {
	        throw new Error('No argument passed to Plotly.register.');
	    } else if(_modules && !Array.isArray(_modules)) {
	        _modules = [_modules];
	    }
	
	    for(var i = 0; i < _modules.length; i++) {
	        var newModule = _modules[i];
	
	        if(newModule && newModule.moduleType !== 'trace') {
	            throw new Error('Invalid module was attempted to be registered!');
	        } else {
	            Plots.register(newModule, newModule.name, newModule.categories, newModule.meta);
	
	            if(!Plots.subplotsRegistry[newModule.basePlotModule.name]) {
	                Plots.registerSubplot(newModule.basePlotModule);
	            }
	        }
	    }
	};
	
	// Scatter is the only trace included by default
	exports.register(__webpack_require__(427));
	
	// plot api
	__webpack_require__(448);
	exports.PlotSchema = __webpack_require__(460);
	
	// imaging routines
	exports.Snapshot = __webpack_require__(454);


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(307);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(308)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(295), (function() { return this; }()), __webpack_require__(306)(module)))

/***/ },
/* 306 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 307 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 308 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var lib = module.exports = {};
	
	lib.nestedProperty = __webpack_require__(311);
	lib.isPlainObject = __webpack_require__(313);
	
	var coerceModule = __webpack_require__(314);
	lib.valObjects = coerceModule.valObjects;
	lib.coerce = coerceModule.coerce;
	lib.coerce2 = coerceModule.coerce2;
	lib.coerceFont = coerceModule.coerceFont;
	
	var datesModule = __webpack_require__(320);
	lib.dateTime2ms = datesModule.dateTime2ms;
	lib.isDateTime = datesModule.isDateTime;
	lib.ms2DateTime = datesModule.ms2DateTime;
	lib.parseDate = datesModule.parseDate;
	
	var searchModule = __webpack_require__(321);
	lib.findBin = searchModule.findBin;
	lib.sorterAsc = searchModule.sorterAsc;
	lib.sorterDes = searchModule.sorterDes;
	lib.distinctVals = searchModule.distinctVals;
	lib.roundUp = searchModule.roundUp;
	
	var statsModule = __webpack_require__(322);
	lib.aggNums = statsModule.aggNums;
	lib.len = statsModule.len;
	lib.mean = statsModule.mean;
	lib.variance = statsModule.variance;
	lib.stdev = statsModule.stdev;
	lib.interp = statsModule.interp;
	
	var matrixModule = __webpack_require__(323);
	lib.init2dArray = matrixModule.init2dArray;
	lib.transposeRagged = matrixModule.transposeRagged;
	lib.dot = matrixModule.dot;
	lib.translationMatrix = matrixModule.translationMatrix;
	lib.rotationMatrix = matrixModule.rotationMatrix;
	lib.rotationXYMatrix = matrixModule.rotationXYMatrix;
	lib.apply2DTransform = matrixModule.apply2DTransform;
	lib.apply2DTransform2 = matrixModule.apply2DTransform2;
	
	var extendModule = __webpack_require__(324);
	lib.extendFlat = extendModule.extendFlat;
	lib.extendDeep = extendModule.extendDeep;
	lib.extendDeepAll = extendModule.extendDeepAll;
	
	lib.notifier = __webpack_require__(325);
	
	/**
	 * swap x and y of the same attribute in container cont
	 * specify attr with a ? in place of x/y
	 * you can also swap other things than x/y by providing part1 and part2
	 */
	lib.swapAttrs = function(cont, attrList, part1, part2) {
	    if(!part1) part1 = 'x';
	    if(!part2) part2 = 'y';
	    for(var i = 0; i < attrList.length; i++) {
	        var attr = attrList[i],
	            xp = lib.nestedProperty(cont, attr.replace('?', part1)),
	            yp = lib.nestedProperty(cont, attr.replace('?', part2)),
	            temp = xp.get();
	        xp.set(yp.get());
	        yp.set(temp);
	    }
	};
	
	/**
	 * to prevent event bubbling, in particular text selection during drag.
	 * see http://stackoverflow.com/questions/5429827/
	 *      how-can-i-prevent-text-element-selection-with-cursor-drag
	 * for maximum effect use:
	 *      return pauseEvent(e);
	 */
	lib.pauseEvent = function(e) {
	    if(e.stopPropagation) e.stopPropagation();
	    if(e.preventDefault) e.preventDefault();
	    e.cancelBubble = true;
	    return false;
	};
	
	/**
	 * ------------------------------------------
	 * debugging tools
	 * ------------------------------------------
	 */
	
	// set VERBOSE to true to get a lot more logging and tracing
	lib.VERBOSE = false;
	
	// first markTime call will return time from page load
	lib.TIMER = new Date().getTime();
	
	// console.log that only runs if VERBOSE is on
	lib.log = function() {
	    if(lib.VERBOSE) console.log.apply(console, arguments);
	};
	
	/**
	 * markTime - for debugging, mark the number of milliseconds
	 * since the previous call to markTime and log arbitrary info too
	 */
	lib.markTime = function(v) {
	    if(!lib.VERBOSE) return;
	    var t2 = new Date().getTime();
	    console.log(v, t2 - lib.TIMER, '(msec)');
	    if(lib.VERBOSE === 'trace') console.trace();
	    lib.TIMER = t2;
	};
	
	// constrain - restrict a number v to be between v0 and v1
	lib.constrain = function(v, v0, v1) {
	    if(v0 > v1) return Math.max(v1, Math.min(v0, v));
	    return Math.max(v0, Math.min(v1, v));
	};
	
	/**
	 * do two bounding boxes from getBoundingClientRect,
	 * ie {left,right,top,bottom,width,height}, overlap?
	 * takes optional padding pixels
	 */
	lib.bBoxIntersect = function(a, b, pad) {
	    pad = pad || 0;
	    return (a.left <= b.right + pad &&
	            b.left <= a.right + pad &&
	            a.top <= b.bottom + pad &&
	            b.top <= a.bottom + pad);
	};
	
	// minor convenience/performance booster for d3...
	lib.identity = function(d) { return d; };
	
	// random string generator
	lib.randstr = function randstr(existing, bits, base) {
	    /*
	     * Include number of bits, the base of the string you want
	     * and an optional array of existing strings to avoid.
	     */
	    if(!base) base = 16;
	    if(bits === undefined) bits = 24;
	    if(bits <= 0) return '0';
	
	    var digits = Math.log(Math.pow(2, bits)) / Math.log(base),
	        res = '',
	        i,
	        b,
	        x;
	
	    for(i = 2; digits === Infinity; i *= 2) {
	        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
	    }
	
	    var rem = digits - Math.floor(digits);
	
	    for(i = 0; i < Math.floor(digits); i++) {
	        x = Math.floor(Math.random() * base).toString(base);
	        res = x + res;
	    }
	
	    if(rem) {
	        b = Math.pow(base, rem);
	        x = Math.floor(Math.random() * b).toString(base);
	        res = x + res;
	    }
	
	    var parsed = parseInt(res, base);
	    if((existing && (existing.indexOf(res) > -1)) ||
	         (parsed !== Infinity && parsed >= Math.pow(2, bits))) {
	        return randstr(existing, bits, base);
	    }
	    else return res;
	};
	
	lib.OptionControl = function(opt, optname) {
	    /*
	     * An environment to contain all option setters and
	     * getters that collectively modify opts.
	     *
	     * You can call up opts from any function in new object
	     * as this.optname || this.opt
	     *
	     * See FitOpts for example of usage
	     */
	    if(!opt) opt = {};
	    if(!optname) optname = 'opt';
	
	    var self = {};
	    self.optionList = [];
	
	    self._newoption = function(optObj) {
	        optObj[optname] = opt;
	        self[optObj.name] = optObj;
	        self.optionList.push(optObj);
	    };
	
	    self['_'+optname] = opt;
	    return self;
	};
	
	/**
	 * lib.smooth: smooth arrayIn by convolving with
	 * a hann window with given full width at half max
	 * bounce the ends in, so the output has the same length as the input
	 */
	lib.smooth = function(arrayIn, FWHM) {
	    FWHM = Math.round(FWHM) || 0; // only makes sense for integers
	    if(FWHM < 2) return arrayIn;
	
	    var alen = arrayIn.length,
	        alen2 = 2 * alen,
	        wlen = 2 * FWHM - 1,
	        w = new Array(wlen),
	        arrayOut = new Array(alen),
	        i,
	        j,
	        k,
	        v;
	
	    // first make the window array
	    for(i = 0; i < wlen; i++) {
	        w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
	    }
	
	    // now do the convolution
	    for(i = 0; i < alen; i++) {
	        v = 0;
	        for(j = 0; j < wlen; j++) {
	            k = i + j + 1 - FWHM;
	
	            // multibounce
	            if(k < -alen) k -= alen2 * Math.round(k / alen2);
	            else if(k >= alen2) k -= alen2 * Math.floor(k / alen2);
	
	            // single bounce
	            if(k < 0) k = - 1 - k;
	            else if(k >= alen) k = alen2 - 1 - k;
	
	            v += arrayIn[k] * w[j];
	        }
	        arrayOut[i] = v;
	    }
	
	    return arrayOut;
	};
	
	// helpers for promises
	
	/**
	 * promiseError: log errors properly inside promises
	 * use:
	 * <promise>.then(undefined,Plotly.Lib.promiseError) (for IE compatibility)
	 * or <promise>.catch(Plotly.Lib.promiseError)
	 * TODO: I guess we need another step to send this error to Sentry?
	 */
	lib.promiseError = function(err) { console.log(err, err.stack); };
	
	/**
	 * syncOrAsync: run a sequence of functions synchronously
	 * as long as its returns are not promises (ie have no .then)
	 * includes one argument arg to send to all functions...
	 * this is mainly just to prevent us having to make wrapper functions
	 * when the only purpose of the wrapper is to reference gd / td
	 * and a final step to be executed at the end
	 * TODO: if there's an error and everything is sync,
	 * this doesn't happen yet because we want to make sure
	 * that it gets reported
	 */
	lib.syncOrAsync = function(sequence, arg, finalStep) {
	    var ret, fni;
	
	    function continueAsync() {
	        lib.markTime('async done ' + fni.name);
	        return lib.syncOrAsync(sequence, arg, finalStep);
	    }
	    while(sequence.length) {
	        fni = sequence.splice(0, 1)[0];
	        ret = fni(arg);
	        // lib.markTime('done calling '+fni.name)
	        if(ret && ret.then) {
	            return ret.then(continueAsync)
	                .then(undefined, lib.promiseError);
	        }
	        lib.markTime('sync done ' + fni.name);
	    }
	
	    return finalStep && finalStep(arg);
	};
	
	
	/**
	 * Helper to strip trailing slash, from
	 * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash
	 */
	lib.stripTrailingSlash = function(str) {
	    if(str.substr(-1) === '/') return str.substr(0, str.length - 1);
	    return str;
	};
	
	lib.noneOrAll = function(containerIn, containerOut, attrList) {
	    /**
	     * some attributes come together, so if you have one of them
	     * in the input, you should copy the default values of the others
	     * to the input as well.
	     */
	    if(!containerIn) return;
	
	    var hasAny = false,
	        hasAll = true,
	        i,
	        val;
	
	    for(i = 0; i < attrList.length; i++) {
	        val = containerIn[attrList[i]];
	        if(val !== undefined && val !== null) hasAny = true;
	        else hasAll = false;
	    }
	
	    if(hasAny && !hasAll) {
	        for(i = 0; i < attrList.length; i++) {
	            containerIn[attrList[i]] = containerOut[attrList[i]];
	        }
	    }
	};
	
	/**
	 * Push array with unique items
	 *
	 * @param {array} array
	 *  array to be filled
	 * @param {any} item
	 *  item to be or not to be inserted
	 * @return {array}
	 *  ref to array (now possibly containing one more item)
	 *
	 */
	lib.pushUnique = function(array, item) {
	    if(item && array.indexOf(item) === -1) array.push(item);
	
	    return array;
	};
	
	lib.mergeArray = function(traceAttr, cd, cdAttr) {
	    if(Array.isArray(traceAttr)) {
	        var imax = Math.min(traceAttr.length, cd.length);
	        for(var i=0; i<imax; i++) cd[i][cdAttr] = traceAttr[i];
	    }
	};
	
	/**
	 * modified version of jQuery's extend to strip out private objs and functions,
	 * and cut arrays down to first <arraylen> or 1 elements
	 * because extend-like algorithms are hella slow
	 * obj2 is assumed to already be clean of these things (including no arrays)
	 */
	lib.minExtend = function(obj1, obj2) {
	    var objOut = {};
	    if(typeof obj2 !== 'object') obj2 = {};
	    var arrayLen = 3,
	        keys = Object.keys(obj1),
	        i,
	        k,
	        v;
	    for(i = 0; i < keys.length; i++) {
	        k = keys[i];
	        v = obj1[k];
	        if(k.charAt(0)==='_' || typeof v === 'function') continue;
	        else if(k==='module') objOut[k] = v;
	        else if(Array.isArray(v)) objOut[k] = v.slice(0,arrayLen);
	        else if(v && (typeof v === 'object')) objOut[k] = lib.minExtend(obj1[k], obj2[k]);
	        else objOut[k] = v;
	    }
	
	    keys = Object.keys(obj2);
	    for(i = 0; i < keys.length; i++) {
	        k = keys[i];
	        v = obj2[k];
	        if(typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {
	            objOut[k] = v;
	        }
	    }
	
	    return objOut;
	};
	
	lib.titleCase = function(s) {
	    return s.charAt(0).toUpperCase() + s.substr(1);
	};
	
	lib.containsAny = function(s, fragments) {
	    for(var i = 0; i < fragments.length; i++) {
	        if(s.indexOf(fragments[i])!== -1) return true;
	    }
	    return false;
	};
	
	// get the parent Plotly plot of any element. Whoo jquery-free tree climbing!
	lib.getPlotDiv = function(el) {
	    for(; el && el.removeAttribute; el = el.parentNode) {
	        if(lib.isPlotDiv(el)) return el;
	    }
	};
	
	lib.isPlotDiv = function(el) {
	    var el3 = d3.select(el);
	    return el3.size() && el3.classed('js-plotly-plot');
	};
	
	lib.removeElement = function(el) {
	    var elParent = el && el.parentNode;
	    if(elParent) elParent.removeChild(el);
	};
	
	/**
	 * for dynamically adding style rules
	 * makes one stylesheet that contains all rules added
	 * by all calls to this function
	 */
	lib.addStyleRule = function(selector, styleString) {
	    if(!lib.styleSheet) {
	        var style = document.createElement('style');
	        // WebKit hack :(
	        style.appendChild(document.createTextNode(''));
	        document.head.appendChild(style);
	        lib.styleSheet = style.sheet;
	    }
	    var styleSheet = lib.styleSheet;
	
	    if(styleSheet.insertRule) {
	        styleSheet.insertRule(selector+'{'+styleString+'}',0);
	    }
	    else if(styleSheet.addRule) {
	        styleSheet.addRule(selector,styleString,0);
	    }
	    else console.warn('addStyleRule failed');
	};
	
	lib.getTranslate = function(element) {
	
	    var re = /(\btranslate\()(\d*\.?\d*)([^\d]*)(\d*\.?\d*)([^\d]*)(.*)/,
	        getter = element.attr ? 'attr' : 'getAttribute',
	        transform = element[getter]('transform') || '';
	
	    var translate = transform.replace(re, function(match, p1, p2, p3, p4) {
	        return [p2, p4].join(' ');
	    })
	    .split(' ');
	
	    return {
	        x: +translate[0] || 0,
	        y: +translate[1] || 0
	    };
	};
	
	lib.setTranslate = function(element, x, y) {
	
	    var re = /(\btranslate\(.*?\);?)/,
	        getter = element.attr ? 'attr' : 'getAttribute',
	        setter = element.attr ? 'attr' : 'setAttribute',
	        transform = element[getter]('transform') || '';
	
	    x = x || 0;
	    y = y || 0;
	
	    transform = transform.replace(re, '').trim();
	    transform += ' translate(' + x + ', ' + y + ')';
	    transform = transform.trim();
	
	    element[setter]('transform', transform);
	
	    return transform;
	};
	
	lib.isIE = function() {
	    return typeof window.navigator.msSaveBlob !== 'undefined';
	};
	
	
	/**
	 * Converts a string path to an object.
	 *
	 * When given a string containing an array element, it will create a `null`
	 * filled array of the given size.
	 *
	 * @example
	 * lib.objectFromPath('nested.test[2].path', 'value');
	 * // returns { nested: { test: [null, null, { path: 'value' }]}
	 *
	 * @param   {string}    path to nested value
	 * @param   {*}         any value to be set
	 *
	 * @return {Object} the constructed object with a full nested path
	 */
	lib.objectFromPath = function(path, value) {
	    var keys = path.split('.'),
	        tmpObj,
	        obj = tmpObj = {};
	
	    for(var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var el = null;
	
	        var parts = keys[i].match(/(.*)\[([0-9]+)\]/);
	
	        if(parts) {
	            key = parts[1];
	            el = parts[2];
	
	            tmpObj = tmpObj[key] = [];
	
	            if(i === keys.length - 1) {
	                tmpObj[el] = value;
	            } else {
	                tmpObj[el] = {};
	            }
	
	            tmpObj = tmpObj[el];
	        } else {
	
	            if(i === keys.length - 1) {
	                tmpObj[key] = value;
	            } else {
	                tmpObj[key] = {};
	            }
	
	            tmpObj = tmpObj[key];
	        }
	    }
	
	    return obj;
	};


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.17"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.transpose = function(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  };
	  function d3_transposeLength(d) {
	    return d.length;
	  }
	  d3.zip = function() {
	    return d3.transpose(arguments);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: d3_nsXhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (node = group[i]) {
	            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
	              exitNodes[i] = node;
	            } else {
	              nodeByKeyValue.set(keyValue, node);
	            }
	            keyValues[i] = keyValue;
	          }
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = d3_array(nodes);
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
	    if (d2 < ε2) {
	      S = Math.log(w1 / w0) / ρ;
	      i = function(t) {
	        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
	      };
	    } else {
	      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / ρ;
	      i = function(t) {
	        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      };
	    }
	    i.duration = S * 1e3;
	    return i;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: null
	      };
	      scaleTo(+_);
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function() {
	    d3_timer.apply(this, arguments);
	  };
	  function d3_timer(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	    return timer;
	  }
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now(), timer = d3_timer_queueHead;
	    while (timer) {
	      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
	      timer = timer.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.c) {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      } else {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value = +value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;
	
	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;
	
	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;
	
	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransformPop(s) {
	    return s.length ? s.pop() + "," : "";
	  }
	  function d3_interpolateTranslate(ta, tb, s, q) {
	    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
	      var i = s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    }
	  }
	  function d3_interpolateRotate(ra, rb, s, q) {
	    if (ra !== rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
	    }
	  }
	  function d3_interpolateSkew(wa, wb, s, q) {
	    if (wa !== wb) {
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
	    }
	  }
	  function d3_interpolateScale(ka, kb, s, q) {
	    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
	      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] !== 1 || kb[1] !== 1) {
	      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
	    }
	  }
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [];
	    a = d3.transform(a), b = d3.transform(b);
	    d3_interpolateTranslate(a.translate, b.translate, s, q);
	    d3_interpolateRotate(a.rotate, b.rotate, s, q);
	    d3_interpolateSkew(a.skew, b.skew, s, q);
	    d3_interpolateScale(a.scale, b.scale, s, q);
	    a = b = null;
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: groupSums[di]
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        timer = null;
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) {
	          alpha = x;
	        } else {
	          timer.c = null, timer.t = NaN, timer = null;
	          event.end({
	            type: "end",
	            alpha: alpha = 0
	          });
	        }
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        timer = d3_timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = root.y = 0;
	      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    return domain;
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(1, base * n / scale.ticks().length);
	      return function(d) {
	        var i = d / pow(Math.round(log(d)));
	        if (i * base < base - .5) i *= base;
	        return i <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var rc1 = rc, rc0 = rc;
	        if (da < π) {
	          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
	          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
	        }
	        if (x1 != null) {
	          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.length > 1 ? points.join("L") : points + "Z";
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return points.join("L") + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, activeId, active;
	      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        if (--lock.count) delete lock[activeId]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id], time, timer, duration, ease, tweens;
	    function schedule(elapsed) {
	      var delay = transition.delay;
	      timer.t = delay + time;
	      if (delay <= elapsed) return start(elapsed - delay);
	      timer.c = start;
	    }
	    function start(elapsed) {
	      var activeId = lock.active, active = lock[activeId];
	      if (active) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        --lock.count;
	        delete lock[activeId];
	        active.event && active.event.interrupt.call(node, node.__data__, active.index);
	      }
	      for (var cancelId in lock) {
	        if (+cancelId < id) {
	          var cancel = lock[cancelId];
	          cancel.timer.c = null;
	          cancel.timer.t = NaN;
	          --lock.count;
	          delete lock[cancelId];
	        }
	      }
	      timer.c = tick;
	      d3_timer(function() {
	        if (timer.c && tick(elapsed || 1)) {
	          timer.c = null;
	          timer.t = NaN;
	        }
	        return 1;
	      }, 0, time);
	      lock.active = id;
	      transition.event && transition.event.start.call(node, node.__data__, i);
	      tweens = [];
	      transition.tween.forEach(function(key, value) {
	        if (value = value.call(node, node.__data__, i)) {
	          tweens.push(value);
	        }
	      });
	      ease = transition.ease;
	      duration = transition.duration;
	    }
	    function tick(elapsed) {
	      var t = elapsed / duration, e = ease(t), n = tweens.length;
	      while (n > 0) {
	        tweens[--n].call(node, e);
	      }
	      if (t >= 1) {
	        transition.event && transition.event.end.call(node, node.__data__, i);
	        if (--lock.count) delete lock[id]; else delete node[ns];
	        return 1;
	      }
	    }
	    if (!transition) {
	      time = inherit.time;
	      timer = d3_timer(schedule, 0, time);
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        timer: timer,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = d3_array(arguments);
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
	}();

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	/**
	 * convert a string s (such as 'xaxis.range[0]')
	 * representing a property of nested object into set and get methods
	 * also return the string and object so we don't have to keep track of them
	 * allows [-1] for an array index, to set a property inside all elements
	 * of an array
	 * eg if obj = {arr: [{a: 1}, {a: 2}]}
	 * you can do p = nestedProperty(obj, 'arr[-1].a')
	 * but you cannot set the array itself this way, to do that
	 * just set the whole array.
	 * eg if obj = {arr: [1, 2, 3]}
	 * you can't do nestedProperty(obj, 'arr[-1]').set(5)
	 * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])
	 */
	module.exports = function nestedProperty(container, propStr) {
	    if(isNumeric(propStr)) propStr = String(propStr);
	    else if(typeof propStr !== 'string' ||
	            propStr.substr(propStr.length - 4) === '[-1]') {
	        throw 'bad property string';
	    }
	
	    var j = 0,
	        propParts = propStr.split('.'),
	        indexed,
	        indices,
	        i;
	
	    // check for parts of the nesting hierarchy that are numbers (ie array elements)
	    while(j < propParts.length) {
	        // look for non-bracket chars, then any number of [##] blocks
	        indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
	        if(indexed) {
	            if(indexed[1]) propParts[j] = indexed[1];
	            // allow propStr to start with bracketed array indices
	            else if(j === 0) propParts.splice(0,1);
	            else throw 'bad property string';
	
	            indices = indexed[2]
	                .substr(1,indexed[2].length-2)
	                .split('][');
	
	            for(i=0; i<indices.length; i++) {
	                j++;
	                propParts.splice(j,0,Number(indices[i]));
	            }
	        }
	        j++;
	    }
	
	    if(typeof container !== 'object') {
	        return badContainer(container, propStr, propParts);
	    }
	
	    return {
	        set: npSet(container, propParts),
	        get: npGet(container, propParts),
	        astr: propStr,
	        parts: propParts,
	        obj: container
	    };
	};
	
	function npGet(cont, parts) {
	    return function() {
	        var curCont = cont,
	            curPart,
	            allSame,
	            out,
	            i,
	            j;
	
	        for(i = 0; i < parts.length - 1; i++) {
	            curPart = parts[i];
	            if(curPart===-1) {
	                allSame = true;
	                out = [];
	                for(j = 0; j < curCont.length; j++) {
	                    out[j] = npGet(curCont[j], parts.slice(i + 1))();
	                    if(out[j]!==out[0]) allSame = false;
	                }
	                return allSame ? out[0] : out;
	            }
	            if(typeof curPart === 'number' && !Array.isArray(curCont)) {
	                return undefined;
	            }
	            curCont = curCont[curPart];
	            if(typeof curCont !== 'object' || curCont === null) {
	                return undefined;
	            }
	        }
	
	        // only hit this if parts.length === 1
	        if(typeof curCont !== 'object' || curCont === null) return undefined;
	
	        out = curCont[parts[i]];
	        if(out === null) return undefined;
	        return out;
	    };
	}
	
	/*
	 * Check known non-data-array arrays (containers). Data arrays only contain scalars,
	 * so parts[end] values, such as -1 or n, indicate we are not dealing with a dataArray.
	 * The ONLY case we are looking for is where the entire array is selected, parts[end] === 'x'
	 * AND the replacement value is an array.
	 */
	function isDataArray(val, key) {
	
	    var containers = ['annotations', 'shapes', 'range', 'domain', 'buttons'],
	        isNotAContainer = containers.indexOf(key) === -1;
	
	    return Array.isArray(val) && isNotAContainer;
	}
	
	function npSet(cont, parts) {
	    return function(val) {
	        var curCont = cont,
	            containerLevels = [cont],
	            toDelete = emptyObj(val) && !isDataArray(val, parts[parts.length-1]),
	            curPart,
	            i;
	
	        for(i = 0; i < parts.length - 1; i++) {
	            curPart = parts[i];
	
	            if(typeof curPart === 'number' && !Array.isArray(curCont)) {
	                throw 'array index but container is not an array';
	            }
	
	            // handle special -1 array index
	            if(curPart===-1) {
	                toDelete = !setArrayAll(curCont, parts.slice(i + 1), val);
	                if(toDelete) break;
	                else return;
	            }
	
	            if(!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {
	                break;
	            }
	
	            curCont = curCont[curPart];
	
	            if(typeof curCont !== 'object' || curCont === null) {
	                throw 'container is not an object';
	            }
	
	            containerLevels.push(curCont);
	        }
	
	        if(toDelete) {
	            if(i === parts.length - 1) delete curCont[parts[i]];
	            pruneContainers(containerLevels);
	        }
	        else curCont[parts[i]] = val;
	    };
	}
	
	// handle special -1 array index
	function setArrayAll(containerArray, innerParts, val) {
	    var arrayVal = Array.isArray(val),
	        allSet = true,
	        thisVal = val,
	        deleteThis = arrayVal ? false : emptyObj(val),
	        firstPart = innerParts[0],
	        i;
	
	    for(i = 0; i < containerArray.length; i++) {
	        if(arrayVal) {
	            thisVal = val[i % val.length];
	            deleteThis = emptyObj(thisVal);
	        }
	        if(deleteThis) allSet = false;
	        if(!checkNewContainer(containerArray, i, firstPart, deleteThis)) {
	            continue;
	        }
	        npSet(containerArray[i], innerParts)(thisVal);
	    }
	    return allSet;
	}
	
	/**
	 * make new sub-container as needed.
	 * returns false if there's no container and none is needed
	 * because we're only deleting an attribute
	 */
	function checkNewContainer(container, part, nextPart, toDelete) {
	    if(container[part] === undefined) {
	        if(toDelete) return false;
	
	        if(typeof nextPart === 'number') container[part] = [];
	        else container[part] = {};
	    }
	    return true;
	}
	
	function pruneContainers(containerLevels) {
	    var i,
	        j,
	        curCont,
	        keys,
	        remainingKeys;
	    for(i = containerLevels.length - 1; i >= 0; i--) {
	        curCont = containerLevels[i];
	        remainingKeys = false;
	        if(Array.isArray(curCont)) {
	            for(j = curCont.length - 1; j >= 0; j--) {
	                if(emptyObj(curCont[j])) {
	                    if(remainingKeys) curCont[j] = undefined;
	                    else curCont.pop();
	                }
	                else remainingKeys = true;
	            }
	        }
	        else if(typeof curCont === 'object' && curCont !== null) {
	            keys = Object.keys(curCont);
	            remainingKeys = false;
	            for(j = keys.length - 1; j >= 0; j--) {
	                if(emptyObj(curCont[keys[j]]) && !isDataArray(curCont[keys[j]], keys[j])) delete curCont[keys[j]];
	                else remainingKeys = true;
	            }
	        }
	        if(remainingKeys) return;
	    }
	}
	
	function emptyObj(obj) {
	    if(obj===undefined || obj===null) return true;
	    if(typeof obj !== 'object') return false; // any plain value
	    if(Array.isArray(obj)) return !obj.length; // []
	    return !Object.keys(obj).length; // {}
	}
	
	function badContainer(container, propStr, propParts) {
	    return {
	        set: function() { throw 'bad container'; },
	        get: function() {},
	        astr: propStr,
	        parts: propParts,
	        obj: container
	    };
	}


/***/ },
/* 312 */
/***/ function(module, exports) {

	/**
	 * inspired by is-number <https://github.com/jonschlinkert/is-number>
	 * but significantly simplified and sped up by ignoring number and string constructors
	 * ie these return false:
	 *   new Number(1)
	 *   new String('1')
	 */
	
	'use strict';
	
	/**
	 * Is this string all whitespace?
	 * This solution kind of makes my brain hurt, but it's significantly faster
	 * than !str.trim() or any other solution I could find.
	 *
	 * whitespace codes from: http://en.wikipedia.org/wiki/Whitespace_character
	 * and verified with:
	 *
	 *  for(var i = 0; i < 65536; i++) {
	 *      var s = String.fromCharCode(i);
	 *      if(+s===0 && !s.trim()) console.log(i, s);
	 *  }
	 *
	 * which counts a couple of these as *not* whitespace, but finds nothing else
	 * that *is* whitespace. Note that charCodeAt stops at 16 bits, but it appears
	 * that there are no whitespace characters above this, and code points above
	 * this do not map onto white space characters.
	 */
	function allBlankCharCodes(str){
	    var l = str.length,
	        a;
	    for(var i = 0; i < l; i++) {
	        a = str.charCodeAt(i);
	        if((a < 9 || a > 13) && (a !== 32) && (a !== 133) && (a !== 160) &&
	            (a !== 5760) && (a !== 6158) && (a < 8192 || a > 8205) &&
	            (a !== 8232) && (a !== 8233) && (a !== 8239) && (a !== 8287) &&
	            (a !== 8288) && (a !== 12288) && (a !== 65279)) {
	                return false;
	        }
	    }
	    return true;
	}
	
	module.exports = function(n) {
	    var type = typeof n;
	    if(type === 'string') {
	        var original = n;
	        n = +n;
	        // whitespace strings cast to zero - filter them out
	        if(n===0 && allBlankCharCodes(original)) return false;
	    }
	    else if(type !== 'number') return false;
	
	    return n - n < 1;
	};


/***/ },
/* 313 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	// more info: http://stackoverflow.com/questions/18531624/isplainobject-thing
	module.exports = function isPlainObject(obj) {
	    return (
	        Object.prototype.toString.call(obj) === '[object Object]' &&
	        Object.getPrototypeOf(obj) === Object.prototype
	    );
	};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	var tinycolor = __webpack_require__(315);
	var nestedProperty = __webpack_require__(311);
	
	var getColorscale = __webpack_require__(316);
	var colorscaleNames = Object.keys(__webpack_require__(317));
	
	var idRegex = /^([2-9]|[1-9][0-9]+)$/;
	
	exports.valObjects = {
	    data_array: {
	        // You can use *dflt=[] to force said array to exist though.
	        description: [
	            'An {array} of data.',
	            'The value MUST be an {array}, or we ignore it.'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            if(Array.isArray(v)) propOut.set(v);
	            else if(dflt!==undefined) propOut.set(dflt);
	        }
	    },
	    enumerated: {
	        description: [
	            'Enumerated value type. The available values are listed',
	            'in `values`.'
	        ].join(' '),
	        requiredOpts: ['values'],
	        otherOpts: ['dflt', 'coerceNumber', 'arrayOk'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(opts.coerceNumber) v = +v;
	            if(opts.values.indexOf(v)===-1) propOut.set(dflt);
	            else propOut.set(v);
	        }
	    },
	    'boolean': {
	        description: 'A boolean (true/false) value.',
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            if(v===true || v===false) propOut.set(v);
	            else propOut.set(dflt);
	        }
	    },
	    number: {
	        description: [
	            'A number or a numeric value',
	            '(e.g. a number inside a string).',
	            'When applicable, values greater (less) than `max` (`min`)',
	            'are coerced to the `dflt`.'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt', 'min', 'max', 'arrayOk'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(!isNumeric(v) ||
	                    (opts.min!==undefined && v<opts.min) ||
	                    (opts.max!==undefined && v>opts.max)) {
	                propOut.set(dflt);
	            }
	            else propOut.set(+v);
	        }
	    },
	    integer: {
	        description: [
	            'An integer or an integer inside a string.',
	            'When applicable, values greater (less) than `max` (`min`)',
	            'are coerced to the `dflt`.'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt', 'min', 'max'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(v%1 || !isNumeric(v) ||
	                    (opts.min!==undefined && v<opts.min) ||
	                    (opts.max!==undefined && v>opts.max)) {
	                propOut.set(dflt);
	            }
	            else propOut.set(+v);
	        }
	    },
	    string: {
	        description: [
	            'A string value.',
	            'Numbers are converted to strings except for attributes with',
	            '`strict` set to true.'
	        ].join(' '),
	        requiredOpts: [],
	        // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)
	        otherOpts: ['dflt', 'noBlank', 'strict', 'arrayOk', 'values'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(opts.strict===true && typeof v !== 'string') {
	                propOut.set(dflt);
	                return;
	            }
	
	            var s = String(v);
	            if(v===undefined || (opts.noBlank===true && !s)) {
	                propOut.set(dflt);
	            }
	            else propOut.set(s);
	        }
	    },
	    color: {
	        description: [
	            'A string describing color.',
	            'Supported formats:',
	            '- hex (e.g. \'#d3d3d3\')',
	            '- rgb (e.g. \'rgb(255, 0, 0)\')',
	            '- rgba (e.g. \'rgb(255, 0, 0, 0.5)\')',
	            '- hsl (e.g. \'hsl(0, 100%, 50%)\')',
	            '- hsv (e.g. \'hsv(0, 100%, 100%)\')',
	            '- named colors (full list: http://www.w3.org/TR/css3-color/#svg-color)'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt', 'arrayOk'],
	        coerceFunction: function(v, propOut, dflt) {
	            if(tinycolor(v).isValid()) propOut.set(v);
	            else propOut.set(dflt);
	        }
	    },
	    colorscale: {
	        description: [
	            'A Plotly colorscale either picked by a name:',
	            '(any of', colorscaleNames.join(', '), ')',
	            'customized as an {array} of 2-element {arrays} where',
	            'the first element is the normalized color level value',
	            '(starting at *0* and ending at *1*),',
	            'and the second item is a valid color string.'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            propOut.set(getColorscale(v, dflt));
	        }
	    },
	    angle: {
	        description: [
	            'A number (in degree) between -180 and 180.'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            if(v==='auto') propOut.set('auto');
	            else if(!isNumeric(v)) propOut.set(dflt);
	            else {
	                if(Math.abs(v)>180) v -= Math.round(v/360)*360;
	                propOut.set(+v);
	            }
	        }
	    },
	    subplotid: {
	        description: [
	            'An id string of a subplot type (given by dflt), optionally',
	            'followed by an integer >1. e.g. if dflt=\'geo\', we can  have',
	            '\'geo\', \'geo2\', \'geo3\', ...'
	        ].join(' '),
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            var dlen = dflt.length;
	            if(typeof v === 'string' && v.substr(0, dlen) === dflt &&
	                    idRegex.test(v.substr(dlen))) {
	                propOut.set(v);
	                return;
	            }
	            propOut.set(dflt);
	        }
	    },
	    flaglist: {
	        description: [
	            'A string representing a combination of flags',
	            '(order does not matter here).',
	            'Combine any of the available `flags` with *+*.',
	            '(e.g. (\'lines+markers\')).',
	            'Values in `extras` cannot be combined.'
	        ].join(' '),
	        requiredOpts: ['flags'],
	        otherOpts: ['dflt', 'extras'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(typeof v !== 'string') {
	                propOut.set(dflt);
	                return;
	            }
	            if(opts.extras.indexOf(v)!==-1) {
	                propOut.set(v);
	                return;
	            }
	            var vParts = v.split('+'),
	                i = 0;
	            while(i<vParts.length) {
	                var vi = vParts[i];
	                if(opts.flags.indexOf(vi)===-1 || vParts.indexOf(vi)<i) {
	                    vParts.splice(i,1);
	                }
	                else i++;
	            }
	            if(!vParts.length) propOut.set(dflt);
	            else propOut.set(vParts.join('+'));
	        }
	    },
	    any: {
	        description: 'Any type.',
	        requiredOpts: [],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt) {
	            if(v===undefined) propOut.set(dflt);
	            else propOut.set(v);
	        }
	    },
	    info_array: {
	        description: [
	            'An {array} of plot information.'
	        ].join(' '),
	        requiredOpts: ['items'],
	        otherOpts: ['dflt'],
	        coerceFunction: function(v, propOut, dflt, opts) {
	            if(!Array.isArray(v)) {
	                propOut.set(dflt);
	                return;
	            }
	
	            var items = opts.items,
	                vOut = [];
	            dflt = Array.isArray(dflt) ? dflt : [];
	
	            for(var i = 0; i < items.length; i++) {
	                exports.coerce(v, vOut, items, '[' + i + ']', dflt[i]);
	            }
	
	            propOut.set(vOut);
	        }
	    }
	};
	
	/**
	 * Ensures that container[attribute] has a valid value.
	 *
	 * attributes[attribute] is an object with possible keys:
	 * - valType: data_array, enumerated, boolean, ... as in valObjects
	 * - values: (enumerated only) array of allowed vals
	 * - min, max: (number, integer only) inclusive bounds on allowed vals
	 *      either or both may be omitted
	 * - dflt: if attribute is invalid or missing, use this default
	 *      if dflt is provided as an argument to lib.coerce it takes precedence
	 *      as a convenience, returns the value it finally set
	 */
	exports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {
	    var opts = nestedProperty(attributes, attribute).get(),
	        propIn = nestedProperty(containerIn, attribute),
	        propOut = nestedProperty(containerOut, attribute),
	        v = propIn.get();
	
	    if(dflt===undefined) dflt = opts.dflt;
	
	    /**
	     * arrayOk: value MAY be an array, then we do no value checking
	     * at this point, because it can be more complicated than the
	     * individual form (eg. some array vals can be numbers, even if the
	     * single values must be color strings)
	     */
	    if(opts.arrayOk && Array.isArray(v)) {
	        propOut.set(v);
	        return v;
	    }
	
	    exports.valObjects[opts.valType].coerceFunction(v, propOut, dflt, opts);
	
	    return propOut.get();
	};
	
	/**
	 * Variation on coerce
	 *
	 * Uses coerce to get attribute value if user input is valid,
	 * returns attribute default if user input it not valid or
	 * returns false if there is no user input.
	 */
	exports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {
	    var propIn = nestedProperty(containerIn, attribute),
	        propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);
	
	    return propIn.get() ? propOut : false;
	};
	
	/*
	 * Shortcut to coerce the three font attributes
	 *
	 * 'coerce' is a lib.coerce wrapper with implied first three arguments
	 */
	exports.coerceFont = function(coerce, attr, dfltObj) {
	    var out = {};
	
	    dfltObj = dfltObj || {};
	
	    out.family = coerce(attr + '.family', dfltObj.family);
	    out.size = coerce(attr + '.size', dfltObj.size);
	    out.color = coerce(attr + '.color', dfltObj.color);
	
	    return out;
	};


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.3.0
	// https://github.com/bgrins/TinyColor
	// Brian Grinstead, MIT License
	
	(function() {
	
	var trimLeft = /^\s+/,
	    trimRight = /\s+$/,
	    tinyCounter = 0,
	    math = Math,
	    mathRound = math.round,
	    mathMin = math.min,
	    mathMax = math.max,
	    mathRandom = math.random;
	
	function tinycolor (color, opts) {
	
	    color = (color) ? color : '';
	    opts = opts || { };
	
	    // If input is already a tinycolor, return itself
	    if (color instanceof tinycolor) {
	       return color;
	    }
	    // If we are called as a function, call using new instead
	    if (!(this instanceof tinycolor)) {
	        return new tinycolor(color, opts);
	    }
	
	    var rgb = inputToRGB(color);
	    this._originalInput = color,
	    this._r = rgb.r,
	    this._g = rgb.g,
	    this._b = rgb.b,
	    this._a = rgb.a,
	    this._roundA = mathRound(100*this._a) / 100,
	    this._format = opts.format || rgb.format;
	    this._gradientType = opts.gradientType;
	
	    // Don't let the range of [0,255] come back in [0,1].
	    // Potentially lose a little bit of precision here, but will fix issues where
	    // .5 gets interpreted as half of the total, instead of half of 1
	    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
	    if (this._r < 1) { this._r = mathRound(this._r); }
	    if (this._g < 1) { this._g = mathRound(this._g); }
	    if (this._b < 1) { this._b = mathRound(this._b); }
	
	    this._ok = rgb.ok;
	    this._tc_id = tinyCounter++;
	}
	
	tinycolor.prototype = {
	    isDark: function() {
	        return this.getBrightness() < 128;
	    },
	    isLight: function() {
	        return !this.isDark();
	    },
	    isValid: function() {
	        return this._ok;
	    },
	    getOriginalInput: function() {
	      return this._originalInput;
	    },
	    getFormat: function() {
	        return this._format;
	    },
	    getAlpha: function() {
	        return this._a;
	    },
	    getBrightness: function() {
	        //http://www.w3.org/TR/AERT#color-contrast
	        var rgb = this.toRgb();
	        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
	    },
	    getLuminance: function() {
	        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
	        var rgb = this.toRgb();
	        var RsRGB, GsRGB, BsRGB, R, G, B;
	        RsRGB = rgb.r/255;
	        GsRGB = rgb.g/255;
	        BsRGB = rgb.b/255;
	
	        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
	        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
	        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
	        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
	    },
	    setAlpha: function(value) {
	        this._a = boundAlpha(value);
	        this._roundA = mathRound(100*this._a) / 100;
	        return this;
	    },
	    toHsv: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
	    },
	    toHsvString: function() {
	        var hsv = rgbToHsv(this._r, this._g, this._b);
	        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
	        return (this._a == 1) ?
	          "hsv("  + h + ", " + s + "%, " + v + "%)" :
	          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
	    },
	    toHsl: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
	    },
	    toHslString: function() {
	        var hsl = rgbToHsl(this._r, this._g, this._b);
	        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
	        return (this._a == 1) ?
	          "hsl("  + h + ", " + s + "%, " + l + "%)" :
	          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
	    },
	    toHex: function(allow3Char) {
	        return rgbToHex(this._r, this._g, this._b, allow3Char);
	    },
	    toHexString: function(allow3Char) {
	        return '#' + this.toHex(allow3Char);
	    },
	    toHex8: function() {
	        return rgbaToHex(this._r, this._g, this._b, this._a);
	    },
	    toHex8String: function() {
	        return '#' + this.toHex8();
	    },
	    toRgb: function() {
	        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
	    },
	    toRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
	          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
	    },
	    toPercentageRgb: function() {
	        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
	    },
	    toPercentageRgbString: function() {
	        return (this._a == 1) ?
	          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
	          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
	    },
	    toName: function() {
	        if (this._a === 0) {
	            return "transparent";
	        }
	
	        if (this._a < 1) {
	            return false;
	        }
	
	        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
	    },
	    toFilter: function(secondColor) {
	        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
	        var secondHex8String = hex8String;
	        var gradientType = this._gradientType ? "GradientType = 1, " : "";
	
	        if (secondColor) {
	            var s = tinycolor(secondColor);
	            secondHex8String = s.toHex8String();
	        }
	
	        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
	    },
	    toString: function(format) {
	        var formatSet = !!format;
	        format = format || this._format;
	
	        var formattedString = false;
	        var hasAlpha = this._a < 1 && this._a >= 0;
	        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");
	
	        if (needsAlphaFormat) {
	            // Special case for "transparent", all other non-alpha formats
	            // will return rgba when there is transparency.
	            if (format === "name" && this._a === 0) {
	                return this.toName();
	            }
	            return this.toRgbString();
	        }
	        if (format === "rgb") {
	            formattedString = this.toRgbString();
	        }
	        if (format === "prgb") {
	            formattedString = this.toPercentageRgbString();
	        }
	        if (format === "hex" || format === "hex6") {
	            formattedString = this.toHexString();
	        }
	        if (format === "hex3") {
	            formattedString = this.toHexString(true);
	        }
	        if (format === "hex8") {
	            formattedString = this.toHex8String();
	        }
	        if (format === "name") {
	            formattedString = this.toName();
	        }
	        if (format === "hsl") {
	            formattedString = this.toHslString();
	        }
	        if (format === "hsv") {
	            formattedString = this.toHsvString();
	        }
	
	        return formattedString || this.toHexString();
	    },
	    clone: function() {
	        return tinycolor(this.toString());
	    },
	
	    _applyModification: function(fn, args) {
	        var color = fn.apply(null, [this].concat([].slice.call(args)));
	        this._r = color._r;
	        this._g = color._g;
	        this._b = color._b;
	        this.setAlpha(color._a);
	        return this;
	    },
	    lighten: function() {
	        return this._applyModification(lighten, arguments);
	    },
	    brighten: function() {
	        return this._applyModification(brighten, arguments);
	    },
	    darken: function() {
	        return this._applyModification(darken, arguments);
	    },
	    desaturate: function() {
	        return this._applyModification(desaturate, arguments);
	    },
	    saturate: function() {
	        return this._applyModification(saturate, arguments);
	    },
	    greyscale: function() {
	        return this._applyModification(greyscale, arguments);
	    },
	    spin: function() {
	        return this._applyModification(spin, arguments);
	    },
	
	    _applyCombination: function(fn, args) {
	        return fn.apply(null, [this].concat([].slice.call(args)));
	    },
	    analogous: function() {
	        return this._applyCombination(analogous, arguments);
	    },
	    complement: function() {
	        return this._applyCombination(complement, arguments);
	    },
	    monochromatic: function() {
	        return this._applyCombination(monochromatic, arguments);
	    },
	    splitcomplement: function() {
	        return this._applyCombination(splitcomplement, arguments);
	    },
	    triad: function() {
	        return this._applyCombination(triad, arguments);
	    },
	    tetrad: function() {
	        return this._applyCombination(tetrad, arguments);
	    }
	};
	
	// If input is an object, force 1 into "1.0" to handle ratios properly
	// String input requires "1.0" as input, so 1 will be treated as 1
	tinycolor.fromRatio = function(color, opts) {
	    if (typeof color == "object") {
	        var newColor = {};
	        for (var i in color) {
	            if (color.hasOwnProperty(i)) {
	                if (i === "a") {
	                    newColor[i] = color[i];
	                }
	                else {
	                    newColor[i] = convertToPercentage(color[i]);
	                }
	            }
	        }
	        color = newColor;
	    }
	
	    return tinycolor(color, opts);
	};
	
	// Given a string or object, convert that input to RGB
	// Possible string inputs:
	//
	//     "red"
	//     "#f00" or "f00"
	//     "#ff0000" or "ff0000"
	//     "#ff000000" or "ff000000"
	//     "rgb 255 0 0" or "rgb (255, 0, 0)"
	//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
	//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
	//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
	//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
	//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
	//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
	//
	function inputToRGB(color) {
	
	    var rgb = { r: 0, g: 0, b: 0 };
	    var a = 1;
	    var ok = false;
	    var format = false;
	
	    if (typeof color == "string") {
	        color = stringInputToObject(color);
	    }
	
	    if (typeof color == "object") {
	        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
	            rgb = rgbToRgb(color.r, color.g, color.b);
	            ok = true;
	            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
	        }
	        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
	            color.s = convertToPercentage(color.s);
	            color.v = convertToPercentage(color.v);
	            rgb = hsvToRgb(color.h, color.s, color.v);
	            ok = true;
	            format = "hsv";
	        }
	        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
	            color.s = convertToPercentage(color.s);
	            color.l = convertToPercentage(color.l);
	            rgb = hslToRgb(color.h, color.s, color.l);
	            ok = true;
	            format = "hsl";
	        }
	
	        if (color.hasOwnProperty("a")) {
	            a = color.a;
	        }
	    }
	
	    a = boundAlpha(a);
	
	    return {
	        ok: ok,
	        format: color.format || format,
	        r: mathMin(255, mathMax(rgb.r, 0)),
	        g: mathMin(255, mathMax(rgb.g, 0)),
	        b: mathMin(255, mathMax(rgb.b, 0)),
	        a: a
	    };
	}
	
	
	// Conversion Functions
	// --------------------
	
	// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
	// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
	
	// `rgbToRgb`
	// Handle bounds / percentage checking to conform to CSS color spec
	// <http://www.w3.org/TR/css3-color/>
	// *Assumes:* r, g, b in [0, 255] or [0, 1]
	// *Returns:* { r, g, b } in [0, 255]
	function rgbToRgb(r, g, b){
	    return {
	        r: bound01(r, 255) * 255,
	        g: bound01(g, 255) * 255,
	        b: bound01(b, 255) * 255
	    };
	}
	
	// `rgbToHsl`
	// Converts an RGB color value to HSL.
	// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
	// *Returns:* { h, s, l } in [0,1]
	function rgbToHsl(r, g, b) {
	
	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);
	
	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, l = (max + min) / 2;
	
	    if(max == min) {
	        h = s = 0; // achromatic
	    }
	    else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	
	        h /= 6;
	    }
	
	    return { h: h, s: s, l: l };
	}
	
	// `hslToRgb`
	// Converts an HSL color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	function hslToRgb(h, s, l) {
	    var r, g, b;
	
	    h = bound01(h, 360);
	    s = bound01(s, 100);
	    l = bound01(l, 100);
	
	    function hue2rgb(p, q, t) {
	        if(t < 0) t += 1;
	        if(t > 1) t -= 1;
	        if(t < 1/6) return p + (q - p) * 6 * t;
	        if(t < 1/2) return q;
	        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	        return p;
	    }
	
	    if(s === 0) {
	        r = g = b = l; // achromatic
	    }
	    else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }
	
	    return { r: r * 255, g: g * 255, b: b * 255 };
	}
	
	// `rgbToHsv`
	// Converts an RGB color value to HSV
	// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	// *Returns:* { h, s, v } in [0,1]
	function rgbToHsv(r, g, b) {
	
	    r = bound01(r, 255);
	    g = bound01(g, 255);
	    b = bound01(b, 255);
	
	    var max = mathMax(r, g, b), min = mathMin(r, g, b);
	    var h, s, v = max;
	
	    var d = max - min;
	    s = max === 0 ? 0 : d / max;
	
	    if(max == min) {
	        h = 0; // achromatic
	    }
	    else {
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h /= 6;
	    }
	    return { h: h, s: s, v: v };
	}
	
	// `hsvToRgb`
	// Converts an HSV color value to RGB.
	// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	// *Returns:* { r, g, b } in the set [0, 255]
	 function hsvToRgb(h, s, v) {
	
	    h = bound01(h, 360) * 6;
	    s = bound01(s, 100);
	    v = bound01(v, 100);
	
	    var i = math.floor(h),
	        f = h - i,
	        p = v * (1 - s),
	        q = v * (1 - f * s),
	        t = v * (1 - (1 - f) * s),
	        mod = i % 6,
	        r = [v, q, p, p, t, v][mod],
	        g = [t, v, v, q, p, p][mod],
	        b = [p, p, t, v, v, q][mod];
	
	    return { r: r * 255, g: g * 255, b: b * 255 };
	}
	
	// `rgbToHex`
	// Converts an RGB color to hex
	// Assumes r, g, and b are contained in the set [0, 255]
	// Returns a 3 or 6 character hex
	function rgbToHex(r, g, b, allow3Char) {
	
	    var hex = [
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16))
	    ];
	
	    // Return a 3 character hex if possible
	    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
	        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	    }
	
	    return hex.join("");
	}
	
	// `rgbaToHex`
	// Converts an RGBA color plus alpha transparency to hex
	// Assumes r, g, b and a are contained in the set [0, 255]
	// Returns an 8 character hex
	function rgbaToHex(r, g, b, a) {
	
	    var hex = [
	        pad2(convertDecimalToHex(a)),
	        pad2(mathRound(r).toString(16)),
	        pad2(mathRound(g).toString(16)),
	        pad2(mathRound(b).toString(16))
	    ];
	
	    return hex.join("");
	}
	
	// `equals`
	// Can be called with any tinycolor input
	tinycolor.equals = function (color1, color2) {
	    if (!color1 || !color2) { return false; }
	    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
	};
	
	tinycolor.random = function() {
	    return tinycolor.fromRatio({
	        r: mathRandom(),
	        g: mathRandom(),
	        b: mathRandom()
	    });
	};
	
	
	// Modification Functions
	// ----------------------
	// Thanks to less.js for some of the basics here
	// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>
	
	function desaturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s -= amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}
	
	function saturate(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.s += amount / 100;
	    hsl.s = clamp01(hsl.s);
	    return tinycolor(hsl);
	}
	
	function greyscale(color) {
	    return tinycolor(color).desaturate(100);
	}
	
	function lighten (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l += amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}
	
	function brighten(color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var rgb = tinycolor(color).toRgb();
	    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
	    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
	    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
	    return tinycolor(rgb);
	}
	
	function darken (color, amount) {
	    amount = (amount === 0) ? 0 : (amount || 10);
	    var hsl = tinycolor(color).toHsl();
	    hsl.l -= amount / 100;
	    hsl.l = clamp01(hsl.l);
	    return tinycolor(hsl);
	}
	
	// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
	// Values outside of this range will be wrapped into this range.
	function spin(color, amount) {
	    var hsl = tinycolor(color).toHsl();
	    var hue = (mathRound(hsl.h) + amount) % 360;
	    hsl.h = hue < 0 ? 360 + hue : hue;
	    return tinycolor(hsl);
	}
	
	// Combination Functions
	// ---------------------
	// Thanks to jQuery xColor for some of the ideas behind these
	// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>
	
	function complement(color) {
	    var hsl = tinycolor(color).toHsl();
	    hsl.h = (hsl.h + 180) % 360;
	    return tinycolor(hsl);
	}
	
	function triad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
	    ];
	}
	
	function tetrad(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
	        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
	    ];
	}
	
	function splitcomplement(color) {
	    var hsl = tinycolor(color).toHsl();
	    var h = hsl.h;
	    return [
	        tinycolor(color),
	        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
	        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
	    ];
	}
	
	function analogous(color, results, slices) {
	    results = results || 6;
	    slices = slices || 30;
	
	    var hsl = tinycolor(color).toHsl();
	    var part = 360 / slices;
	    var ret = [tinycolor(color)];
	
	    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
	        hsl.h = (hsl.h + part) % 360;
	        ret.push(tinycolor(hsl));
	    }
	    return ret;
	}
	
	function monochromatic(color, results) {
	    results = results || 6;
	    var hsv = tinycolor(color).toHsv();
	    var h = hsv.h, s = hsv.s, v = hsv.v;
	    var ret = [];
	    var modification = 1 / results;
	
	    while (results--) {
	        ret.push(tinycolor({ h: h, s: s, v: v}));
	        v = (v + modification) % 1;
	    }
	
	    return ret;
	}
	
	// Utility Functions
	// ---------------------
	
	tinycolor.mix = function(color1, color2, amount) {
	    amount = (amount === 0) ? 0 : (amount || 50);
	
	    var rgb1 = tinycolor(color1).toRgb();
	    var rgb2 = tinycolor(color2).toRgb();
	
	    var p = amount / 100;
	    var w = p * 2 - 1;
	    var a = rgb2.a - rgb1.a;
	
	    var w1;
	
	    if (w * a == -1) {
	        w1 = w;
	    } else {
	        w1 = (w + a) / (1 + w * a);
	    }
	
	    w1 = (w1 + 1) / 2;
	
	    var w2 = 1 - w1;
	
	    var rgba = {
	        r: rgb2.r * w1 + rgb1.r * w2,
	        g: rgb2.g * w1 + rgb1.g * w2,
	        b: rgb2.b * w1 + rgb1.b * w2,
	        a: rgb2.a * p  + rgb1.a * (1 - p)
	    };
	
	    return tinycolor(rgba);
	};
	
	
	// Readability Functions
	// ---------------------
	// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
	
	// `contrast`
	// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
	tinycolor.readability = function(color1, color2) {
	    var c1 = tinycolor(color1);
	    var c2 = tinycolor(color2);
	    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
	};
	
	// `isReadable`
	// Ensure that foreground and background color combinations meet WCAG2 guidelines.
	// The third argument is an optional Object.
	//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
	//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
	// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
	
	// *Example*
	//    tinycolor.isReadable("#000", "#111") => false
	//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
	tinycolor.isReadable = function(color1, color2, wcag2) {
	    var readability = tinycolor.readability(color1, color2);
	    var wcag2Parms, out;
	
	    out = false;
	
	    wcag2Parms = validateWCAG2Parms(wcag2);
	    switch (wcag2Parms.level + wcag2Parms.size) {
	        case "AAsmall":
	        case "AAAlarge":
	            out = readability >= 4.5;
	            break;
	        case "AAlarge":
	            out = readability >= 3;
	            break;
	        case "AAAsmall":
	            out = readability >= 7;
	            break;
	    }
	    return out;
	
	};
	
	// `mostReadable`
	// Given a base color and a list of possible foreground or background
	// colors for that base, returns the most readable color.
	// Optionally returns Black or White if the most readable color is unreadable.
	// *Example*
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
	//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
	//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
	tinycolor.mostReadable = function(baseColor, colorList, args) {
	    var bestColor = null;
	    var bestScore = 0;
	    var readability;
	    var includeFallbackColors, level, size ;
	    args = args || {};
	    includeFallbackColors = args.includeFallbackColors ;
	    level = args.level;
	    size = args.size;
	
	    for (var i= 0; i < colorList.length ; i++) {
	        readability = tinycolor.readability(baseColor, colorList[i]);
	        if (readability > bestScore) {
	            bestScore = readability;
	            bestColor = tinycolor(colorList[i]);
	        }
	    }
	
	    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
	        return bestColor;
	    }
	    else {
	        args.includeFallbackColors=false;
	        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
	    }
	};
	
	
	// Big List of Colors
	// ------------------
	// <http://www.w3.org/TR/css3-color/#svg-color>
	var names = tinycolor.names = {
	    aliceblue: "f0f8ff",
	    antiquewhite: "faebd7",
	    aqua: "0ff",
	    aquamarine: "7fffd4",
	    azure: "f0ffff",
	    beige: "f5f5dc",
	    bisque: "ffe4c4",
	    black: "000",
	    blanchedalmond: "ffebcd",
	    blue: "00f",
	    blueviolet: "8a2be2",
	    brown: "a52a2a",
	    burlywood: "deb887",
	    burntsienna: "ea7e5d",
	    cadetblue: "5f9ea0",
	    chartreuse: "7fff00",
	    chocolate: "d2691e",
	    coral: "ff7f50",
	    cornflowerblue: "6495ed",
	    cornsilk: "fff8dc",
	    crimson: "dc143c",
	    cyan: "0ff",
	    darkblue: "00008b",
	    darkcyan: "008b8b",
	    darkgoldenrod: "b8860b",
	    darkgray: "a9a9a9",
	    darkgreen: "006400",
	    darkgrey: "a9a9a9",
	    darkkhaki: "bdb76b",
	    darkmagenta: "8b008b",
	    darkolivegreen: "556b2f",
	    darkorange: "ff8c00",
	    darkorchid: "9932cc",
	    darkred: "8b0000",
	    darksalmon: "e9967a",
	    darkseagreen: "8fbc8f",
	    darkslateblue: "483d8b",
	    darkslategray: "2f4f4f",
	    darkslategrey: "2f4f4f",
	    darkturquoise: "00ced1",
	    darkviolet: "9400d3",
	    deeppink: "ff1493",
	    deepskyblue: "00bfff",
	    dimgray: "696969",
	    dimgrey: "696969",
	    dodgerblue: "1e90ff",
	    firebrick: "b22222",
	    floralwhite: "fffaf0",
	    forestgreen: "228b22",
	    fuchsia: "f0f",
	    gainsboro: "dcdcdc",
	    ghostwhite: "f8f8ff",
	    gold: "ffd700",
	    goldenrod: "daa520",
	    gray: "808080",
	    green: "008000",
	    greenyellow: "adff2f",
	    grey: "808080",
	    honeydew: "f0fff0",
	    hotpink: "ff69b4",
	    indianred: "cd5c5c",
	    indigo: "4b0082",
	    ivory: "fffff0",
	    khaki: "f0e68c",
	    lavender: "e6e6fa",
	    lavenderblush: "fff0f5",
	    lawngreen: "7cfc00",
	    lemonchiffon: "fffacd",
	    lightblue: "add8e6",
	    lightcoral: "f08080",
	    lightcyan: "e0ffff",
	    lightgoldenrodyellow: "fafad2",
	    lightgray: "d3d3d3",
	    lightgreen: "90ee90",
	    lightgrey: "d3d3d3",
	    lightpink: "ffb6c1",
	    lightsalmon: "ffa07a",
	    lightseagreen: "20b2aa",
	    lightskyblue: "87cefa",
	    lightslategray: "789",
	    lightslategrey: "789",
	    lightsteelblue: "b0c4de",
	    lightyellow: "ffffe0",
	    lime: "0f0",
	    limegreen: "32cd32",
	    linen: "faf0e6",
	    magenta: "f0f",
	    maroon: "800000",
	    mediumaquamarine: "66cdaa",
	    mediumblue: "0000cd",
	    mediumorchid: "ba55d3",
	    mediumpurple: "9370db",
	    mediumseagreen: "3cb371",
	    mediumslateblue: "7b68ee",
	    mediumspringgreen: "00fa9a",
	    mediumturquoise: "48d1cc",
	    mediumvioletred: "c71585",
	    midnightblue: "191970",
	    mintcream: "f5fffa",
	    mistyrose: "ffe4e1",
	    moccasin: "ffe4b5",
	    navajowhite: "ffdead",
	    navy: "000080",
	    oldlace: "fdf5e6",
	    olive: "808000",
	    olivedrab: "6b8e23",
	    orange: "ffa500",
	    orangered: "ff4500",
	    orchid: "da70d6",
	    palegoldenrod: "eee8aa",
	    palegreen: "98fb98",
	    paleturquoise: "afeeee",
	    palevioletred: "db7093",
	    papayawhip: "ffefd5",
	    peachpuff: "ffdab9",
	    peru: "cd853f",
	    pink: "ffc0cb",
	    plum: "dda0dd",
	    powderblue: "b0e0e6",
	    purple: "800080",
	    rebeccapurple: "663399",
	    red: "f00",
	    rosybrown: "bc8f8f",
	    royalblue: "4169e1",
	    saddlebrown: "8b4513",
	    salmon: "fa8072",
	    sandybrown: "f4a460",
	    seagreen: "2e8b57",
	    seashell: "fff5ee",
	    sienna: "a0522d",
	    silver: "c0c0c0",
	    skyblue: "87ceeb",
	    slateblue: "6a5acd",
	    slategray: "708090",
	    slategrey: "708090",
	    snow: "fffafa",
	    springgreen: "00ff7f",
	    steelblue: "4682b4",
	    tan: "d2b48c",
	    teal: "008080",
	    thistle: "d8bfd8",
	    tomato: "ff6347",
	    turquoise: "40e0d0",
	    violet: "ee82ee",
	    wheat: "f5deb3",
	    white: "fff",
	    whitesmoke: "f5f5f5",
	    yellow: "ff0",
	    yellowgreen: "9acd32"
	};
	
	// Make it easy to access colors via `hexNames[hex]`
	var hexNames = tinycolor.hexNames = flip(names);
	
	
	// Utilities
	// ---------
	
	// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
	function flip(o) {
	    var flipped = { };
	    for (var i in o) {
	        if (o.hasOwnProperty(i)) {
	            flipped[o[i]] = i;
	        }
	    }
	    return flipped;
	}
	
	// Return a valid alpha value [0,1] with all invalid values being set to 1
	function boundAlpha(a) {
	    a = parseFloat(a);
	
	    if (isNaN(a) || a < 0 || a > 1) {
	        a = 1;
	    }
	
	    return a;
	}
	
	// Take input from [0, n] and return it as [0, 1]
	function bound01(n, max) {
	    if (isOnePointZero(n)) { n = "100%"; }
	
	    var processPercent = isPercentage(n);
	    n = mathMin(max, mathMax(0, parseFloat(n)));
	
	    // Automatically convert percentage into number
	    if (processPercent) {
	        n = parseInt(n * max, 10) / 100;
	    }
	
	    // Handle floating point rounding errors
	    if ((math.abs(n - max) < 0.000001)) {
	        return 1;
	    }
	
	    // Convert into [0, 1] range if it isn't already
	    return (n % max) / parseFloat(max);
	}
	
	// Force a number between 0 and 1
	function clamp01(val) {
	    return mathMin(1, mathMax(0, val));
	}
	
	// Parse a base-16 hex value into a base-10 integer
	function parseIntFromHex(val) {
	    return parseInt(val, 16);
	}
	
	// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
	function isOnePointZero(n) {
	    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
	}
	
	// Check to see if string passed in is a percentage
	function isPercentage(n) {
	    return typeof n === "string" && n.indexOf('%') != -1;
	}
	
	// Force a hex value to have 2 characters
	function pad2(c) {
	    return c.length == 1 ? '0' + c : '' + c;
	}
	
	// Replace a decimal with it's percentage value
	function convertToPercentage(n) {
	    if (n <= 1) {
	        n = (n * 100) + "%";
	    }
	
	    return n;
	}
	
	// Converts a decimal to a hex value
	function convertDecimalToHex(d) {
	    return Math.round(parseFloat(d) * 255).toString(16);
	}
	// Converts a hex value to a decimal
	function convertHexToDecimal(h) {
	    return (parseIntFromHex(h) / 255);
	}
	
	var matchers = (function() {
	
	    // <http://www.w3.org/TR/css3-values/#integers>
	    var CSS_INTEGER = "[-\\+]?\\d+%?";
	
	    // <http://www.w3.org/TR/css3-values/#number-value>
	    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
	
	    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
	    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
	
	    // Actual matching.
	    // Parentheses and commas are optional, but not required.
	    // Whitespace can take the place of commas or opening paren
	    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	
	    return {
	        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
	        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
	        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
	        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
	        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
	        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
	        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
	        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	    };
	})();
	
	// `stringInputToObject`
	// Permissive string parsing.  Take in a number of formats, and output an object
	// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
	function stringInputToObject(color) {
	
	    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
	    var named = false;
	    if (names[color]) {
	        color = names[color];
	        named = true;
	    }
	    else if (color == 'transparent') {
	        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
	    }
	
	    // Try to match string input using regular expressions.
	    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
	    // Just return an object and let the conversion functions handle that.
	    // This way the result will be the same whether the tinycolor is initialized with string or object.
	    var match;
	    if ((match = matchers.rgb.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3] };
	    }
	    if ((match = matchers.rgba.exec(color))) {
	        return { r: match[1], g: match[2], b: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsl.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3] };
	    }
	    if ((match = matchers.hsla.exec(color))) {
	        return { h: match[1], s: match[2], l: match[3], a: match[4] };
	    }
	    if ((match = matchers.hsv.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3] };
	    }
	    if ((match = matchers.hsva.exec(color))) {
	        return { h: match[1], s: match[2], v: match[3], a: match[4] };
	    }
	    if ((match = matchers.hex8.exec(color))) {
	        return {
	            a: convertHexToDecimal(match[1]),
	            r: parseIntFromHex(match[2]),
	            g: parseIntFromHex(match[3]),
	            b: parseIntFromHex(match[4]),
	            format: named ? "name" : "hex8"
	        };
	    }
	    if ((match = matchers.hex6.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1]),
	            g: parseIntFromHex(match[2]),
	            b: parseIntFromHex(match[3]),
	            format: named ? "name" : "hex"
	        };
	    }
	    if ((match = matchers.hex3.exec(color))) {
	        return {
	            r: parseIntFromHex(match[1] + '' + match[1]),
	            g: parseIntFromHex(match[2] + '' + match[2]),
	            b: parseIntFromHex(match[3] + '' + match[3]),
	            format: named ? "name" : "hex"
	        };
	    }
	
	    return false;
	}
	
	function validateWCAG2Parms(parms) {
	    // return valid WCAG2 parms for isReadable.
	    // If input parms are invalid, return {"level":"AA", "size":"small"}
	    var level, size;
	    parms = parms || {"level":"AA", "size":"small"};
	    level = (parms.level || "AA").toUpperCase();
	    size = (parms.size || "small").toLowerCase();
	    if (level !== "AA" && level !== "AAA") {
	        level = "AA";
	    }
	    if (size !== "small" && size !== "large") {
	        size = "small";
	    }
	    return {"level":level, "size":size};
	}
	
	// Node: Export function
	if (typeof module !== "undefined" && module.exports) {
	    module.exports = tinycolor;
	}
	// AMD/requirejs: Define the module
	else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {return tinycolor;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	// Browser: Expose to window
	else {
	    window.tinycolor = tinycolor;
	}
	
	})();


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var scales = __webpack_require__(317);
	var defaultScale = __webpack_require__(318);
	var isValidScaleArray = __webpack_require__(319);
	
	
	module.exports = function getScale(scl, dflt) {
	    if(!dflt) dflt = defaultScale;
	    if(!scl) return dflt;
	
	    function parseScale() {
	        try {
	            scl = scales[scl] || JSON.parse(scl);
	        }
	        catch(e) {
	            scl = dflt;
	        }
	    }
	
	    if(typeof scl === 'string') {
	        parseScale();
	        // occasionally scl is double-JSON encoded...
	        if(typeof scl === 'string') parseScale();
	    }
	
	    if(!isValidScaleArray(scl)) return dflt;
	    return scl;
	};


/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    'Greys': [
	        [0, 'rgb(0,0,0)'], [1, 'rgb(255,255,255)']
	    ],
	
	    'YlGnBu': [
	        [0, 'rgb(8,29,88)'], [0.125, 'rgb(37,52,148)'],
	        [0.25, 'rgb(34,94,168)'], [0.375, 'rgb(29,145,192)'],
	        [0.5, 'rgb(65,182,196)'], [0.625, 'rgb(127,205,187)'],
	        [0.75, 'rgb(199,233,180)'], [0.875, 'rgb(237,248,217)'],
	        [1, 'rgb(255,255,217)']
	    ],
	
	    'Greens': [
	        [0, 'rgb(0,68,27)'], [0.125, 'rgb(0,109,44)'],
	        [0.25, 'rgb(35,139,69)'], [0.375, 'rgb(65,171,93)'],
	        [0.5, 'rgb(116,196,118)'], [0.625, 'rgb(161,217,155)'],
	        [0.75, 'rgb(199,233,192)'], [0.875, 'rgb(229,245,224)'],
	        [1, 'rgb(247,252,245)']
	    ],
	
	    'YlOrRd': [
	        [0, 'rgb(128,0,38)'], [0.125, 'rgb(189,0,38)'],
	        [0.25, 'rgb(227,26,28)'], [0.375, 'rgb(252,78,42)'],
	        [0.5, 'rgb(253,141,60)'], [0.625, 'rgb(254,178,76)'],
	        [0.75, 'rgb(254,217,118)'], [0.875, 'rgb(255,237,160)'],
	        [1, 'rgb(255,255,204)']
	    ],
	
	    'Bluered': [
	        [0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']
	    ],
	
	    // modified RdBu based on
	    // www.sandia.gov/~kmorel/documents/ColorMaps/ColorMapsExpanded.pdf
	    'RdBu': [
	        [0, 'rgb(5,10,172)'], [0.35, 'rgb(106,137,247)'],
	        [0.5, 'rgb(190,190,190)'], [0.6, 'rgb(220,170,132)'],
	        [0.7, 'rgb(230,145,90)'], [1, 'rgb(178,10,28)']
	    ],
	
	    // Scale for non-negative numeric values
	    'Reds': [
	        [0, 'rgb(220,220,220)'], [0.2, 'rgb(245,195,157)'],
	        [0.4, 'rgb(245,160,105)'], [1, 'rgb(178,10,28)']
	    ],
	
	    // Scale for non-positive numeric values
	    'Blues': [
	        [0, 'rgb(5,10,172)'], [0.35, 'rgb(40,60,190)'],
	        [0.5, 'rgb(70,100,245)'], [0.6, 'rgb(90,120,245)'],
	        [0.7, 'rgb(106,137,247)'], [1, 'rgb(220,220,220)']
	    ],
	
	    'Picnic': [
	        [0, 'rgb(0,0,255)'], [0.1, 'rgb(51,153,255)'],
	        [0.2, 'rgb(102,204,255)'], [0.3, 'rgb(153,204,255)'],
	        [0.4, 'rgb(204,204,255)'], [0.5, 'rgb(255,255,255)'],
	        [0.6, 'rgb(255,204,255)'], [0.7, 'rgb(255,153,255)'],
	        [0.8, 'rgb(255,102,204)'], [0.9, 'rgb(255,102,102)'],
	        [1, 'rgb(255,0,0)']
	    ],
	
	    'Rainbow': [
	        [0, 'rgb(150,0,90)'], [0.125, 'rgb(0,0,200)'],
	        [0.25, 'rgb(0,25,255)'], [0.375, 'rgb(0,152,255)'],
	        [0.5, 'rgb(44,255,150)'], [0.625, 'rgb(151,255,0)'],
	        [0.75, 'rgb(255,234,0)'], [0.875, 'rgb(255,111,0)'],
	        [1, 'rgb(255,0,0)']
	    ],
	
	    'Portland': [
	        [0, 'rgb(12,51,131)'], [0.25, 'rgb(10,136,186)'],
	        [0.5, 'rgb(242,211,56)'], [0.75, 'rgb(242,143,56)'],
	        [1, 'rgb(217,30,30)']
	    ],
	
	    'Jet': [
	        [0, 'rgb(0,0,131)'], [0.125, 'rgb(0,60,170)'],
	        [0.375, 'rgb(5,255,255)'], [0.625, 'rgb(255,255,0)'],
	        [0.875, 'rgb(250,0,0)'], [1, 'rgb(128,0,0)']
	    ],
	
	    'Hot': [
	        [0, 'rgb(0,0,0)'], [0.3, 'rgb(230,0,0)'],
	        [0.6, 'rgb(255,210,0)'], [1, 'rgb(255,255,255)']
	    ],
	
	    'Blackbody': [
	        [0, 'rgb(0,0,0)'], [0.2, 'rgb(230,0,0)'],
	        [0.4, 'rgb(230,210,0)'], [0.7, 'rgb(255,255,255)'],
	        [1, 'rgb(160,200,255)']
	    ],
	
	    'Earth': [
	        [0, 'rgb(0,0,130)'], [0.1, 'rgb(0,180,180)'],
	        [0.2, 'rgb(40,210,40)'], [0.4, 'rgb(230,230,50)'],
	        [0.6, 'rgb(120,70,20)'], [1, 'rgb(255,255,255)']
	    ],
	
	    'Electric': [
	        [0, 'rgb(0,0,0)'], [0.15, 'rgb(30,0,100)'],
	        [0.4, 'rgb(120,0,100)'], [0.6, 'rgb(160,90,0)'],
	        [0.8, 'rgb(230,200,0)'], [1, 'rgb(255,250,220)']
	    ],
	
	    'Viridis': [
	        [0, '#440154'], [0.06274509803921569, '#48186a'],
	        [0.12549019607843137, '#472d7b'], [0.18823529411764706, '#424086'],
	        [0.25098039215686274, '#3b528b'], [0.3137254901960784, '#33638d'],
	        [0.3764705882352941, '#2c728e'], [0.4392156862745098, '#26828e'],
	        [0.5019607843137255, '#21918c'], [0.5647058823529412, '#1fa088'],
	        [0.6274509803921569, '#28ae80'], [0.6901960784313725, '#3fbc73'],
	        [0.7529411764705882, '#5ec962'], [0.8156862745098039, '#84d44b'],
	        [0.8784313725490196, '#addc30'], [0.9411764705882353, '#d8e219'],
	        [1, '#fde725']
	    ]
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var scales = __webpack_require__(317);
	
	
	module.exports = scales.RdBu;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var tinycolor = __webpack_require__(315);
	
	
	module.exports = function isValidScaleArray(scl) {
	    var isValid = true,
	        highestVal = 0,
	        si;
	
	    if(!Array.isArray(scl)) return false;
	    else {
	        if(+scl[0][0]!==0 || +scl[scl.length-1][0]!==1) return false;
	        for(var i = 0; i < scl.length; i++) {
	            si = scl[i];
	            if(si.length!==2 || +si[0]<highestVal || !tinycolor(si[1]).isValid()) {
	                isValid = false;
	                break;
	            }
	            highestVal = +si[0];
	        }
	        return isValid;
	    }
	};


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	
	/**
	 * dateTime2ms - turn a date object or string s of the form
	 * YYYY-mm-dd HH:MM:SS.sss into milliseconds (relative to 1970-01-01,
	 * per javascript standard)
	 * may truncate after any full field, and sss can be any length
	 * even >3 digits, though javascript dates truncate to milliseconds
	 * returns false if it doesn't find a date
	 *
	 * 2-digit to 4-digit year conversion, where to cut off?
	 * from http://support.microsoft.com/kb/244664:
	 *   1930-2029 (the most retro of all...)
	 * but in my mac chrome from eg. d=new Date(Date.parse('8/19/50')):
	 *   1950-2049
	 * by Java, from http://stackoverflow.com/questions/2024273/:
	 *   now-80 - now+20
	 * or FileMaker Pro, from
	 *      http://www.filemaker.com/12help/html/add_view_data.4.21.html:
	 *   now-70 - now+30
	 * but python strptime etc, via
	 *      http://docs.python.org/py3k/library/time.html:
	 *   1969-2068 (super forward-looking, but static, not sliding!)
	 *
	 * lets go with now-70 to now+30, and if anyone runs into this problem
	 * they can learn the hard way not to use 2-digit years, as no choice we
	 * make now will cover all possibilities. mostly this will all be taken
	 * care of in initial parsing, should only be an issue for hand-entered data
	 * currently (2012) this range is:
	 *   1942-2041
	 */
	
	exports.dateTime2ms = function(s) {
	    // first check if s is a date object
	    try {
	        if(s.getTime) return +s;
	    }
	    catch(e) {
	        return false;
	    }
	
	    var y, m, d, h;
	    // split date and time parts
	    var datetime = String(s).split(' ');
	    if(datetime.length > 2) return false;
	
	    var p = datetime[0].split('-'); // date part
	    if(p.length > 3 || (p.length !== 3 && datetime[1])) return false;
	
	    // year
	    if(p[0].length === 4) y = Number(p[0]);
	    else if(p[0].length === 2) {
	        var yNow = new Date().getFullYear();
	        y = ((Number(p[0]) - yNow + 70)%100 + 200)%100 + yNow - 70;
	    }
	    else return false;
	    if(!isNumeric(y)) return false;
	    if(p.length === 1) return new Date(y,0,1).getTime(); // year only
	
	    // month
	    m = Number(p[1]) - 1; // new Date() uses zero-based months
	    if(p[1].length > 2 || !(m >= 0 && m <= 11)) return false;
	    if(p.length === 2) return new Date(y, m, 1).getTime(); // year-month
	
	    // day
	    d = Number(p[2]);
	    if(p[2].length > 2 || !(d >= 1 && d <= 31)) return false;
	
	    // now save the date part
	    d = new Date(y, m, d).getTime();
	    if(!datetime[1]) return d; // year-month-day
	    p = datetime[1].split(':');
	    if(p.length > 3) return false;
	
	    // hour
	    h = Number(p[0]);
	    if(p[0].length > 2 || !(h >= 0 && h <= 23)) return false;
	    d += 3600000*h;
	    if(p.length === 1) return d;
	
	    // minute
	    m = Number(p[1]);
	    if(p[1].length > 2 || !(m >= 0 && m <= 59)) return false;
	    d += 60000*m;
	    if(p.length === 2) return d;
	
	    // second
	    s = Number(p[2]);
	    if(!(s >= 0 && s < 60)) return false;
	    return d+s*1000;
	};
	
	// is string s a date? (see above)
	exports.isDateTime = function(s) {
	    return (exports.dateTime2ms(s) !== false);
	};
	
	// pad a number with zeroes, to given # of digits before the decimal point
	function lpad(val, digits) {
	    return String(val + Math.pow(10, digits)).substr(1);
	}
	
	/**
	 * Turn ms into string of the form YYYY-mm-dd HH:MM:SS.sss
	 * Crop any trailing zeros in time, but always leave full date
	 * (we could choose to crop '-01' from date too)...
	 * Optional range r is the data range that applies, also in ms.
	 * If rng is big, the later parts of time will be omitted
	 */
	exports.ms2DateTime = function(ms, r) {
	    if(typeof(d3)==='undefined') {
	        console.log('d3 is not defined');
	        return;
	    }
	
	    if(!r) r=0;
	    var d = new Date(ms),
	        s = d3.time.format('%Y-%m-%d')(d);
	    if(r<7776000000) {
	        // <90 days: add hours
	        s+=' '+lpad(d.getHours(),2);
	        if(r<432000000) {
	            // <5 days: add minutes
	            s+=':'+lpad(d.getMinutes(),2);
	            if(r<10800000) {
	                // <3 hours: add seconds
	                s+=':'+lpad(d.getSeconds(),2);
	                if(r<300000) {
	                    // <5 minutes: add ms
	                    s+='.'+lpad(d.getMilliseconds(),3);
	                }
	            }
	        }
	        // strip trailing zeros
	        return s.replace(/([:\s]00)*\.?[0]*$/,'');
	    }
	    return s;
	};
	
	/**
	 * parseDate: forgiving attempt to turn any date string
	 * into a javascript date object
	 *
	 * first collate all the date formats we want to support, precompiled
	 * to d3 format objects see below for the string cleaning that happens
	 * before this separate out 2-digit (y) and 4-digit-year (Y) formats,
	 * formats with month names (b), and formats with am/pm (I) or no time (D)
	 * (also includes hour only, as the test is really for a colon) so we can
	 * cut down the number of tests we need to run for any given string
	 * (right now all are between 15 and 32 tests)
	 */
	
	// TODO: this is way out of date vs. the server-side version
	var timeFormats = {
	    // 24 hour
	    H: ['%H:%M:%S~%L', '%H:%M:%S', '%H:%M'],
	    // with am/pm
	    I: ['%I:%M:%S~%L%p', '%I:%M:%S%p', '%I:%M%p'],
	    // no colon, ie only date or date with hour (could also support eg 12h34m?)
	    D: ['%H', '%I%p', '%Hh']
	};
	
	var dateFormats = {
	    Y: [
	        '%Y~%m~%d',
	        '%Y%m%d',
	        '%y%m%d', // YYMMDD, has 6 digits together so will match Y, not y
	        '%m~%d~%Y', // MM/DD/YYYY has first precedence
	        '%d~%m~%Y' // then DD/MM/YYYY
	    ],
	    Yb: [
	        '%b~%d~%Y', // eg nov 21 2013
	        '%d~%b~%Y', // eg 21 nov 2013
	        '%Y~%d~%b', // eg 2013 21 nov (or 2013 q3, after replacement)
	        '%Y~%b~%d' // eg 2013 nov 21
	    ],
	    /**
	     * the two-digit year cases have so many potential ambiguities
	     * it's not even funny, but we'll try them anyway.
	     */
	    y: [
	        '%m~%d~%y',
	        '%d~%m~%y',
	        '%y~%m~%d'
	    ],
	    yb: [
	        '%b~%d~%y',
	        '%d~%b~%y',
	        '%y~%d~%b',
	        '%y~%b~%d'
	    ]
	};
	
	// use utc formatter since we're ignoring timezone info
	var formatter = d3.time.format.utc;
	
	/**
	 * ISO8601 and YYYYMMDDHHMMSS are the only ones where date and time
	 * are not separated by a space, so they get inserted specially here.
	 * Also a couple formats with no day (so time makes no sense)
	 */
	var dateTimeFormats = {
	    Y: {
	        H: ['%Y~%m~%dT%H:%M:%S', '%Y~%m~%dT%H:%M:%S~%L'].map(formatter),
	        I: [],
	        D: ['%Y%m%d%H%M%S', '%Y~%m', '%m~%Y'].map(formatter)
	    },
	    Yb: {H: [], I: [], D: ['%Y~%b', '%b~%Y'].map(formatter)},
	    y: {H: [], I: [], D: []},
	    yb: {H: [], I: [], D: []}
	};
	// all others get inserted in all possible combinations from dateFormats and timeFormats
	['Y', 'Yb', 'y', 'yb'].forEach(function(dateType) {
	    dateFormats[dateType].forEach(function(dateFormat) {
	        // just a date (don't do just a time)
	        dateTimeFormats[dateType].D.push(formatter(dateFormat));
	        ['H', 'I', 'D'].forEach(function(timeType) {
	            timeFormats[timeType].forEach(function(timeFormat) {
	                var a = dateTimeFormats[dateType][timeType];
	
	                // 'date time', then 'time date'
	                a.push(formatter(dateFormat+'~'+timeFormat));
	                a.push(formatter(timeFormat+'~'+dateFormat));
	            });
	        });
	    });
	});
	
	// precompiled regexps for performance
	var matchword = /[a-z]*/g,
	    shortenword = function(m) { return m.substr(0,3); },
	    weekdaymatch = /(mon|tue|wed|thu|fri|sat|sun|the|of|st|nd|rd|th)/g,
	    separatormatch = /[\s,\/\-\.\(\)]+/g,
	    ampmmatch = /~?([ap])~?m(~|$)/,
	    replaceampm = function(m,ap) { return ap+'m '; },
	    match4Y = /\d\d\d\d/,
	    matchMonthName = /(^|~)[a-z]{3}/,
	    matchAMPM = /[ap]m/,
	    matchcolon = /:/,
	    matchquarter = /q([1-4])/,
	    quarters = ['31~mar','30~jun','30~sep','31~dec'],
	    replacequarter = function(m,n) { return quarters[n-1]; },
	    matchTZ = / ?([+\-]\d\d:?\d\d|Z)$/;
	
	function getDateType(v) {
	    var dateType;
	    dateType = (match4Y.test(v) ? 'Y' : 'y');
	    dateType = dateType + (matchMonthName.test(v) ? 'b' : '');
	    return dateType;
	}
	
	function getTimeType(v) {
	    var timeType;
	    timeType = matchcolon.test(v) ? (matchAMPM.test(v) ? 'I' : 'H') : 'D';
	    return timeType;
	}
	
	exports.parseDate = function(v) {
	    // is it already a date? just return it
	    if(v.getTime) return v;
	    /**
	     * otherwise, if it's not a string, return nothing
	     * the case of numbers that just have years will get
	     * dealt with elsewhere.
	     */
	    if(typeof v !== 'string') return false;
	
	    // first clean up the string a bit to reduce the number of formats we have to test
	    v = v.toLowerCase()
	        /**
	         * cut all words down to 3 characters - this will result in
	         * some spurious matches, ie whenever the first three characters
	         * of a word match a month or weekday but that seems more likely
	         * to fix typos than to make dates where they shouldn't be...
	         * and then we can omit the long form of months from our testing
	         */
	        .replace(matchword, shortenword)
	        /**
	         * remove weekday names, as they get overridden anyway if they're
	         * inconsistent also removes a few more words
	         * (ie "tuesday the 26th of november")
	         * TODO: language support?
	         * for months too, but these seem to be built into d3
	         */
	        .replace(weekdaymatch, '')
	        /**
	         * collapse all separators one ~ at a time, except : which seems
	         * pretty consistent for the time part use ~ instead of space or
	         * something since d3 can eat a space as padding on 1-digit numbers
	         */
	        .replace(separatormatch, '~')
	        // in case of a.m. or p.m. (also take off any space before am/pm)
	        .replace(ampmmatch, replaceampm)
	        // turn quarters Q1-4 into dates (quarter ends)
	        .replace(matchquarter, replacequarter)
	        .trim()
	        // also try to ignore timezone info, at least for now
	        .replace(matchTZ, '');
	
	    // now test against the various formats that might match
	    var out = null,
	        dateType = getDateType(v),
	        timeType = getTimeType(v),
	        formatList,
	        len;
	
	    formatList = dateTimeFormats[dateType][timeType];
	    len = formatList.length;
	
	    for(var i = 0; i < len; i++) {
	        out = formatList[i].parse(v);
	        if(out) break;
	    }
	
	    // If not an instance of Date at this point, just return it.
	    if(!(out instanceof Date)) return false;
	    // parse() method interprets arguments with local time zone.
	    var tzoff = out.getTimezoneOffset();
	    // In general (default) this is not what we want, so force into UTC:
	    out.setTime(out.getTime() + tzoff * 60 * 1000);
	    return out;
	};


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	
	/**
	 * findBin - find the bin for val - note that it can return outside the
	 * bin range any pos. or neg. integer for linear bins, or -1 or
	 * bins.length-1 for explicit.
	 * bins is either an object {start,size,end} or an array length #bins+1
	 * bins can be either increasing or decreasing but must be monotonic
	 * for linear bins, we can just calculate. For listed bins, run a binary
	 * search linelow (truthy) says the bin boundary should be attributed to
	 * the lower bin rather than the default upper bin
	 */
	exports.findBin = function(val, bins, linelow) {
	    if(isNumeric(bins.start)) {
	        return linelow ?
	            Math.ceil((val - bins.start) / bins.size) - 1 :
	            Math.floor((val - bins.start) / bins.size);
	    }
	    else {
	        var n1 = 0,
	            n2 = bins.length,
	            c = 0,
	            n,
	            test;
	        if(bins[bins.length - 1] >= bins[0]) {
	            test = linelow ? lessThan : lessOrEqual;
	        } else {
	            test = linelow ? greaterOrEqual : greaterThan;
	        }
	        // c is just to avoid infinite loops if there's an error
	        while(n1 < n2 && c++ < 100) {
	            n = Math.floor((n1 + n2) / 2);
	            if(test(bins[n], val)) n1 = n + 1;
	            else n2 = n;
	        }
	        if(c > 90) console.log('Long binary search...');
	        return n1 - 1;
	    }
	};
	
	function lessThan(a, b) { return a < b; }
	function lessOrEqual(a, b) { return a <= b; }
	function greaterThan(a, b) { return a > b; }
	function greaterOrEqual(a, b) { return a >= b; }
	
	exports.sorterAsc = function(a, b) { return a - b; };
	exports.sorterDes = function(a, b) { return b - a; };
	
	/**
	 * find distinct values in an array, lumping together ones that appear to
	 * just be off by a rounding error
	 * return the distinct values and the minimum difference between any two
	 */
	exports.distinctVals = function(valsIn) {
	    var vals = valsIn.slice();  // otherwise we sort the original array...
	    vals.sort(exports.sorterAsc);
	
	    var l = vals.length - 1,
	        minDiff = (vals[l] - vals[0]) || 1,
	        errDiff = minDiff / (l || 1) / 10000,
	        v2 = [vals[0]];
	
	    for(var i = 0; i < l; i++) {
	        // make sure values aren't just off by a rounding error
	        if(vals[i + 1] > vals[i] + errDiff) {
	            minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);
	            v2.push(vals[i + 1]);
	        }
	    }
	
	    return {vals: v2, minDiff: minDiff};
	};
	
	/**
	 * return the smallest element from (sorted) array arrayIn that's bigger than val,
	 * or (reverse) the largest element smaller than val
	 * used to find the best tick given the minimum (non-rounded) tick
	 * particularly useful for date/time where things are not powers of 10
	 * binary search is probably overkill here...
	 */
	exports.roundUp = function(val, arrayIn, reverse) {
	    var low = 0,
	        high = arrayIn.length - 1,
	        mid,
	        c = 0,
	        dlow = reverse ? 0 : 1,
	        dhigh = reverse ? 1 : 0,
	        rounded = reverse ? Math.ceil : Math.floor;
	    // c is just to avoid infinite loops if there's an error
	    while(low < high && c++ < 100) {
	        mid = rounded((low + high) / 2);
	        if(arrayIn[mid] <= val) low = mid + dlow;
	        else high = mid - dhigh;
	    }
	    return arrayIn[low];
	};


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	
	/**
	 * aggNums() returns the result of an aggregate function applied to an array of
	 * values, where non-numerical values have been tossed out.
	 *
	 * @param {function} f - aggregation function (e.g., Math.min)
	 * @param {Number} v - initial value (continuing from previous calls)
	 *      if there's no continuing value, use null for selector-type
	 *      functions (max,min), or 0 for summations
	 * @param {Array} a - array to aggregate (may be nested, we will recurse,
	 *                    but all elements must have the same dimension)
	 * @param {Number} len - maximum length of a to aggregate
	 * @return {Number} - result of f applied to a starting from v
	 */
	exports.aggNums = function(f, v, a, len) {
	    var i,
	        b;
	    if(!len) len = a.length;
	    if(!isNumeric(v)) v = false;
	    if(Array.isArray(a[0])) {
	        b = new Array(len);
	        for(i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);
	        a = b;
	    }
	
	    for(i = 0; i < len; i++) {
	        if(!isNumeric(v)) v = a[i];
	        else if(isNumeric(a[i])) v = f(+v, +a[i]);
	    }
	    return v;
	};
	
	/**
	 * mean & std dev functions using aggNums, so it handles non-numerics nicely
	 * even need to use aggNums instead of .length, to toss out non-numerics
	 */
	exports.len = function(data) {
	    return exports.aggNums(function(a) { return a + 1; }, 0, data);
	};
	
	exports.mean = function(data, len) {
	    if(!len) len = exports.len(data);
	    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
	};
	
	exports.variance = function(data, len, mean) {
	    if(!len) len = exports.len(data);
	    if(!isNumeric(mean)) mean = exports.mean(data, len);
	
	    return exports.aggNums(function(a, b) {
	        return a + Math.pow(b - mean, 2);
	    }, 0, data)/len;
	};
	
	exports.stdev = function(data, len, mean) {
	    return Math.sqrt(exports.variance(data, len, mean));
	};
	
	/**
	 * interp() computes a percentile (quantile) for a given distribution.
	 * We interpolate the distribution (to compute quantiles, we follow method #10 here:
	 * http://www.amstat.org/publications/jse/v14n3/langford.html).
	 * Typically the index or rank (n * arr.length) may be non-integer.
	 * For reference: ends are clipped to the extreme values in the array;
	 * For box plots: index you get is half a point too high (see
	 * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition
	 * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).
	 *
	 * @param {Array} arr - This array contains the values that make up the distribution.
	 * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.
	 * For example, the 50th percentile (or median) corresponds to n = 0.5
	 * @return {Number} - percentile
	 */
	exports.interp = function(arr, n) {
	    if(!isNumeric(n)) throw 'n should be a finite number';
	    n = n * arr.length - 0.5;
	    if(n < 0) return arr[0];
	    if(n > arr.length - 1) return arr[arr.length - 1];
	    var frac = n % 1;
	    return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
	};


/***/ },
/* 323 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	exports.init2dArray = function(rowLength, colLength) {
	    var array = new Array(rowLength);
	    for(var i = 0; i < rowLength; i++) array[i] = new Array(colLength);
	    return array;
	};
	
	/**
	 * transpose a (possibly ragged) 2d array z. inspired by
	 * http://stackoverflow.com/questions/17428587/
	 * transposing-a-2d-array-in-javascript
	 */
	exports.transposeRagged = function(z) {
	    var maxlen = 0,
	        zlen = z.length,
	        i,
	        j;
	    // Maximum row length:
	    for(i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);
	
	    var t = new Array(maxlen);
	    for(i = 0; i < maxlen; i++) {
	        t[i] = new Array(zlen);
	        for(j = 0; j < zlen; j++) t[i][j] = z[j][i];
	    }
	
	    return t;
	};
	
	// our own dot function so that we don't need to include numeric
	exports.dot = function(x, y) {
	    if(!(x.length && y.length) || x.length !== y.length) return null;
	
	    var len = x.length,
	        out,
	        i;
	
	    if(x[0].length) {
	        // mat-vec or mat-mat
	        out = new Array(len);
	        for(i = 0; i < len; i++) out[i] = exports.dot(x[i], y);
	    }
	    else if(y[0].length) {
	        // vec-mat
	        var yTranspose = exports.transposeRagged(y);
	        out = new Array(yTranspose.length);
	        for(i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
	    }
	    else {
	        // vec-vec
	        out = 0;
	        for(i = 0; i < len; i++) out += x[i] * y[i];
	    }
	
	    return out;
	};
	
	// translate by (x,y)
	exports.translationMatrix = function(x, y) {
	    return [[1, 0, x], [0, 1, y], [0, 0, 1]];
	};
	
	// rotate by alpha around (0,0)
	exports.rotationMatrix = function(alpha) {
	    var a = alpha*Math.PI/180;
	    return [[Math.cos(a), -Math.sin(a), 0],
	            [Math.sin(a), Math.cos(a), 0],
	            [0, 0, 1]];
	};
	
	// rotate by alpha around (x,y)
	exports.rotationXYMatrix = function(a, x, y) {
	    return exports.dot(
	        exports.dot(exports.translationMatrix(x, y),
	                    exports.rotationMatrix(a)),
	        exports.translationMatrix(-x, -y));
	};
	
	// applies a 2D transformation matrix to either x and y params or an [x,y] array
	exports.apply2DTransform = function(transform) {
	    return function() {
	        var args = arguments;
	        if(args.length === 3) {
	            args = args[0];
	        }//from map
	        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
	        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
	    };
	};
	
	// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)
	exports.apply2DTransform2 = function(transform) {
	    var at = exports.apply2DTransform(transform);
	    return function(xys) {
	        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
	    };
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isPlainObject = __webpack_require__(313);
	var isArray = Array.isArray;
	
	exports.extendFlat = function() {
	    return _extend(arguments, false, false);
	};
	
	exports.extendDeep = function() {
	    return _extend(arguments, true, false);
	};
	
	exports.extendDeepAll = function() {
	    return _extend(arguments, true, true);
	};
	
	/*
	 * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js
	 * All credit to the jQuery authors for perfecting this amazing utility.
	 *
	 * API difference with jQuery version:
	 * - No optional boolean (true -> deep extend) first argument,
	 *   use `extendFlat` for first-level only extend and
	 *   use `extendDeep` for a deep extend.
	 *
	 * Other differences with jQuery version:
	 * - Uses a modern (and faster) isPlainObject routine.
	 * - Expected to work with object {} and array [] arguments only.
	 * - Does not check for circular structure.
	 *   FYI: jQuery only does a check across one level.
	 *   Warning: this might result in infinite loops.
	 *
	 */
	function _extend(inputs, isDeep, keepAllKeys) {
	    var target = inputs[0],
	        length = inputs.length;
	
	    var input, key, src, copy, copyIsArray, clone;
	
	    for(var i = 1; i < length; i++) {
	        input = inputs[i];
	
	        for(key in input) {
	            src = target[key];
	            copy = input[key];
	
	            // recurse if we're merging plain objects or arrays
	            if(isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
	                if(copyIsArray) {
	                    copyIsArray = false;
	                    clone = src && isArray(src) ? src : [];
	                } else {
	                    clone = src && isPlainObject(src) ? src : {};
	                }
	
	                // never move original objects, clone them
	                target[key] = _extend([clone, copy], isDeep, keepAllKeys);
	            }
	
	            // don't bring in undefined values, except for extendDeepAll
	            else if(typeof copy !== 'undefined' || keepAllKeys) {
	                target[key] = copy;
	            }
	        }
	    }
	
	    return target;
	}


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var NOTEDATA = [];
	
	/**
	 * notifier
	 * @param {String} text The person's user name
	 * @param {Number} [delay=1000] The delay time in milliseconds
	 *          or 'long' which provides 2000 ms delay time.
	 * @return {undefined} this function does not return a value
	 */
	module.exports = function(text, displayLength) {
	    if(NOTEDATA.indexOf(text) !== -1) return;
	
	    NOTEDATA.push(text);
	
	    var ts = 1000;
	    if(isNumeric(displayLength)) ts = displayLength;
	    else if(displayLength === 'long') ts = 3000;
	
	    var notifierContainer = d3.select('body')
	        .selectAll('.plotly-notifier')
	        .data([0]);
	    notifierContainer.enter()
	        .append('div')
	        .classed('plotly-notifier', true);
	
	    var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);
	
	    function killNote(transition) {
	        transition
	            .duration(700)
	            .style('opacity', 0)
	            .each('end', function(thisText) {
	                var thisIndex = NOTEDATA.indexOf(thisText);
	                if(thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
	                d3.select(this).remove();
	            });
	    }
	
	    notes.enter().append('div')
	        .classed('notifier-note', true)
	        .style('opacity', 0)
	        .each(function(thisText) {
	            var note = d3.select(this);
	
	            note.append('button')
	                .classed('notifier-close', true)
	                .html('&times;')
	                .on('click', function() {
	                    note.transition().call(killNote);
	                });
	
	            note.append('p').html(thisText);
	
	            note.transition()
	                    .duration(700)
	                    .style('opacity', 1)
	                .transition()
	                    .delay(ts)
	                    .call(killNote);
	        });
	};


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	/* global MathJax:false */
	
	var Plotly = __webpack_require__(304);
	var d3 = __webpack_require__(310);
	
	var xmlnsNamespaces = __webpack_require__(327);
	
	var util = module.exports = {};
	
	// Append SVG
	
	d3.selection.prototype.appendSVG = function(_svgString) {
	    var skeleton = [
	        '<svg xmlns="', xmlnsNamespaces.svg, '" ',
	        'xmlns:xlink="', xmlnsNamespaces.xlink, '">',
	        _svgString,
	        '</svg>'
	    ].join('');
	
	    var dom = new DOMParser().parseFromString(skeleton, 'application/xml'),
	        childNode = dom.documentElement.firstChild;
	
	    while(childNode) {
	        this.node().appendChild(this.node().ownerDocument.importNode(childNode, true));
	        childNode = childNode.nextSibling;
	    }
	    if(dom.querySelector('parsererror')) {
	        console.log(dom.querySelector('parsererror div').textContent);
	        return null;
	    }
	    return d3.select(this.node().lastChild);
	};
	
	// Text utilities
	
	util.html_entity_decode = function(s) {
	    var hiddenDiv = d3.select('body').append('div').style({display: 'none'}).html('');
	    var replaced = s.replace(/(&[^;]*;)/gi, function(d) {
	        if(d==='&lt;') { return '&#60;'; } // special handling for brackets
	        if(d==='&rt;') { return '&#62;'; }
	        return hiddenDiv.html(d).text(); // everything else, let the browser decode it to unicode
	    });
	    hiddenDiv.remove();
	    return replaced;
	};
	
	util.xml_entity_encode = function(str) {
	    return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g,'&amp;');
	};
	
	// text converter
	
	function getSize(_selection, _dimension) {
	    return _selection.node().getBoundingClientRect()[_dimension];
	}
	
	util.convertToTspans = function(_context, _callback) {
	    var str = _context.text();
	    var converted = convertToSVG(str);
	    var that = _context;
	    // Until we get tex integrated more fully (so it can be used along with non-tex)
	    // allow some elements to prohibit it by attaching 'data-notex' to the original
	    var tex = (!that.attr('data-notex')) && converted.match(/([^$]*)([$]+[^$]*[$]+)([^$]*)/);
	    var result = str;
	    var parent = d3.select(that.node().parentNode);
	    if(parent.empty()) return;
	    var svgClass = (that.attr('class')) ? that.attr('class').split(' ')[0] : 'text';
	    svgClass += '-math';
	    parent.selectAll('svg.' + svgClass).remove();
	    parent.selectAll('g.' + svgClass + '-group').remove();
	    _context.style({visibility: null});
	    for(var up = _context.node(); up && up.removeAttribute; up = up.parentNode) {
	        up.removeAttribute('data-bb');
	    }
	
	    function showText() {
	        if(!parent.empty()) {
	            svgClass = that.attr('class') + '-math';
	            parent.select('svg.' + svgClass).remove();
	        }
	        _context.text('')
	            .style({
	                visibility: 'visible',
	                'white-space': 'pre'
	            });
	        result = _context.appendSVG(converted);
	        if(!result) _context.text(str);
	        if(_context.select('a').size()) {
	            // at least in Chrome, pointer-events does not seem
	            // to be honored in children of <text> elements
	            // so if we have an anchor, we have to make the
	            // whole element respond
	            _context.style('pointer-events', 'all');
	        }
	
	        if(_callback) _callback.call(that);
	    }
	
	    if(tex) {
	        var td = Plotly.Lib.getPlotDiv(that.node());
	        ((td && td._promises)||[]).push(new Promise(function(resolve) {
	            that.style({visibility: 'hidden'});
	            var config = {fontSize: parseInt(that.style('font-size'), 10)};
	
	            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
	                parent.selectAll('svg.' + svgClass).remove();
	                parent.selectAll('g.' + svgClass + '-group').remove();
	
	                var newSvg = _svgEl && _svgEl.select('svg');
	                if(!newSvg || !newSvg.node()) {
	                    showText();
	                    resolve();
	                    return;
	                }
	
	                var mathjaxGroup = parent.append('g')
	                    .classed(svgClass + '-group', true)
	                    .attr({'pointer-events': 'none'});
	
	                mathjaxGroup.node().appendChild(newSvg.node());
	
	                // stitch the glyph defs
	                if(_glyphDefs && _glyphDefs.node()) {
	                    newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true),
	                                               newSvg.node().firstChild);
	                }
	
	                newSvg.attr({
	                    'class': svgClass,
	                    height: _svgBBox.height,
	                    preserveAspectRatio: 'xMinYMin meet'
	                })
	                .style({overflow: 'visible', 'pointer-events': 'none'});
	
	                var fill = that.style('fill') || 'black';
	                newSvg.select('g').attr({fill: fill, stroke: fill});
	
	                var newSvgW = getSize(newSvg, 'width'),
	                    newSvgH = getSize(newSvg, 'height'),
	                    newX = +that.attr('x') - newSvgW *
	                        {start: 0, middle: 0.5, end: 1}[that.attr('text-anchor') || 'start'],
	                    // font baseline is about 1/4 fontSize below centerline
	                    textHeight = parseInt(that.style('font-size'), 10) ||
	                        getSize(that, 'height'),
	                    dy = -textHeight/4;
	
	                if(svgClass[0] === 'y') {
	                    mathjaxGroup.attr({
	                        transform: 'rotate(' + [-90, +that.attr('x'), +that.attr('y')] +
	                        ') translate(' + [-newSvgW / 2, dy - newSvgH / 2] + ')'
	                    });
	                    newSvg.attr({x: +that.attr('x'), y: +that.attr('y')});
	                }
	                else if(svgClass[0] === 'l') {
	                    newSvg.attr({x: that.attr('x'), y: dy - (newSvgH / 2)});
	                }
	                else if(svgClass[0] === 'a') {
	                    newSvg.attr({x: 0, y: dy});
	                }
	                else {
	                    newSvg.attr({x: newX, y: (+that.attr('y') + dy - newSvgH / 2)});
	                }
	
	                if(_callback) _callback.call(that, mathjaxGroup);
	                resolve(mathjaxGroup);
	            });
	        }));
	    }
	    else showText();
	
	    return _context;
	};
	
	
	// MathJax
	
	function cleanEscapesForTex(s) {
	    return s.replace(/(<|&lt;|&#60;)/g, '\\lt ')
	        .replace(/(>|&gt;|&#62;)/g, '\\gt ');
	}
	
	function texToSVG(_texString, _config, _callback) {
	    var randomID = 'math-output-' + Plotly.Lib.randstr([],64);
	    var tmpDiv = d3.select('body').append('div')
	        .attr({id: randomID})
	        .style({visibility: 'hidden', position: 'absolute'})
	        .style({'font-size': _config.fontSize + 'px'})
	        .text(cleanEscapesForTex(_texString));
	
	    MathJax.Hub.Queue(['Typeset', MathJax.Hub, tmpDiv.node()], function() {
	        var glyphDefs = d3.select('body').select('#MathJax_SVG_glyphs');
	
	        if(tmpDiv.select('.MathJax_SVG').empty() || !tmpDiv.select('svg').node()) {
	            console.log('There was an error in the tex syntax.', _texString);
	            _callback();
	        }
	        else {
	            var svgBBox = tmpDiv.select('svg').node().getBoundingClientRect();
	            _callback(tmpDiv.select('.MathJax_SVG'), glyphDefs, svgBBox);
	        }
	
	        tmpDiv.remove();
	    });
	}
	
	var TAG_STYLES = {
	    // would like to use baseline-shift but FF doesn't support it yet
	    // so we need to use dy along with the uber hacky shift-back-to
	    // baseline below
	    sup: 'font-size:70%" dy="-0.6em',
	    sub: 'font-size:70%" dy="0.3em',
	    b: 'font-weight:bold',
	    i: 'font-style:italic',
	    a: '',
	    span: '',
	    br: '',
	    em: 'font-style:italic;font-weight:bold'
	};
	
	var PROTOCOLS = ['http:', 'https:', 'mailto:'];
	
	var STRIP_TAGS = new RegExp('</?(' + Object.keys(TAG_STYLES).join('|') + ')( [^>]*)?/?>', 'g');
	
	util.plainText = function(_str) {
	    // strip out our pseudo-html so we have a readable
	    // version to put into text fields
	    return (_str||'').replace(STRIP_TAGS, ' ');
	};
	
	function convertToSVG(_str) {
	    var htmlEntitiesDecoded = Plotly.util.html_entity_decode(_str);
	    var result = htmlEntitiesDecoded
	        .split(/(<[^<>]*>)/).map(function(d) {
	            var match = d.match(/<(\/?)([^ >]*)\s*(.*)>/i),
	                tag = match && match[2].toLowerCase(),
	                style = TAG_STYLES[tag];
	            if(style !== undefined) {
	                var close = match[1],
	                    extra = match[3],
	                    /**
	                     * extraStyle: any random extra css (that's supported by svg)
	                     * use this like <span style="font-family:Arial"> to change font in the middle
	                     *
	                     * at one point we supported <font family="..." size="..."> but as this isn't even
	                     * valid HTML anymore and we dropped it accidentally for many months, we will not
	                     * resurrect it.
	                     */
	                    extraStyle = extra.match(/^style\s*=\s*"([^"]+)"\s*/i);
	                // anchor and br are the only ones that don't turn into a tspan
	                if(tag === 'a') {
	                    if(close) return '</a>';
	                    else if(extra.substr(0,4).toLowerCase() !== 'href') return '<a>';
	                    else {
	                        var dummyAnchor = document.createElement('a');
	                        dummyAnchor.href = extra.substr(4).replace(/["'=]/g, '');
	
	                        if(PROTOCOLS.indexOf(dummyAnchor.protocol) === -1) return '<a>';
	
	                        return '<a xlink:show="new" xlink:href' + extra.substr(4) + '>';
	                    }
	                }
	                else if(tag === 'br') return '<br>';
	                else if(close) {
	                    // closing tag
	
	                    // sub/sup: extra tspan with zero-width space to get back to the right baseline
	                    if(tag === 'sup') return '</tspan><tspan dy="0.42em">&#x200b;</tspan>';
	                    if(tag === 'sub') return '</tspan><tspan dy="-0.21em">&#x200b;</tspan>';
	                    else return '</tspan>';
	                }
	                else {
	                    var tspanStart = '<tspan';
	
	                    if(tag === 'sup' || tag === 'sub') {
	                        // sub/sup: extra zero-width space, fixes problem if new line starts with sub/sup
	                        tspanStart = '&#x200b;' + tspanStart;
	                    }
	
	                    if(extraStyle) {
	                        // most of the svg css users will care about is just like html,
	                        // but font color is different. Let our users ignore this.
	                        extraStyle = extraStyle[1].replace(/(^|;)\s*color:/, '$1 fill:');
	                        style = (style ? style + ';' : '') + extraStyle;
	                    }
	
	                    return tspanStart + (style ? ' style="' + style + '"' : '') + '>';
	                }
	            }
	            else {
	                return Plotly.util.xml_entity_encode(d).replace(/</g, '&lt;');
	            }
	        });
	
	    var indices = [];
	    for(var index = result.indexOf('<br>'); index > 0; index = result.indexOf('<br>', index+1)) {
	        indices.push(index);
	    }
	    var count = 0;
	    indices.forEach(function(d) {
	        var brIndex = d + count;
	        var search = result.slice(0, brIndex);
	        var previousOpenTag = '';
	        for(var i2=search.length-1; i2>=0; i2--) {
	            var isTag = search[i2].match(/<(\/?).*>/i);
	            if(isTag && search[i2] !== '<br>') {
	                if(!isTag[1]) previousOpenTag = search[i2];
	                break;
	            }
	        }
	        if(previousOpenTag) {
	            result.splice(brIndex+1, 0, previousOpenTag);
	            result.splice(brIndex, 0, '</tspan>');
	            count += 2;
	        }
	    });
	
	    var joined = result.join('');
	    var splitted = joined.split(/<br>/gi);
	    if(splitted.length > 1) {
	        result = splitted.map(function(d, i) {
	            // TODO: figure out max font size of this line and alter dy
	            // this requires either:
	            // 1) bringing the base font size into convertToTspans, or
	            // 2) only allowing relative percentage font sizes.
	            // I think #2 is the way to go
	            return '<tspan class="line" dy="' + (i*1.3) + 'em">'+ d +'</tspan>';
	        });
	    }
	
	    return result.join('');
	}
	
	function alignHTMLWith(_base, container, options) {
	    var alignH = options.horizontalAlign,
	        alignV = options.verticalAlign || 'top',
	        bRect = _base.node().getBoundingClientRect(),
	        cRect = container.node().getBoundingClientRect(),
	        thisRect,
	        getTop,
	        getLeft;
	
	    if(alignV === 'bottom') {
	        getTop = function() { return bRect.bottom - thisRect.height; };
	    } else if(alignV === 'middle') {
	        getTop = function() { return bRect.top + (bRect.height - thisRect.height) / 2; };
	    } else { // default: top
	        getTop = function() { return bRect.top; };
	    }
	
	    if(alignH === 'right') {
	        getLeft = function() { return bRect.right - thisRect.width; };
	    } else if(alignH === 'center') {
	        getLeft = function() { return bRect.left + (bRect.width - thisRect.width) / 2; };
	    } else { // default: left
	        getLeft = function() { return bRect.left; };
	    }
	
	    return function() {
	        thisRect = this.node().getBoundingClientRect();
	        this.style({
	            top: (getTop() - cRect.top) + 'px',
	            left: (getLeft() - cRect.left) + 'px',
	            'z-index': 1000
	        });
	        return this;
	    };
	}
	
	// Editable title
	
	util.makeEditable = function(context, _delegate, options) {
	    if(!options) options = {};
	    var that = this;
	    var dispatch = d3.dispatch('edit', 'input', 'cancel');
	    var textSelection = d3.select(this.node())
	        .style({'pointer-events': 'all'});
	
	    var handlerElement = _delegate || textSelection;
	    if(_delegate) textSelection.style({'pointer-events': 'none'});
	
	    function handleClick() {
	        appendEditable();
	        that.style({opacity: 0});
	        // also hide any mathjax svg
	        var svgClass = handlerElement.attr('class'),
	            mathjaxClass;
	        if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';
	        else mathjaxClass = '[class*=-math-group]';
	        if(mathjaxClass) {
	            d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});
	        }
	    }
	
	    function selectElementContents(_el) {
	        var el = _el.node();
	        var range = document.createRange();
	        range.selectNodeContents(el);
	        var sel = window.getSelection();
	        sel.removeAllRanges();
	        sel.addRange(range);
	        el.focus();
	    }
	
	    function appendEditable() {
	        var plotDiv = d3.select(Plotly.Lib.getPlotDiv(that.node())),
	            container = plotDiv.select('.svg-container'),
	            div = container.append('div');
	        div.classed('plugin-editable editable', true)
	            .style({
	                position: 'absolute',
	                'font-family': that.style('font-family') || 'Arial',
	                'font-size': that.style('font-size') || 12,
	                color: options.fill || that.style('fill') || 'black',
	                opacity: 1,
	                'background-color': options.background || 'transparent',
	                outline: '#ffffff33 1px solid',
	                margin: [-parseFloat(that.style('font-size'))/8+1, 0, 0, -1].join('px ') + 'px',
	                padding: '0',
	                'box-sizing': 'border-box'
	            })
	            .attr({contenteditable: true})
	            .text(options.text || that.attr('data-unformatted'))
	            .call(alignHTMLWith(that, container, options))
	            .on('blur', function() {
	                that.text(this.textContent)
	                    .style({opacity: 1});
	                var svgClass = d3.select(this).attr('class'),
	                    mathjaxClass;
	                if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';
	                else mathjaxClass = '[class*=-math-group]';
	                if(mathjaxClass) {
	                    d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});
	                }
	                var text = this.textContent;
	                d3.select(this).transition().duration(0).remove();
	                d3.select(document).on('mouseup', null);
	                dispatch.edit.call(that, text);
	            })
	            .on('focus', function() {
	                var context = this;
	                d3.select(document).on('mouseup', function() {
	                    if(d3.event.target === context) return false;
	                    if(document.activeElement === div.node()) div.node().blur();
	                });
	            })
	            .on('keyup', function() {
	                if(d3.event.which === 27) {
	                    that.style({opacity: 1});
	                    d3.select(this)
	                        .style({opacity: 0})
	                        .on('blur', function() { return false; })
	                        .transition().remove();
	                    dispatch.cancel.call(that, this.textContent);
	                }
	                else {
	                    dispatch.input.call(that, this.textContent);
	                    d3.select(this).call(alignHTMLWith(that, container, options));
	                }
	            })
	            .on('keydown', function() {
	                if(d3.event.which === 13) this.blur();
	            })
	            .call(selectElementContents);
	    }
	
	    if(options.immediate) handleClick();
	    else handlerElement.on('click', handleClick);
	
	    return d3.rebind(this, dispatch, 'on');
	};


/***/ },
/* 327 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	exports.xmlns = 'http://www.w3.org/2000/xmlns/';
	exports.svg = 'http://www.w3.org/2000/svg';
	exports.xlink = 'http://www.w3.org/1999/xlink';
	
	// the 'old' d3 quirk got fix in v3.5.7
	// https://github.com/mbostock/d3/commit/a6f66e9dd37f764403fc7c1f26be09ab4af24fed
	exports.svgAttrs = {
	    xmlns: exports.svg,
	    'xmlns:xlink': exports.xlink
	};


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	
	/**
	 * Copy arg array *without* removing `undefined` values from objects.
	 *
	 * @param gd
	 * @param args
	 * @returns {Array}
	 */
	function copyArgArray(gd, args) {
	    var copy = [];
	    var arg;
	
	    for(var i = 0; i < args.length; i++) {
	        arg = args[i];
	
	        if(arg === gd) copy[i] = arg;
	        else if(typeof arg === 'object') {
	            copy[i] = Array.isArray(arg) ?
	                Plotly.Lib.extendDeep([], arg) :
	                Plotly.Lib.extendDeepAll({}, arg);
	        }
	        else copy[i] = arg;
	    }
	
	    return copy;
	}
	
	
	// -----------------------------------------------------
	// Undo/Redo queue for plots
	// -----------------------------------------------------
	
	
	var queue = {};
	
	// TODO: disable/enable undo and redo buttons appropriately
	
	/**
	 * Add an item to the undoQueue for a graphDiv
	 *
	 * @param gd
	 * @param undoFunc Function undo this operation
	 * @param undoArgs Args to supply undoFunc with
	 * @param redoFunc Function to redo this operation
	 * @param redoArgs Args to supply redoFunc with
	 */
	queue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {
	    var queueObj,
	        queueIndex;
	
	    // make sure we have the queue and our position in it
	    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
	    queueIndex = gd.undoQueue.index;
	
	    // if we're already playing an undo or redo, or if this is an auto operation
	    // (like pane resize... any others?) then we don't save this to the undo queue
	    if(gd.autoplay) {
	        if(!gd.undoQueue.inSequence) gd.autoplay = false;
	        return;
	    }
	
	    // if we're not in a sequence or are just starting, we need a new queue item
	    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
	        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};
	        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
	        gd.undoQueue.index += 1;
	    } else {
	        queueObj = gd.undoQueue.queue[queueIndex - 1];
	    }
	    gd.undoQueue.beginSequence = false;
	
	    // we unshift to handle calls for undo in a forward for loop later
	    queueObj.undo.calls.unshift(undoFunc);
	    queueObj.undo.args.unshift(undoArgs);
	    queueObj.redo.calls.push(redoFunc);
	    queueObj.redo.args.push(redoArgs);
	
	};
	
	/**
	 * Begin a sequence of undoQueue changes
	 *
	 * @param gd
	 */
	queue.startSequence = function(gd) {
	    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
	    gd.undoQueue.sequence = true;
	    gd.undoQueue.beginSequence = true;
	};
	
	/**
	 * Stop a sequence of undoQueue changes
	 *
	 * Call this *after* you're sure your undo chain has ended
	 *
	 * @param gd
	 */
	queue.stopSequence = function(gd) {
	    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
	    gd.undoQueue.sequence = false;
	    gd.undoQueue.beginSequence = false;
	};
	
	/**
	 * Move one step back in the undo queue, and undo the object there.
	 *
	 * @param gd
	 */
	queue.undo = function undo(gd) {
	    var queueObj, i;
	
	    if(gd.framework && gd.framework.isPolar) {
	        gd.framework.undo();
	        return;
	    }
	    if(gd.undoQueue === undefined ||
	            isNaN(gd.undoQueue.index) ||
	            gd.undoQueue.index <= 0) {
	        return;
	    }
	
	    // index is pointing to next *forward* queueObj, point to the one we're undoing
	    gd.undoQueue.index--;
	
	    // get the queueObj for instructions on how to undo
	    queueObj = gd.undoQueue.queue[gd.undoQueue.index];
	
	    // this sequence keeps things from adding to the queue during undo/redo
	    gd.undoQueue.inSequence = true;
	    for(i = 0; i < queueObj.undo.calls.length; i++) {
	        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
	    }
	    gd.undoQueue.inSequence = false;
	    gd.autoplay = false;
	};
	
	/**
	 * Redo the current object in the undo, then move forward in the queue.
	 *
	 * @param gd
	 */
	queue.redo = function redo(gd) {
	    var queueObj, i;
	
	    if(gd.framework && gd.framework.isPolar) {
	        gd.framework.redo();
	        return;
	    }
	    if(gd.undoQueue === undefined ||
	            isNaN(gd.undoQueue.index) ||
	            gd.undoQueue.index >= gd.undoQueue.queue.length) {
	        return;
	    }
	
	    // get the queueObj for instructions on how to undo
	    queueObj = gd.undoQueue.queue[gd.undoQueue.index];
	
	    // this sequence keeps things from adding to the queue during undo/redo
	    gd.undoQueue.inSequence = true;
	    for(i = 0; i < queueObj.redo.calls.length; i++) {
	        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
	    }
	    gd.undoQueue.inSequence = false;
	    gd.autoplay = false;
	
	    // index is pointing to the thing we just redid, move it
	    gd.undoQueue.index++;
	};
	
	/**
	 * Called by undo/redo to make the actual changes.
	 *
	 * Not meant to be called publically, but included for mocking out in tests.
	 *
	 * @param gd
	 * @param func
	 * @param args
	 */
	queue.plotDo = function(gd, func, args) {
	    gd.autoplay = true;
	
	    // this *won't* copy gd and it preserves `undefined` properties!
	    args = copyArgArray(gd, args);
	
	    // call the supplied function
	    func.apply(null, args);
	};
	
	module.exports = queue;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Plotly = __webpack_require__(304);
	var rules = {
	    "X,X div": "font-family:'Open Sans', verdana, arial, sans-serif;margin:0;padding:0;",
	    "X input,X button": "font-family:'Open Sans', verdana, arial, sans-serif;",
	    "X input:focus,X button:focus": "outline:none;",
	    "X a": "text-decoration:none;",
	    "X a:hover": "text-decoration:none;",
	    "X .crisp": "shape-rendering:crispEdges;",
	    "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
	    "X svg": "overflow:hidden;",
	    "X svg a": "fill:#447adb;",
	    "X svg a:hover": "fill:#3c6dc5;",
	    "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
	    "X .main-svg .draglayer": "pointer-events:all;",
	    "X .cursor-pointer": "cursor:pointer;",
	    "X .cursor-crosshair": "cursor:crosshair;",
	    "X .cursor-move": "cursor:move;",
	    "X .cursor-col-resize": "cursor:col-resize;",
	    "X .cursor-row-resize": "cursor:row-resize;",
	    "X .cursor-ns-resize": "cursor:ns-resize;",
	    "X .cursor-ew-resize": "cursor:ew-resize;",
	    "X .cursor-sw-resize": "cursor:sw-resize;",
	    "X .cursor-s-resize": "cursor:s-resize;",
	    "X .cursor-se-resize": "cursor:se-resize;",
	    "X .cursor-w-resize": "cursor:w-resize;",
	    "X .cursor-e-resize": "cursor:e-resize;",
	    "X .cursor-nw-resize": "cursor:nw-resize;",
	    "X .cursor-n-resize": "cursor:n-resize;",
	    "X .cursor-ne-resize": "cursor:ne-resize;",
	    "X .modebar": "position:absolute;top:2px;right:2px;z-index:1001;background:rgba(255,255,255,0.7);",
	    "X .modebar--hover": "opacity:0;-webkit-transition:opacity 0.3s ease 0s;-moz-transition:opacity 0.3s ease 0s;-ms-transition:opacity 0.3s ease 0s;-o-transition:opacity 0.3s ease 0s;transition:opacity 0.3s ease 0s;",
	    "X:hover .modebar--hover": "opacity:1;",
	    "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;margin-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
	    "X .modebar-group:first-child": "margin-left:0px;",
	    "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;cursor:pointer;line-height:normal;box-sizing:border-box;",
	    "X .modebar-btn svg": "position:relative;top:2px;",
	    "X .modebar-btn path": "fill:rgba(0,31,95,0.3);",
	    "X .modebar-btn.active path,X .modebar-btn:hover path": "fill:rgba(0,22,72,0.5);",
	    "X .modebar-btn.modebar-btn--logo": "padding:3px 1px;",
	    "X .modebar-btn.modebar-btn--logo path": "fill:#447adb !important;",
	    "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
	    "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
	    "X [data-title]:before": "content:'';position:absolute;background:transparent;border:6px solid transparent;z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;",
	    "X [data-title]:after": "content:attr(data-title);background:#69738a;color:white;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
	    "X .select-outline": "fill:none;stroke-width:1;shape-rendering:crispEdges;",
	    "X .select-outline-1": "stroke:white;",
	    "X .select-outline-2": "stroke:black;stroke-dasharray:2px 2px;",
	    Y: "font-family:'Open Sans';position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;",
	    "Y p": "margin:0;",
	    "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,0.9);color:#fff;padding:10px;",
	    "Y .notifier-close": "color:#fff;opacity:0.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
	    "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
	};
	
	for(var selector in rules) {
	    var fullSelector = selector.replace(/^,/,' ,')
	        .replace(/X/g, '.js-plotly-plot .plotly')
	        .replace(/Y/g, '.plotly-notifier');
	    Plotly.Lib.addStyleRule(fullSelector, rules[selector]);
	}


/***/ },
/* 330 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	/* global MathJax:false */
	
	/**
	 * Check and configure MathJax
	 */
	if(typeof MathJax !== 'undefined') {
	    exports.MathJax = true;
	
	    MathJax.Hub.Config({
	        messageStyle: 'none',
	        skipStartupTypeset: true,
	        displayAlign: 'left',
	        tex2jax: {
	            inlineMath: [['$','$'],['\\(','\\)']]
	        }
	    });
	
	    MathJax.Hub.Configured();
	} else {
	    exports.MathJax = false;
	}


/***/ },
/* 331 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	/**
	 * This will be transfered over to gd and overridden by
	 * config args to Plotly.plot.
	 *
	 * The defaults are the appropriate settings for plotly.js,
	 * so we get the right experience without any config argument.
	 */
	
	module.exports = {
	
	    // no interactivity, for export or image generation
	    staticPlot: false,
	
	    // we can edit titles, move annotations, etc
	    editable: false,
	
	    // plot will respect layout.autosize=true and infer its container size
	    autosizable: false,
	
	    // if we DO autosize, do we fill the container or the screen?
	    fillFrame: false,
	
	    // if we DO autosize, set the frame margins in percents of plot size
	    frameMargins: 0,
	
	    // mousewheel or two-finger scroll zooms the plot
	    scrollZoom: false,
	
	    // double click interaction (false, 'reset', 'autosize' or 'reset+autosize')
	    doubleClick: 'reset+autosize',
	
	    // new users see some hints about interactivity
	    showTips: true,
	
	    // link to open this plot in plotly
	    showLink: false,
	
	    // if we show a link, does it contain data or just link to a plotly file?
	    sendData: true,
	
	    // text appearing in the sendData link
	    linkText: 'Edit chart',
	
	    // false or function adding source(s) to linkText <text>
	    showSources: false,
	
	    // display the mode bar (true, false, or 'hover')
	    displayModeBar: 'hover',
	
	    // remove mode bar button by name
	    // (see ./components/modebar/buttons.js for the list of names)
	    modeBarButtonsToRemove: [],
	
	    // add mode bar button using config objects
	    // (see ./components/modebar/buttons.js for list of arguments)
	    modeBarButtonsToAdd: [],
	
	    // fully custom mode bar buttons as nested array,
	    // where the outer arrays represents button groups, and
	    // the inner arrays have buttons config objects or names of default buttons
	    // (see ./components/modebar/buttons.js for more info)
	    modeBarButtons: false,
	
	    // add the plotly logo on the end of the mode bar
	    displaylogo: true,
	
	    // increase the pixel ratio for Gl plot images
	    plotGlPixelRatio: 2,
	
	    // function to add the background color to a different container
	    // or 'opaque' to ensure there's white behind it
	    setBackground: defaultSetBackground,
	
	    // URL to topojson files used in geo charts
	    topojsonURL: 'https://cdn.plot.ly/'
	
	};
	
	// where and how the background gets set can be overridden by context
	// so we define the default (plotlyjs) behavior here
	function defaultSetBackground(gd, bgColor) {
	    try {
	        gd._fullLayout._paper.style('background', bgColor);
	    }
	    catch(e) { console.log(e); }
	}


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var Color = __webpack_require__(333);
	
	var plots = module.exports = {};
	
	var modules = plots.modules = {},
	    allTypes = plots.allTypes = [],
	    allCategories = plots.allCategories = {},
	    subplotsRegistry = plots.subplotsRegistry = {};
	
	plots.attributes = __webpack_require__(335);
	plots.attributes.type.values = allTypes;
	plots.fontAttrs = __webpack_require__(336);
	plots.layoutAttributes = __webpack_require__(337);
	
	// TODO make this a plot attribute?
	plots.fontWeight = 'normal';
	
	/**
	 * plots.register: register a module as the handler for a trace type
	 *
	 * @param {object} _module the module that will handle plotting this trace type
	 * @param {string} thisType
	 * @param {array of strings} categoriesIn all the categories this type is in,
	 *     tested by calls: Plotly.Plots.traceIs(trace, oneCategory)
	 * @param {object} meta meta information about the trace type
	 */
	plots.register = function(_module, thisType, categoriesIn, meta) {
	    if(modules[thisType]) {
	        console.log('type ' + thisType + ' already registered');
	        return;
	    }
	
	    var categoryObj = {};
	    for(var i = 0; i < categoriesIn.length; i++) {
	        categoryObj[categoriesIn[i]] = true;
	        allCategories[categoriesIn[i]] = true;
	    }
	
	    modules[thisType] = {
	        _module: _module,
	        categories: categoryObj
	    };
	
	    if(meta && Object.keys(meta).length) {
	        modules[thisType].meta = meta;
	    }
	
	    allTypes.push(thisType);
	};
	
	function getTraceType(traceType) {
	    if(typeof traceType === 'object') traceType = traceType.type;
	    return traceType;
	}
	
	plots.getModule = function(trace) {
	    if(trace.r !== undefined) {
	        console.log('Oops, tried to put a polar trace ' +
	            'on an incompatible graph of cartesian ' +
	            'data. Ignoring this dataset.', trace
	        );
	        return false;
	    }
	
	    var _module = modules[getTraceType(trace)];
	    if(!_module) return false;
	    return _module._module;
	};
	
	
	/**
	 * plots.traceIs: is this trace type in this category?
	 *
	 * traceType: a trace (object) or trace type (string)
	 * category: a category (string)
	 */
	plots.traceIs = function traceIs(traceType, category) {
	    traceType = getTraceType(traceType);
	
	    if(traceType === 'various') return false;  // FIXME
	
	    var _module = modules[traceType];
	
	    if(!_module) {
	        if(traceType !== undefined) {
	            console.warn('unrecognized trace type ' + traceType);
	        }
	        _module = modules[plots.attributes.type.dflt];
	    }
	
	    return !!_module.categories[category];
	};
	
	
	/**
	 * plots.registerSubplot: register a subplot type
	 *
	 * @param {object} _module subplot module:
	 *
	 *      @param {string or array of strings} attr
	 *          attribute name in traces and layout
	 *      @param {string or array of strings} idRoot
	 *          root of id (setting the possible value for attrName)
	 *      @param {object} attributes
	 *          attribute(s) for traces of this subplot type
	 *
	 * In trace objects `attr` is the object key taking a valid `id` as value
	 * (the set of all valid ids is generated below and stored in idRegex).
	 *
	 * In the layout object, a or several valid `attr` name(s) can be keys linked
	 * to a nested attribute objects
	 * (the set of all valid attr names is generated below and stored in attrRegex).
	 *
	 * TODO use these in Lib.coerce
	 */
	plots.registerSubplot = function(_module) {
	    var plotType = _module.name;
	
	    if(subplotsRegistry[plotType]) {
	        console.log('plot type ' + plotType + ' already registered');
	        return;
	    }
	
	    // not sure what's best for the 'cartesian' type at this point
	    subplotsRegistry[plotType] = _module;
	};
	
	/**
	 * Find subplot ids in data.
	 * Meant to be used in the defaults step.
	 *
	 * Use plots.getSubplotIds to grab the current
	 * subplot ids later on in Plotly.plot.
	 *
	 * @param {array} data plotly data array
	 *      (intended to be _fullData, but does not have to be).
	 * @param {string} type subplot type to look for.
	 *
	 * @return {array} list of subplot ids (strings).
	 *      N.B. these ids possibly un-ordered.
	 *
	 * TODO incorporate cartesian/gl2d axis finders in this paradigm.
	 */
	plots.findSubplotIds = function findSubplotIds(data, type) {
	    var subplotIds = [];
	
	    if(plots.subplotsRegistry[type] === undefined) return subplotIds;
	
	    var attr = plots.subplotsRegistry[type].attr;
	
	    for(var i = 0; i < data.length; i++) {
	        var trace = data[i];
	
	        if(plots.traceIs(trace, type) && subplotIds.indexOf(trace[attr]) === -1) {
	            subplotIds.push(trace[attr]);
	        }
	    }
	
	    return subplotIds;
	};
	
	/**
	 * Get the ids of the current subplots.
	 *
	 * @param {object} layout plotly full layout object.
	 * @param {string} type subplot type to look for.
	 *
	 * @return {array} list of ordered subplot ids (strings).
	 *
	 */
	plots.getSubplotIds = function getSubplotIds(layout, type) {
	    var _module = plots.subplotsRegistry[type];
	
	    if(_module === undefined) return [];
	
	    // layout must be 'fullLayout' here
	    if(type === 'cartesian' && (!layout._has || !layout._has('cartesian'))) return [];
	    if(type === 'gl2d' && (!layout._has || !layout._has('gl2d'))) return [];
	    if(type === 'cartesian' || type === 'gl2d') {
	        return Object.keys(layout._plots);
	    }
	
	    var idRegex = _module.idRegex,
	        layoutKeys = Object.keys(layout),
	        subplotIds = [];
	
	    for(var i = 0; i < layoutKeys.length; i++) {
	        var layoutKey = layoutKeys[i];
	
	        if(idRegex.test(layoutKey)) subplotIds.push(layoutKey);
	    }
	
	    // order the ids
	    var idLen = _module.idRoot.length;
	    subplotIds.sort(function(a, b) {
	        var aNum = +(a.substr(idLen) || 1),
	            bNum = +(b.substr(idLen) || 1);
	        return aNum - bNum;
	    });
	
	    return subplotIds;
	};
	
	/**
	 * Get the data trace(s) associated with a given subplot.
	 *
	 * @param {array} data  plotly full data array.
	 * @param {object} layout plotly full layout object.
	 * @param {string} subplotId subplot ids to look for.
	 *
	 * @return {array} list of trace objects.
	 *
	 */
	plots.getSubplotData = function getSubplotData(data, type, subplotId) {
	    if(plots.subplotsRegistry[type] === undefined) return [];
	
	    var attr = plots.subplotsRegistry[type].attr,
	        subplotData = [],
	        trace;
	
	    for(var i = 0; i < data.length; i++) {
	        trace = data[i];
	
	        if(type === 'gl2d' && plots.traceIs(trace, 'gl2d')) {
	            var spmatch = Plotly.Axes.subplotMatch,
	                subplotX = 'x' + subplotId.match(spmatch)[1],
	                subplotY = 'y' + subplotId.match(spmatch)[2];
	
	            if(trace[attr[0]]===subplotX && trace[attr[1]]===subplotY) {
	                subplotData.push(trace);
	            }
	        }
	        else {
	            if(trace[attr] === subplotId) subplotData.push(trace);
	        }
	    }
	
	    return subplotData;
	};
	
	// in some cases the browser doesn't seem to know how big
	// the text is at first, so it needs to draw it,
	// then wait a little, then draw it again
	plots.redrawText = function(gd) {
	
	    // do not work if polar is present
	    if((gd.data && gd.data[0] && gd.data[0].r)) return;
	
	    return new Promise(function(resolve) {
	        setTimeout(function() {
	            Plotly.Annotations.drawAll(gd);
	            Plotly.Legend.draw(gd);
	
	            (gd.calcdata || []).forEach(function(d) {
	                if(d[0] && d[0].t && d[0].t.cb) d[0].t.cb();
	            });
	
	            resolve(plots.previousPromises(gd));
	        },300);
	    });
	};
	
	// resize plot about the container size
	plots.resize = function(gd) {
	    return new Promise(function(resolve, reject) {
	
	        if(!gd || d3.select(gd).style('display') === 'none') {
	            reject(new Error('Resize must be passed a plot div element.'));
	        }
	
	        if(gd._redrawTimer) clearTimeout(gd._redrawTimer);
	
	        gd._redrawTimer = setTimeout(function() {
	            if((gd._fullLayout || {}).autosize) {
	                // autosizing doesn't count as a change that needs saving
	                var oldchanged = gd.changed;
	
	                // nor should it be included in the undo queue
	                gd.autoplay = true;
	
	                Plotly.relayout(gd, { autosize: true });
	                gd.changed = oldchanged;
	                resolve(gd);
	            }
	        }, 100);
	    });
	};
	
	
	// for use in Lib.syncOrAsync, check if there are any
	// pending promises in this plot and wait for them
	plots.previousPromises = function(gd) {
	    if((gd._promises || []).length) {
	        return Promise.all(gd._promises)
	            .then(function() { gd._promises=[]; });
	    }
	};
	
	/**
	 * Adds the 'Edit chart' link.
	 * Note that now Plotly.plot() calls this so it can regenerate whenever it replots
	 *
	 * Add source links to your graph inside the 'showSources' config argument.
	 */
	plots.addLinks = function(gd) {
	    var fullLayout = gd._fullLayout;
	
	    var linkContainer = fullLayout._paper
	        .selectAll('text.js-plot-link-container').data([0]);
	
	    linkContainer.enter().append('text')
	        .classed('js-plot-link-container', true)
	        .style({
	            'font-family': '"Open Sans", Arial, sans-serif',
	            'font-size': '12px',
	            'fill': Color.defaultLine,
	            'pointer-events': 'all'
	        })
	        .each(function() {
	            var links = d3.select(this);
	            links.append('tspan').classed('js-link-to-tool', true);
	            links.append('tspan').classed('js-link-spacer', true);
	            links.append('tspan').classed('js-sourcelinks', true);
	        });
	
	    // The text node inside svg
	    var text = linkContainer.node(),
	        attrs = {
	            y: fullLayout._paper.attr('height') - 9
	        };
	
	    // If text's width is bigger than the layout
	    // Check that text is a child node or document.body
	    // because otherwise IE/Edge might throw an exception
	    // when calling getComputedTextLength().
	    // Apparently offsetParent is null for invisibles.
	    if(document.body.contains(text) && text.getComputedTextLength() >= (fullLayout.width - 20)) {
	        // Align the text at the left
	        attrs['text-anchor'] = 'start';
	        attrs.x = 5;
	    }
	    else {
	        // Align the text at the right
	        attrs['text-anchor'] = 'end';
	        attrs.x = fullLayout._paper.attr('width') - 7;
	    }
	
	    linkContainer.attr(attrs);
	
	    var toolspan = linkContainer.select('.js-link-to-tool'),
	        spacespan = linkContainer.select('.js-link-spacer'),
	        sourcespan = linkContainer.select('.js-sourcelinks');
	
	    if(gd._context.showSources) gd._context.showSources(gd);
	
	    // 'view in plotly' link for embedded plots
	    if(gd._context.showLink) positionPlayWithData(gd, toolspan);
	
	    // separator if we have both sources and tool link
	    spacespan.text((toolspan.text() && sourcespan.text()) ? ' - ' : '');
	};
	
	// note that now this function is only adding the brand in
	// iframes and 3rd-party apps
	function positionPlayWithData(gd, container) {
	    container.text('');
	    var link = container.append('a')
	        .attr({
	            'xlink:xlink:href': '#',
	            'class': 'link--impt link--embedview',
	            'font-weight': 'bold'
	        })
	        .text(gd._context.linkText + ' ' + String.fromCharCode(187));
	
	    if(gd._context.sendData) {
	        link.on('click', function() {
	            plots.sendDataToCloud(gd);
	        });
	    }
	    else {
	        var path = window.location.pathname.split('/');
	        var query = window.location.search;
	        link.attr({
	            'xlink:xlink:show': 'new',
	            'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query
	        });
	    }
	}
	plots.sendDataToCloud = function(gd) {
	    gd.emit('plotly_beforeexport');
	
	    var baseUrl = (window.PLOTLYENV && window.PLOTLYENV.BASE_URL) || 'https://plot.ly';
	
	    var hiddenformDiv = d3.select(gd)
	        .append('div')
	        .attr('id', 'hiddenform')
	        .style('display', 'none');
	
	    var hiddenform = hiddenformDiv
	        .append('form')
	        .attr({
	            action: baseUrl + '/external',
	            method: 'post',
	            target: '_blank'
	        });
	
	    var hiddenformInput = hiddenform
	        .append('input')
	        .attr({
	            type: 'text',
	            name: 'data'
	        });
	
	    hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');
	    hiddenform.node().submit();
	    hiddenformDiv.remove();
	
	    gd.emit('plotly_afterexport');
	    return false;
	};
	
	// Fill in default values:
	//
	// gd.data, gd.layout:
	//   are precisely what the user specified,
	//   these fields shouldn't be modified nor used directly
	//   after the supply defaults step.
	//
	// gd._fullData, gd._fullLayout:
	//   are complete descriptions of how to draw the plot,
	//   use these fields in all required computations.
	//
	// gd._fullLayout._modules
	//   is a list of all the trace modules required to draw the plot.
	//
	// gd._fullLayout._basePlotModules
	//   is a list of all the plot modules required to draw the plot.
	//
	plots.supplyDefaults = function(gd) {
	    var oldFullLayout = gd._fullLayout || {},
	        newFullLayout = gd._fullLayout = {},
	        newLayout = gd.layout || {};
	
	    var oldFullData = gd._fullData || [],
	        newFullData = gd._fullData = [],
	        newData = gd.data || [];
	
	    var modules = newFullLayout._modules = [],
	        basePlotModules = newFullLayout._basePlotModules = [];
	
	    var i, _module;
	
	    // first fill in what we can of layout without looking at data
	    // because fullData needs a few things from layout
	    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout);
	
	    // keep track of how many traces are inputted
	    newFullLayout._dataLength = newData.length;
	
	    // then do the data
	    for(i = 0; i < newData.length; i++) {
	        var fullTrace = plots.supplyDataDefaults(newData[i], i, newFullLayout);
	        newFullData.push(fullTrace);
	
	        // detect polar
	        if('r' in newData[i]) continue;
	
	        _module = fullTrace._module;
	        if(!_module) continue;
	
	        // fill in module lists
	        Lib.pushUnique(modules, _module);
	        Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);
	    }
	
	    // attach helper method to check whether a plot type is present on graph
	    newFullLayout._has = plots._hasPlotType.bind(newFullLayout);
	
	    // special cases that introduce interactions between traces
	    for(i = 0; i < modules.length; i++) {
	        _module = modules[i];
	        if(_module.cleanData) _module.cleanData(newFullData);
	    }
	
	    if(oldFullData.length === newData.length) {
	        for(i = 0; i < newFullData.length; i++) {
	            relinkPrivateKeys(newFullData[i], oldFullData[i]);
	        }
	    }
	
	    // finally, fill in the pieces of layout that may need to look at data
	    plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData);
	
	    // TODO remove in v2.0.0
	    // add has-plot-type refs to fullLayout for backward compatibility
	    newFullLayout._hasCartesian = newFullLayout._has('cartesian');
	    newFullLayout._hasGeo = newFullLayout._has('geo');
	    newFullLayout._hasGL3D = newFullLayout._has('gl3d');
	    newFullLayout._hasGL2D = newFullLayout._has('gl2d');
	    newFullLayout._hasTernary = newFullLayout._has('ternary');
	    newFullLayout._hasPie = newFullLayout._has('pie');
	
	    // clean subplots and other artifacts from previous plot calls
	    plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);
	
	    // relink functions and _ attributes to promote consistency between plots
	    relinkPrivateKeys(newFullLayout, oldFullLayout);
	
	    plots.doAutoMargin(gd);
	
	    // can't quite figure out how to get rid of this... each axis needs
	    // a reference back to the DOM object for just a few purposes
	    var axList = Plotly.Axes.list(gd);
	    for(i = 0; i < axList.length; i++) {
	        var ax = axList[i];
	        ax._gd = gd;
	        ax.setScale();
	    }
	
	    // update object references in calcdata
	    if((gd.calcdata || []).length === newFullData.length) {
	        for(i = 0; i < newFullData.length; i++) {
	            var trace = newFullData[i];
	            (gd.calcdata[i][0] || {}).trace = trace;
	        }
	    }
	};
	
	// helper function to be bound to fullLayout to check
	// whether a certain plot type is present on plot
	plots._hasPlotType = function(category) {
	    var basePlotModules = this._basePlotModules || [];
	
	    for(var i = 0; i < basePlotModules.length; i++) {
	        var _module = basePlotModules[i];
	
	        if(_module.name === category) return true;
	    }
	
	    return false;
	};
	
	plots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
	    var i, j;
	
	    var basePlotModules = oldFullLayout._basePlotModules || [];
	    for(i = 0; i < basePlotModules.length; i++) {
	        var _module = basePlotModules[i];
	
	        if(_module.clean) {
	            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
	        }
	    }
	
	    var hasPaper = !!oldFullLayout._paper;
	    var hasInfoLayer = !!oldFullLayout._infolayer;
	
	    oldLoop:
	    for(i = 0; i < oldFullData.length; i++) {
	        var oldTrace = oldFullData[i],
	            oldUid = oldTrace.uid;
	
	        for(j = 0; j < newFullData.length; j++) {
	            var newTrace = newFullData[j];
	
	            if(oldUid === newTrace.uid) continue oldLoop;
	        }
	
	        // clean old heatmap and contour traces
	        if(hasPaper) {
	            oldFullLayout._paper.selectAll(
	                '.hm' + oldUid +
	                ',.contour' + oldUid +
	                ',#clip' + oldUid
	            ).remove();
	        }
	
	        // clean old colorbars
	        if(hasInfoLayer) {
	            oldFullLayout._infolayer.selectAll('.cb' + oldUid).remove();
	        }
	    }
	};
	
	/**
	 * Relink private _keys and keys with a function value from one layout
	 * (usually cached) to the new fullLayout.
	 * relink means copying if object is pass-by-value and adding a reference
	 * if object is pass-by-ref. This prevents deepCopying massive structures like
	 * a webgl context.
	 */
	function relinkPrivateKeys(toLayout, fromLayout) {
	    var keys = Object.keys(fromLayout);
	    var j;
	
	    for(var i = 0; i < keys.length; ++i) {
	        var k = keys[i];
	        if(k.charAt(0)==='_' || typeof fromLayout[k]==='function') {
	            // if it already exists at this point, it's something
	            // that we recreate each time around, so ignore it
	            if(k in toLayout) continue;
	
	            toLayout[k] = fromLayout[k];
	        }
	        else if(Array.isArray(fromLayout[k]) &&
	                 Array.isArray(toLayout[k]) &&
	                 fromLayout[k].length &&
	                 Lib.isPlainObject(fromLayout[k][0])) {
	            if(fromLayout[k].length !== toLayout[k].length) {
	                // this should be handled elsewhere, it causes
	                // ambiguity if we try to deal with it here.
	                throw new Error('relinkPrivateKeys needs equal ' +
	                                'length arrays');
	            }
	
	            for(j = 0; j < fromLayout[k].length; j++) {
	                relinkPrivateKeys(toLayout[k][j], fromLayout[k][j]);
	            }
	        }
	        else if(Lib.isPlainObject(fromLayout[k]) &&
	                 Lib.isPlainObject(toLayout[k])) {
	            // recurse into objects, but only if they still exist
	            relinkPrivateKeys(toLayout[k], fromLayout[k]);
	            if(!Object.keys(toLayout[k]).length) delete toLayout[k];
	        }
	    }
	}
	
	plots.supplyDataDefaults = function(traceIn, i, layout) {
	    var traceOut = {},
	        defaultColor = Color.defaults[i % Color.defaults.length];
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
	    }
	
	    function coerceSubplotAttr(subplotType, subplotAttr) {
	        if(!plots.traceIs(traceOut, subplotType)) return;
	        return Lib.coerce(traceIn, traceOut,
	            plots.subplotsRegistry[subplotType].attributes, subplotAttr);
	    }
	
	    // module-independent attributes
	    traceOut.index = i;
	    var visible = coerce('visible'),
	        scene,
	        _module;
	
	    coerce('type');
	    coerce('uid');
	
	    // this is necessary otherwise we lose references to scene objects when
	    // the traces of a scene are invisible. Also we handle visible/unvisible
	    // differently for 3D cases.
	    coerceSubplotAttr('gl3d', 'scene');
	    coerceSubplotAttr('geo', 'geo');
	    coerceSubplotAttr('ternary', 'subplot');
	
	    // module-specific attributes --- note: we need to send a trace into
	    // the 3D modules to have it removed from the webgl context.
	    if(visible || scene) {
	        _module = plots.getModule(traceOut);
	        traceOut._module = _module;
	    }
	
	    // gets overwritten in pie, geo and ternary modules
	    if(visible) coerce('hoverinfo', (layout._dataLength === 1) ? 'x+y+z+text' : undefined);
	
	    if(_module && visible) _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);
	
	    if(visible) {
	        coerce('name', 'trace ' + i);
	
	        if(!plots.traceIs(traceOut, 'noOpacity')) coerce('opacity');
	
	        coerceSubplotAttr('cartesian', 'xaxis');
	        coerceSubplotAttr('cartesian', 'yaxis');
	
	        coerceSubplotAttr('gl2d', 'xaxis');
	        coerceSubplotAttr('gl2d', 'yaxis');
	
	        if(plots.traceIs(traceOut, 'showLegend')) {
	            coerce('showlegend');
	            coerce('legendgroup');
	        }
	    }
	
	    // NOTE: I didn't include fit info at all... for now I think it can stay
	    // just in gd.data, as this info isn't involved in creating plots at all,
	    // only in pulling back up the fit popover
	
	    // reference back to the input object for convenience
	    traceOut._input = traceIn;
	
	    return traceOut;
	};
	
	plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut) {
	    function coerce(attr, dflt) {
	        return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
	    }
	
	    var globalFont = Lib.coerceFont(coerce, 'font');
	
	    coerce('title');
	
	    Lib.coerceFont(coerce, 'titlefont', {
	        family: globalFont.family,
	        size: Math.round(globalFont.size * 1.4),
	        color: globalFont.color
	    });
	
	    var autosize = coerce('autosize',
	        (layoutIn.width && layoutIn.height) ? false : 'initial');
	    coerce('width');
	    coerce('height');
	
	    coerce('margin.l');
	    coerce('margin.r');
	    coerce('margin.t');
	    coerce('margin.b');
	    coerce('margin.pad');
	    coerce('margin.autoexpand');
	
	    // called in plotAutoSize otherwise
	    if(autosize!=='initial') plots.sanitizeMargins(layoutOut);
	
	    coerce('paper_bgcolor');
	
	    coerce('separators');
	    coerce('hidesources');
	    coerce('smith');
	};
	
	plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData) {
	    var i, _module;
	
	    // can't be be part of basePlotModules loop
	    // in order to handle the orphan axes case
	    Plotly.Axes.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
	
	    // base plot module layout defaults
	    var basePlotModules = layoutOut._basePlotModules;
	    for(i = 0; i < basePlotModules.length; i++) {
	        _module = basePlotModules[i];
	
	        // done above already
	        if(_module.name === 'cartesian') continue;
	
	        // e.g. gl2d does not have a layout-defaults step
	        if(_module.supplyLayoutDefaults) {
	            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
	        }
	    }
	
	    // trace module layout defaults
	    var modules = layoutOut._modules;
	    for(i = 0; i < modules.length; i++) {
	        _module = modules[i];
	
	        if(_module.supplyLayoutDefaults) {
	            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
	        }
	    }
	
	    // TODO register these
	    // Legend must come after traces (e.g. it depends on 'barmode')
	    var moduleLayoutDefaults = ['Fx', 'Annotations', 'Shapes', 'Legend', 'Images'];
	    for(i = 0; i < moduleLayoutDefaults.length; i++) {
	        _module = moduleLayoutDefaults[i];
	
	        if(Plotly[_module]) {
	            Plotly[_module].supplyLayoutDefaults(layoutIn, layoutOut, fullData);
	        }
	    }
	};
	
	// Remove all plotly attributes from a div so it can be replotted fresh
	// TODO: these really need to be encapsulated into a much smaller set...
	plots.purge = function(gd) {
	
	    // note: we DO NOT remove _context because it doesn't change when we insert
	    // a new plot, and may have been set outside of our scope.
	
	    var fullLayout = gd._fullLayout || {};
	    if(fullLayout._glcontainer !== undefined) fullLayout._glcontainer.remove();
	    if(fullLayout._geocontainer !== undefined) fullLayout._geocontainer.remove();
	
	    // remove modebar
	    if(fullLayout._modeBar) fullLayout._modeBar.destroy();
	
	    // data and layout
	    delete gd.data;
	    delete gd.layout;
	    delete gd._fullData;
	    delete gd._fullLayout;
	    delete gd.calcdata;
	    delete gd.framework;
	    delete gd.empty;
	
	    delete gd.fid;
	
	    delete gd.undoqueue; // action queue
	    delete gd.undonum;
	    delete gd.autoplay; // are we doing an action that doesn't go in undo queue?
	    delete gd.changed;
	
	    // these get recreated on Plotly.plot anyway, but just to be safe
	    // (and to have a record of them...)
	    delete gd._tester;
	    delete gd._testref;
	    delete gd._promises;
	    delete gd._redrawTimer;
	    delete gd._replotting;
	    delete gd.firstscatter;
	    delete gd.hmlumcount;
	    delete gd.hmpixcount;
	    delete gd.numboxes;
	    delete gd._hoverTimer;
	    delete gd._lastHoverTime;
	
	    // remove all event listeners
	    if(gd.removeAllListeners) gd.removeAllListeners();
	};
	
	plots.style = function(gd) {
	    var _modules = gd._fullLayout._modules;
	
	    for(var i = 0; i < _modules.length; i++) {
	        var _module = _modules[i];
	
	        if(_module.style) _module.style(gd);
	    }
	};
	
	plots.sanitizeMargins = function(fullLayout) {
	    // polar doesn't do margins...
	    if(!fullLayout || !fullLayout.margin) return;
	
	    var width = fullLayout.width,
	        height = fullLayout.height,
	        margin = fullLayout.margin,
	        plotWidth = width - (margin.l + margin.r),
	        plotHeight = height - (margin.t + margin.b),
	        correction;
	
	    // if margin.l + margin.r = 0 then plotWidth > 0
	    // as width >= 10 by supplyDefaults
	    // similarly for margin.t + margin.b
	
	    if(plotWidth < 0) {
	        correction = (width - 1) / (margin.l + margin.r);
	        margin.l = Math.floor(correction * margin.l);
	        margin.r = Math.floor(correction * margin.r);
	    }
	
	    if(plotHeight < 0) {
	        correction = (height - 1) / (margin.t + margin.b);
	        margin.t = Math.floor(correction * margin.t);
	        margin.b = Math.floor(correction * margin.b);
	    }
	};
	
	// called by legend and colorbar routines to see if we need to
	// expand the margins to show them
	// o is {x,l,r,y,t,b} where x and y are plot fractions,
	// the rest are pixels in each direction
	// or leave o out to delete this entry (like if it's hidden)
	plots.autoMargin = function(gd, id, o) {
	    var fullLayout = gd._fullLayout;
	
	    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};
	
	    if(fullLayout.margin.autoexpand !== false) {
	        if(!o) delete fullLayout._pushmargin[id];
	        else {
	            var pad = o.pad === undefined ? 12 : o.pad;
	
	            // if the item is too big, just give it enough automargin to
	            // make sure you can still grab it and bring it back
	            if(o.l+o.r > fullLayout.width*0.5) o.l = o.r = 0;
	            if(o.b+o.t > fullLayout.height*0.5) o.b = o.t = 0;
	
	            fullLayout._pushmargin[id] = {
	                l: {val: o.x, size: o.l+pad},
	                r: {val: o.x, size: o.r+pad},
	                b: {val: o.y, size: o.b+pad},
	                t: {val: o.y, size: o.t+pad}
	            };
	        }
	
	        if(!gd._replotting) plots.doAutoMargin(gd);
	    }
	};
	
	plots.doAutoMargin = function(gd) {
	    var fullLayout = gd._fullLayout;
	    if(!fullLayout._size) fullLayout._size = {};
	    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};
	
	    var gs = fullLayout._size,
	        oldmargins = JSON.stringify(gs);
	
	    // adjust margins for outside legends and colorbars
	    // fullLayout.margin is the requested margin,
	    // fullLayout._size has margins and plotsize after adjustment
	    var ml = Math.max(fullLayout.margin.l || 0, 0),
	        mr = Math.max(fullLayout.margin.r || 0, 0),
	        mt = Math.max(fullLayout.margin.t || 0, 0),
	        mb = Math.max(fullLayout.margin.b || 0, 0),
	        pm = fullLayout._pushmargin;
	
	    if(fullLayout.margin.autoexpand!==false) {
	        // fill in the requested margins
	        pm.base = {
	            l: {val: 0, size: ml},
	            r: {val: 1, size: mr},
	            t: {val: 1, size: mt},
	            b: {val: 0, size: mb}
	        };
	        // now cycle through all the combinations of l and r
	        // (and t and b) to find the required margins
	        Object.keys(pm).forEach(function(k1) {
	            var pushleft = pm[k1].l||{},
	                pushbottom = pm[k1].b||{},
	                fl = pushleft.val,
	                pl = pushleft.size,
	                fb = pushbottom.val,
	                pb = pushbottom.size;
	            Object.keys(pm).forEach(function(k2) {
	                if(isNumeric(pl) && pm[k2].r) {
	                    var fr = pm[k2].r.val,
	                        pr = pm[k2].r.size;
	                    if(fr>fl) {
	                        var newl = (pl*fr +
	                                (pr-fullLayout.width)*fl) / (fr-fl),
	                            newr = (pr*(1-fl) +
	                                (pl-fullLayout.width)*(1-fr)) / (fr-fl);
	                        if(newl>=0 && newr>=0 && newl+newr>ml+mr) {
	                            ml = newl;
	                            mr = newr;
	                        }
	                    }
	                }
	                if(isNumeric(pb) && pm[k2].t) {
	                    var ft = pm[k2].t.val,
	                        pt = pm[k2].t.size;
	                    if(ft>fb) {
	                        var newb = (pb*ft +
	                                (pt-fullLayout.height)*fb) / (ft-fb),
	                            newt = (pt*(1-fb) +
	                                (pb-fullLayout.height)*(1-ft)) / (ft-fb);
	                        if(newb>=0 && newt>=0 && newb+newt>mb+mt) {
	                            mb = newb;
	                            mt = newt;
	                        }
	                    }
	                }
	            });
	        });
	    }
	
	    gs.l = Math.round(ml);
	    gs.r = Math.round(mr);
	    gs.t = Math.round(mt);
	    gs.b = Math.round(mb);
	    gs.p = Math.round(fullLayout.margin.pad);
	    gs.w = Math.round(fullLayout.width)-gs.l-gs.r;
	    gs.h = Math.round(fullLayout.height)-gs.t-gs.b;
	
	    // if things changed and we're not already redrawing, trigger a redraw
	    if(!gd._replotting && oldmargins!=='{}' &&
	            oldmargins!==JSON.stringify(fullLayout._size)) {
	        return Plotly.plot(gd);
	    }
	};
	
	/**
	 * JSONify the graph data and layout
	 *
	 * This function needs to recurse because some src can be inside
	 * sub-objects.
	 *
	 * It also strips out functions and private (starts with _) elements.
	 * Therefore, we can add temporary things to data and layout that don't
	 * get saved.
	 *
	 * @param gd The graphDiv
	 * @param {Boolean} dataonly If true, don't return layout.
	 * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept
	 *      keepref: remove data for which there's a src present
	 *          eg if there's xsrc present (and xsrc is well-formed,
	 *          ie has : and some chars before it), strip out x
	 *      keepdata: remove all src tags, don't remove the data itself
	 *      keepall: keep data and src
	 * @param {String} output If you specify 'object', the result will not be stringified
	 * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData
	 * @returns {Object|String}
	 */
	plots.graphJson = function(gd, dataonly, mode, output, useDefaults) {
	    // if the defaults aren't supplied yet, we need to do that...
	    if((useDefaults && dataonly && !gd._fullData) ||
	            (useDefaults && !dataonly && !gd._fullLayout)) {
	        plots.supplyDefaults(gd);
	    }
	
	    var data = (useDefaults) ? gd._fullData : gd.data,
	        layout = (useDefaults) ? gd._fullLayout : gd.layout;
	
	    function stripObj(d) {
	        if(typeof d === 'function') {
	            return null;
	        }
	        if(Lib.isPlainObject(d)) {
	            var o={}, v, src;
	            for(v in d) {
	                // remove private elements and functions
	                // _ is for private, [ is a mistake ie [object Object]
	                if(typeof d[v]==='function' ||
	                        ['_','['].indexOf(v.charAt(0))!==-1) {
	                    continue;
	                }
	
	                // look for src/data matches and remove the appropriate one
	                if(mode==='keepdata') {
	                    // keepdata: remove all ...src tags
	                    if(v.substr(v.length-3)==='src') {
	                        continue;
	                    }
	                }
	                else if(mode==='keepstream') {
	                    // keep sourced data if it's being streamed.
	                    // similar to keepref, but if the 'stream' object exists
	                    // in a trace, we will keep the data array.
	                    src = d[v+'src'];
	                    if(typeof src==='string' && src.indexOf(':')>0) {
	                        if(!Lib.isPlainObject(d.stream)) {
	                            continue;
	                        }
	                    }
	                }
	                else if(mode!=='keepall') {
	                    // keepref: remove sourced data but only
	                    // if the source tag is well-formed
	                    src = d[v+'src'];
	                    if(typeof src==='string' && src.indexOf(':')>0) {
	                        continue;
	                    }
	                }
	
	                // OK, we're including this... recurse into it
	                o[v] = stripObj(d[v]);
	            }
	            return o;
	        }
	
	        if(Array.isArray(d)) {
	            return d.map(stripObj);
	        }
	
	        // convert native dates to date strings...
	        // mostly for external users exporting to plotly
	        if(d && d.getTime) {
	            return Lib.ms2DateTime(d);
	        }
	
	        return d;
	    }
	
	    var obj = {
	        data: (data || []).map(function(v) {
	            var d = stripObj(v);
	            // fit has some little arrays in it that don't contain data,
	            // just fit params and meta
	            if(dataonly) { delete d.fit; }
	            return d;
	        })
	    };
	    if(!dataonly) { obj.layout = stripObj(layout); }
	
	    if(gd.framework && gd.framework.isPolar) obj = gd.framework.getConfig();
	
	    return (output==='object') ? obj : JSON.stringify(obj);
	};


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var tinycolor = __webpack_require__(315);
	var isNumeric = __webpack_require__(312);
	
	var color = module.exports = {};
	
	var colorAttrs = __webpack_require__(334);
	color.defaults = colorAttrs.defaults;
	color.defaultLine = colorAttrs.defaultLine;
	color.lightLine = colorAttrs.lightLine;
	color.background = colorAttrs.background;
	
	color.tinyRGB = function(tc) {
	    var c = tc.toRgb();
	    return 'rgb(' + Math.round(c.r) + ', ' +
	        Math.round(c.g) + ', ' + Math.round(c.b) + ')';
	};
	
	color.rgb = function(cstr) { return color.tinyRGB(tinycolor(cstr)); };
	
	color.opacity = function(cstr) { return cstr ? tinycolor(cstr).getAlpha() : 0; };
	
	color.addOpacity = function(cstr, op) {
	    var c = tinycolor(cstr).toRgb();
	    return 'rgba(' + Math.round(c.r) + ', ' +
	        Math.round(c.g) + ', ' + Math.round(c.b) + ', ' + op + ')';
	};
	
	// combine two colors into one apparent color
	// if back has transparency or is missing,
	// color.background is assumed behind it
	color.combine = function(front, back) {
	    var fc = tinycolor(front).toRgb();
	    if(fc.a===1) return tinycolor(front).toRgbString();
	
	    var bc = tinycolor(back||color.background).toRgb(),
	        bcflat = bc.a===1 ? bc : {
	            r: 255 * (1-bc.a) + bc.r*bc.a,
	            g: 255 * (1-bc.a) + bc.g*bc.a,
	            b: 255 * (1-bc.a) + bc.b*bc.a
	        },
	        fcflat = {
	            r: bcflat.r*(1-fc.a) + fc.r*fc.a,
	            g: bcflat.g*(1-fc.a) + fc.g*fc.a,
	            b: bcflat.b*(1-fc.a) + fc.b*fc.a
	        };
	    return tinycolor(fcflat).toRgbString();
	};
	
	color.stroke = function(s, c) {
	    var tc = tinycolor(c);
	    s.style({'stroke': color.tinyRGB(tc), 'stroke-opacity': tc.getAlpha()});
	};
	
	color.fill = function(s, c) {
	    var tc = tinycolor(c);
	    s.style({'fill': color.tinyRGB(tc), 'fill-opacity': tc.getAlpha()});
	};
	
	// search container for colors with the deprecated rgb(fractions) format
	// and convert them to rgb(0-255 values)
	color.clean = function(container) {
	    if(!container || typeof container !== 'object') return;
	
	    var keys = Object.keys(container),
	        i,
	        j,
	        key,
	        val;
	
	    for(i = 0; i < keys.length; i++) {
	        key = keys[i];
	        val = container[key];
	
	        // only sanitize keys that end in "color" or "colorscale"
	        if(key.substr(key.length - 5) === 'color') {
	            if(Array.isArray(val)) {
	                for(j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);
	            }
	            else container[key] = cleanOne(val);
	        }
	        else if(key.substr(key.length - 10) === 'colorscale' && Array.isArray(val)) {
	            // colorscales have the format [[0, color1], [frac, color2], ... [1, colorN]]
	            for(j = 0; j < val.length; j++) {
	                if(Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);
	            }
	        }
	        // recurse into arrays of objects, and plain objects
	        else if(Array.isArray(val)) {
	            var el0 = val[0];
	            if(!Array.isArray(el0) && el0 && typeof el0 === 'object') {
	                for(j = 0; j < val.length; j++) color.clean(val[j]);
	            }
	        }
	        else if(val && typeof val === 'object') color.clean(val);
	    }
	};
	
	function cleanOne(val) {
	    if(isNumeric(val) || typeof val !== 'string') return val;
	
	    var valTrim = val.trim();
	    if(valTrim.substr(0,3) !== 'rgb') return val;
	
	    var match = valTrim.match(/^rgba?\s*\(([^()]*)\)$/);
	    if(!match) return val;
	
	    var parts = match[1].trim().split(/\s*[\s,]\s*/),
	        rgba = valTrim.charAt(3) === 'a' && parts.length === 4;
	    if(!rgba && parts.length !== 3) return val;
	
	    for(var i = 0; i < parts.length; i++) {
	        if(!parts[i].length) return val;
	        parts[i] = Number(parts[i]);
	
	        // all parts must be non-negative numbers
	        if(!(parts[i] >= 0)) return val;
	        // alpha>1 gets clipped to 1
	        if(i === 3) {
	            if(parts[i] > 1) parts[i] = 1;
	        }
	        // r, g, b must be < 1 (ie 1 itself is not allowed)
	        else if(parts[i] >= 1) return val;
	    }
	
	    var rgbStr = Math.round(parts[0] * 255) + ', ' +
	        Math.round(parts[1] * 255) + ', ' +
	        Math.round(parts[2] * 255);
	
	    if(rgba) return 'rgba(' + rgbStr + ', ' + parts[3] + ')';
	    return 'rgb(' + rgbStr + ')';
	}


/***/ },
/* 334 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	// IMPORTANT - default colors should be in hex for compatibility
	exports.defaults = [
	    '#1f77b4',  // muted blue
	    '#ff7f0e',  // safety orange
	    '#2ca02c',  // cooked asparagus green
	    '#d62728',  // brick red
	    '#9467bd',  // muted purple
	    '#8c564b',  // chestnut brown
	    '#e377c2',  // raspberry yogurt pink
	    '#7f7f7f',  // middle gray
	    '#bcbd22',  // curry yellow-green
	    '#17becf'   // blue-teal
	];
	
	exports.defaultLine = '#444';
	
	exports.lightLine = '#eee';
	
	exports.background = '#fff';
	
	// with axis.color and Color.interp we aren't using lightLine
	// itself anymore, instead interpolating between axis.color
	// and the background color using tinycolor.mix. lightFraction
	// gives back exactly lightLine if the other colors are defaults.
	exports.lightFraction = 100 * (0xe - 0x4) / (0xf - 0x4);


/***/ },
/* 335 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    type: {
	        valType: 'enumerated',
	        role: 'info',
	        values: [],     // listed dynamically
	        dflt: 'scatter'
	    },
	    visible: {
	        valType: 'enumerated',
	        values: [true, false, 'legendonly'],
	        role: 'info',
	        dflt: true,
	        description: [
	            'Determines whether or not this trace is visible.',
	            'If *legendonly*, the trace is not drawn,',
	            'but can appear as a legend item',
	            '(provided that the legend itself is visible).'
	        ].join(' ')
	    },
	    showlegend: {
	        valType: 'boolean',
	        role: 'info',
	        dflt: true,
	        description: [
	            'Determines whether or not an item corresponding to this',
	            'trace is shown in the legend.'
	        ].join(' ')
	    },
	    legendgroup: {
	        valType: 'string',
	        role: 'info',
	        dflt: '',
	        description: [
	            'Sets the legend group for this trace.',
	            'Figures part of the same legend group hide/show at the same time',
	            'when toggling legend items.'
	        ].join(' ')
	    },
	    opacity: {
	        valType: 'number',
	        role: 'style',
	        min: 0,
	        max: 1,
	        dflt: 1,
	        description: 'Sets the opacity of the trace.'
	    },
	    name: {
	        valType: 'string',
	        role: 'info',
	        description: [
	            'Sets the trace name.',
	            'The trace name appear as the legend item and on hover.'
	        ].join(' ')
	    },
	    uid: {
	        valType: 'string',
	        role: 'info',
	        dflt: ''
	    },
	    hoverinfo: {
	        valType: 'flaglist',
	        role: 'info',
	        flags: ['x', 'y', 'z', 'text', 'name'],
	        extras: ['all', 'none'],
	        dflt: 'all',
	        description: 'Determines which trace information appear on hover.'
	    },
	    stream: {
	        token: {
	            valType: 'string',
	            noBlank: true,
	            strict: true,
	            role: 'info',
	            description: [
	                'The stream id number links a data trace on a plot with a stream.',
	                'See https://plot.ly/settings for more details.'
	            ].join(' ')
	        },
	        maxpoints: {
	            valType: 'number',
	            min: 0,
	            role: 'info',
	            description: [
	                'Sets the maximum number of points to keep on the plots from an',
	                'incoming stream.',
	                'If `maxpoints` is set to *50*, only the newest 50 points will',
	                'be displayed on the plot.'
	            ].join(' ')
	        }
	    }
	};


/***/ },
/* 336 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    family: {
	        valType: 'string',
	        role: 'style',
	        noBlank: true,
	        strict: true,
	        description: [
	            'HTML font family - the typeface that will be applied by the web browser.',
	            'The web browser will only be able to apply a font if it is available on the system',
	            'which it operates. Provide multiple font families, separated by commas, to indicate',
	            'the preference in which to apply fonts if they aren\'t available on the system.',
	            'The plotly service (at https://plot.ly or on-premise) generates images on a server,',
	            'where only a select number of',
	            'fonts are installed and supported.',
	            'These include *Arial*, *Balto*, *Courier New*, *Droid Sans*,, *Droid Serif*,',
	            '*Droid Sans Mono*, *Gravitas One*, *Old Standard TT*, *Open Sans*, *Overpass*,',
	            '*PT Sans Narrow*, *Raleway*, *Times New Roman*.'
	        ].join(' ')
	    },
	    size: {
	        valType: 'number',
	        role: 'style',
	        min: 1
	    },
	    color: {
	        valType: 'color',
	        role: 'style'
	    }
	};


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	
	var fontAttrs = __webpack_require__(336);
	var colorAttrs = __webpack_require__(334);
	
	var extendFlat = Plotly.Lib.extendFlat;
	
	
	module.exports = {
	    font: {
	        family: extendFlat({}, fontAttrs.family, {
	            dflt: '"Open Sans", verdana, arial, sans-serif'
	        }),
	        size: extendFlat({}, fontAttrs.size, {
	            dflt: 12
	        }),
	        color: extendFlat({}, fontAttrs.color, {
	            dflt: colorAttrs.defaultLine
	        }),
	        description: [
	            'Sets the global font.',
	            'Note that fonts used in traces and other',
	            'layout components inherit from the global font.'
	        ].join(' ')
	    },
	    title: {
	        valType: 'string',
	        role: 'info',
	        dflt: 'Click to enter Plot title',
	        description: [
	            'Sets the plot\'s title.'
	        ].join(' ')
	    },
	    titlefont: extendFlat({}, fontAttrs, {
	        description: 'Sets the title font.'
	    }),
	    autosize: {
	        valType: 'enumerated',
	        role: 'info',
	        // TODO: better handling of 'initial'
	        values: [true, false, 'initial'],
	        description: [
	            'Determines whether or not the dimensions of the figure are',
	            'computed as a function of the display size.'
	        ].join(' ')
	    },
	    width: {
	        valType: 'number',
	        role: 'info',
	        min: 10,
	        dflt: 700,
	        description: [
	            'Sets the plot\'s width (in px).'
	        ].join(' ')
	    },
	    height: {
	        valType: 'number',
	        role: 'info',
	        min: 10,
	        dflt: 450,
	        description: [
	            'Sets the plot\'s height (in px).'
	        ].join(' ')
	    },
	    margin: {
	        l: {
	            valType: 'number',
	            role: 'info',
	            min: 0,
	            dflt: 80,
	            description: 'Sets the left margin (in px).'
	        },
	        r: {
	            valType: 'number',
	            role: 'info',
	            min: 0,
	            dflt: 80,
	            description: 'Sets the right margin (in px).'
	        },
	        t: {
	            valType: 'number',
	            role: 'info',
	            min: 0,
	            dflt: 100,
	            description: 'Sets the top margin (in px).'
	        },
	        b: {
	            valType: 'number',
	            role: 'info',
	            min: 0,
	            dflt: 80,
	            description: 'Sets the bottom margin (in px).'
	        },
	        pad: {
	            valType: 'number',
	            role: 'info',
	            min: 0,
	            dflt: 0,
	            description: [
	                'Sets the amount of padding (in px)',
	                'between the plotting area and the axis lines'
	            ].join(' ')
	        },
	        autoexpand: {
	            valType: 'boolean',
	            role: 'info',
	            dflt: true
	        }
	    },
	    paper_bgcolor: {
	        valType: 'color',
	        role: 'style',
	        dflt: colorAttrs.background,
	        description: 'Sets the color of paper where the graph is drawn.'
	    },
	    plot_bgcolor: {
	        // defined here, but set in Axes.supplyLayoutDefaults
	        // because it needs to know if there are (2D) axes or not
	        valType: 'color',
	        role: 'style',
	        dflt: colorAttrs.background,
	        description: [
	            'Sets the color of plotting area in-between x and y axes.'
	        ].join(' ')
	    },
	    separators: {
	        valType: 'string',
	        role: 'style',
	        dflt: '.,',
	        description: [
	            'Sets the decimal and thousand separators.',
	            'For example, *. * puts a \'.\' before decimals and',
	            'a space between thousands.'
	        ].join(' ')
	    },
	    hidesources: {
	        valType: 'boolean',
	        role: 'info',
	        dflt: false,
	        description: [
	            'Determines whether or not a text link citing the data source is',
	            'placed at the bottom-right cored of the figure.',
	            'Has only an effect only on graphs that have been generated via',
	            'forked graphs from the plotly service (at https://plot.ly or on-premise).'
	        ].join(' ')
	    },
	    smith: {
	        // will become a boolean if/when we implement this
	        valType: 'enumerated',
	        role: 'info',
	        values: [false],
	        dflt: false
	    },
	    showlegend: {
	        // handled in legend.supplyLayoutDefaults
	        // but included here because it's not in the legend object
	        valType: 'boolean',
	        role: 'info',
	        description: 'Determines whether or not a legend is drawn.'
	    },
	
	    _composedModules: {
	        '*': 'Fx'
	    },
	
	    // TODO merge with moduleLayoutDefaults in plots.js
	    _nestedModules: {
	        'xaxis': 'Axes',
	        'yaxis': 'Axes',
	        'scene': 'gl3d',
	        'geo': 'geo',
	        'legend': 'Legend',
	        'annotations': 'Annotations',
	        'shapes': 'Shapes',
	        'images': 'Images',
	        'ternary': 'ternary'
	    }
	};


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var svgTextUtils = __webpack_require__(326);
	var Titles = __webpack_require__(339);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	
	
	var axes = module.exports = {};
	
	axes.layoutAttributes = __webpack_require__(348);
	axes.supplyLayoutDefaults = __webpack_require__(363);
	
	axes.setConvert = __webpack_require__(378);
	
	var axisIds = __webpack_require__(373);
	axes.id2name = axisIds.id2name;
	axes.cleanId = axisIds.cleanId;
	axes.list = axisIds.list;
	axes.listIds = axisIds.listIds;
	axes.getFromId = axisIds.getFromId;
	axes.getFromTrace = axisIds.getFromTrace;
	
	
	// find the list of possible axes to reference with an xref or yref attribute
	// and coerce it to that list
	axes.coerceRef = function(containerIn, containerOut, gd, axLetter, dflt) {
	    var axlist = gd._fullLayout._has('gl2d') ? [] : axes.listIds(gd, axLetter),
	        refAttr = axLetter + 'ref',
	        attrDef = {};
	
	    // data-ref annotations are not supported in gl2d yet
	
	    attrDef[refAttr] = {
	        valType: 'enumerated',
	        values: axlist.concat(['paper']),
	        dflt: dflt || axlist[0] || 'paper'
	    };
	
	    // xref, yref
	    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
	};
	
	// empty out types for all axes containing these traces
	// so we auto-set them again
	axes.clearTypes = function(gd, traces) {
	    if(!Array.isArray(traces) || !traces.length) {
	        traces = (gd._fullData).map(function(d, i) { return i; });
	    }
	    traces.forEach(function(tracenum) {
	        var trace = gd.data[tracenum];
	        delete (axes.getFromId(gd, trace.xaxis) || {}).type;
	        delete (axes.getFromId(gd, trace.yaxis) || {}).type;
	    });
	};
	
	// get counteraxis letter for this axis (name or id)
	// this can also be used as the id for default counter axis
	axes.counterLetter = function(id) {
	    var axLetter = id.charAt(0);
	    if(axLetter === 'x') return 'y';
	    if(axLetter === 'y') return 'x';
	};
	
	// incorporate a new minimum difference and first tick into
	// forced
	axes.minDtick = function(ax,newDiff,newFirst,allow) {
	    // doesn't make sense to do forced min dTick on log or category axes,
	    // and the plot itself may decide to cancel (ie non-grouped bars)
	    if(['log','category'].indexOf(ax.type)!==-1 || !allow) {
	        ax._minDtick = 0;
	    }
	    // null means there's nothing there yet
	    else if(ax._minDtick===null) {
	        ax._minDtick = newDiff;
	        ax._forceTick0 = newFirst;
	    }
	    else if(ax._minDtick) {
	        // existing minDtick is an integer multiple of newDiff
	        // (within rounding err)
	        // and forceTick0 can be shifted to newFirst
	        if((ax._minDtick/newDiff+1e-6)%1 < 2e-6 &&
	                (((newFirst-ax._forceTick0)/newDiff%1) +
	                    1.000001) % 1 < 2e-6) {
	            ax._minDtick = newDiff;
	            ax._forceTick0 = newFirst;
	        }
	        // if the converse is true (newDiff is a multiple of minDtick and
	        // newFirst can be shifted to forceTick0) then do nothing - same
	        // forcing stands. Otherwise, cancel forced minimum
	        else if((newDiff/ax._minDtick+1e-6)%1 > 2e-6 ||
	                (((newFirst-ax._forceTick0)/ax._minDtick%1) +
	                    1.000001) % 1 > 2e-6) {
	            ax._minDtick = 0;
	        }
	    }
	};
	
	axes.getAutoRange = function(ax) {
	    var newRange = [];
	
	    var minmin = ax._min[0].val,
	        maxmax = ax._max[0].val,
	        i;
	
	    for(i = 1; i < ax._min.length; i++) {
	        if(minmin !== maxmax) break;
	        minmin = Math.min(minmin, ax._min[i].val);
	    }
	    for(i = 1; i < ax._max.length; i++) {
	        if(minmin !== maxmax) break;
	        maxmax = Math.max(maxmax, ax._max[i].val);
	    }
	
	    var j,minpt,maxpt,minbest,maxbest,dp,dv,
	        mbest = 0,
	        axReverse = (ax.range && ax.range[1]<ax.range[0]);
	
	    // one-time setting to easily reverse the axis
	    // when plotting from code
	    if(ax.autorange === 'reversed') {
	        axReverse = true;
	        ax.autorange = true;
	    }
	
	    for(i=0; i<ax._min.length; i++) {
	        minpt = ax._min[i];
	        for(j=0; j<ax._max.length; j++) {
	            maxpt = ax._max[j];
	            dv = maxpt.val-minpt.val;
	            dp = ax._length-minpt.pad-maxpt.pad;
	            if(dv>0 && dp>0 && dv/dp > mbest) {
	                minbest = minpt;
	                maxbest = maxpt;
	                mbest = dv/dp;
	            }
	        }
	    }
	
	    if(minmin === maxmax) {
	        newRange = axReverse ?
	            [minmin+1, ax.rangemode!=='normal' ? 0 : minmin-1] :
	            [ax.rangemode!=='normal' ? 0 : minmin-1, minmin+1];
	    }
	    else if(mbest) {
	        if(ax.type==='linear' || ax.type==='-') {
	            if(ax.rangemode==='tozero' && minbest.val>=0) {
	                minbest = {val: 0, pad: 0};
	            }
	            else if(ax.rangemode==='nonnegative') {
	                if(minbest.val - mbest*minbest.pad<0) {
	                    minbest = {val: 0, pad: 0};
	                }
	                if(maxbest.val<0) {
	                    maxbest = {val: 1, pad: 0};
	                }
	            }
	
	            // in case it changed again...
	            mbest = (maxbest.val-minbest.val) /
	                (ax._length-minbest.pad-maxbest.pad);
	        }
	
	        newRange = [
	            minbest.val - mbest*minbest.pad,
	            maxbest.val + mbest*maxbest.pad
	        ];
	
	        // don't let axis have zero size
	        if(newRange[0] === newRange[1]) {
	            newRange = [newRange[0]-1, newRange[0]+1];
	        }
	
	        // maintain reversal
	        if(axReverse) {
	            newRange.reverse();
	        }
	    }
	
	    return newRange;
	};
	
	axes.doAutoRange = function(ax) {
	    if(!ax._length) ax.setScale();
	
	    // TODO do we really need this?
	    var hasDeps = (ax._min && ax._max && ax._min.length && ax._max.length);
	
	    if(ax.autorange && hasDeps) {
	        ax.range = axes.getAutoRange(ax);
	
	        // doAutoRange will get called on fullLayout,
	        // but we want to report its results back to layout
	        var axIn = ax._gd.layout[ax._name];
	
	        if(!axIn) ax._gd.layout[ax._name] = axIn = {};
	
	        if(axIn !== ax) {
	            axIn.range = ax.range.slice();
	            axIn.autorange = ax.autorange;
	        }
	    }
	};
	
	// save a copy of the initial axis ranges in fullLayout
	// use them in mode bar and dblclick events
	axes.saveRangeInitial = function(gd, overwrite) {
	    var axList = axes.list(gd, '', true),
	        hasOneAxisChanged = false;
	
	    for(var i = 0; i < axList.length; i++) {
	        var ax = axList[i];
	
	        var isNew = (ax._rangeInitial === undefined);
	        var hasChanged = (
	            isNew || !(
	                ax.range[0] === ax._rangeInitial[0] &&
	                ax.range[1] === ax._rangeInitial[1]
	            )
	        );
	
	        if((isNew && ax.autorange === false) || (overwrite && hasChanged)) {
	            ax._rangeInitial = ax.range.slice();
	            hasOneAxisChanged = true;
	        }
	    }
	
	    return hasOneAxisChanged;
	};
	
	// axes.expand: if autoranging, include new data in the outer limits
	// for this axis
	// data is an array of numbers (ie already run through ax.d2c)
	// available options:
	//      vpad: (number or number array) pad values (data value +-vpad)
	//      ppad: (number or number array) pad pixels (pixel location +-ppad)
	//      ppadplus, ppadminus, vpadplus, vpadminus:
	//          separate padding for each side, overrides symmetric
	//      padded: (boolean) add 5% padding to both ends
	//          (unless one end is overridden by tozero)
	//      tozero: (boolean) make sure to include zero if axis is linear,
	//          and make it a tight bound if possible
	var FP_SAFE = Number.MAX_VALUE/2;
	axes.expand = function(ax, data, options) {
	    if(!(ax.autorange || ax._needsExpand) || !data) return;
	    if(!ax._min) ax._min = [];
	    if(!ax._max) ax._max = [];
	    if(!options) options = {};
	    if(!ax._m) ax.setScale();
	
	    var len = data.length,
	        extrappad = options.padded ? ax._length*0.05 : 0,
	        tozero = options.tozero && (ax.type==='linear' || ax.type==='-'),
	        i, j, v, di, dmin, dmax,
	        ppadiplus, ppadiminus, includeThis, vmin, vmax;
	
	    function getPad(item) {
	        if(Array.isArray(item)) {
	            return function(i) { return Math.max(Number(item[i]||0),0); };
	        }
	        else {
	            var v = Math.max(Number(item||0),0);
	            return function() { return v; };
	        }
	    }
	    var ppadplus = getPad((ax._m>0 ?
	            options.ppadplus : options.ppadminus) || options.ppad || 0),
	        ppadminus = getPad((ax._m>0 ?
	            options.ppadminus : options.ppadplus) || options.ppad || 0),
	        vpadplus = getPad(options.vpadplus||options.vpad),
	        vpadminus = getPad(options.vpadminus||options.vpad);
	
	    function addItem(i) {
	        di = data[i];
	        if(!isNumeric(di)) return;
	        ppadiplus = ppadplus(i) + extrappad;
	        ppadiminus = ppadminus(i) + extrappad;
	        vmin = di-vpadminus(i);
	        vmax = di+vpadplus(i);
	        // special case for log axes: if vpad makes this object span
	        // more than an order of mag, clip it to one order. This is so
	        // we don't have non-positive errors or absurdly large lower
	        // range due to rounding errors
	        if(ax.type==='log' && vmin<vmax/10) { vmin = vmax/10; }
	
	        dmin = ax.c2l(vmin);
	        dmax = ax.c2l(vmax);
	
	        if(tozero) {
	            dmin = Math.min(0,dmin);
	            dmax = Math.max(0,dmax);
	        }
	
	        // In order to stop overflow errors, don't consider points
	        // too close to the limits of js floating point
	        function goodNumber(v) {
	            return isNumeric(v) && Math.abs(v)<FP_SAFE;
	        }
	
	        if(goodNumber(dmin)) {
	            includeThis = true;
	            // take items v from ax._min and compare them to the
	            // presently active point:
	            // - if the item supercedes the new point, set includethis false
	            // - if the new pt supercedes the item, delete it from ax._min
	            for(j=0; j<ax._min.length && includeThis; j++) {
	                v = ax._min[j];
	                if(v.val<=dmin && v.pad>=ppadiminus) {
	                    includeThis = false;
	                }
	                else if(v.val>=dmin && v.pad<=ppadiminus) {
	                    ax._min.splice(j,1);
	                    j--;
	                }
	            }
	            if(includeThis) {
	                ax._min.push({
	                    val: dmin,
	                    pad: (tozero && dmin===0) ? 0 : ppadiminus
	                });
	            }
	        }
	
	        if(goodNumber(dmax)) {
	            includeThis = true;
	            for(j=0; j<ax._max.length && includeThis; j++) {
	                v = ax._max[j];
	                if(v.val>=dmax && v.pad>=ppadiplus) {
	                    includeThis = false;
	                }
	                else if(v.val<=dmax && v.pad<=ppadiplus) {
	                    ax._max.splice(j,1);
	                    j--;
	                }
	            }
	            if(includeThis) {
	                ax._max.push({
	                    val: dmax,
	                    pad: (tozero && dmax===0) ? 0 : ppadiplus
	                });
	            }
	        }
	    }
	
	    // For efficiency covering monotonic or near-monotonic data,
	    // check a few points at both ends first and then sweep
	    // through the middle
	    for(i=0; i<6; i++) addItem(i);
	    for(i=len-1; i>5; i--) addItem(i);
	
	};
	
	axes.autoBin = function(data,ax,nbins,is2d) {
	    var datamin = Lib.aggNums(Math.min, null, data),
	        datamax = Lib.aggNums(Math.max, null, data);
	    if(ax.type==='category') {
	        return {
	            start: datamin - 0.5,
	            end: datamax + 0.5,
	            size: 1
	        };
	    }
	
	    var size0;
	    if(nbins) size0 = ((datamax-datamin)/nbins);
	    else {
	        // totally auto: scale off std deviation so the highest bin is
	        // somewhat taller than the total number of bins, but don't let
	        // the size get smaller than the 'nice' rounded down minimum
	        // difference between values
	        var distinctData = Lib.distinctVals(data),
	            msexp = Math.pow(10, Math.floor(
	                Math.log(distinctData.minDiff) / Math.LN10)),
	            // TODO: there are some date cases where this will fail...
	            minSize = msexp * Lib.roundUp(
	                distinctData.minDiff/msexp, [0.9, 1.9, 4.9, 9.9], true);
	        size0 = Math.max(minSize, 2 * Lib.stdev(data) /
	            Math.pow(data.length, is2d ? 0.25 : 0.4));
	    }
	
	    // piggyback off autotick code to make "nice" bin sizes
	    var dummyax = {
	        type: ax.type==='log' ? 'linear' : ax.type,
	        range: [datamin, datamax]
	    };
	    axes.autoTicks(dummyax, size0);
	    var binstart = axes.tickIncrement(
	            axes.tickFirst(dummyax), dummyax.dtick, 'reverse'),
	        binend;
	
	    function nearEdge(v) {
	        // is a value within 1% of a bin edge?
	        return (1 + (v-binstart)*100/dummyax.dtick)%100 < 2;
	    }
	
	    // check for too many data points right at the edges of bins
	    // (>50% within 1% of bin edges) or all data points integral
	    // and offset the bins accordingly
	    if(typeof dummyax.dtick === 'number') {
	        var edgecount = 0,
	            midcount = 0,
	            intcount = 0,
	            blankcount = 0;
	        for(var i=0; i<data.length; i++) {
	            if(data[i]%1===0) intcount++;
	            else if(!isNumeric(data[i])) blankcount++;
	
	            if(nearEdge(data[i])) edgecount++;
	            if(nearEdge(data[i] + dummyax.dtick/2)) midcount++;
	        }
	        var datacount = data.length - blankcount;
	
	        if(intcount===datacount && ax.type!=='date') {
	            // all integers: if bin size is <1, it's because
	            // that was specifically requested (large nbins)
	            // so respect that... but center the bins containing
	            // integers on those integers
	            if(dummyax.dtick<1) {
	                binstart = datamin - 0.5 * dummyax.dtick;
	            }
	            // otherwise start half an integer down regardless of
	            // the bin size, just enough to clear up endpoint
	            // ambiguity about which integers are in which bins.
	            else binstart -= 0.5;
	        }
	        else if(midcount < datacount * 0.1) {
	            if(edgecount > datacount * 0.3 ||
	                    nearEdge(datamin) || nearEdge(datamax)) {
	                // lots of points at the edge, not many in the middle
	                // shift half a bin
	                var binshift = dummyax.dtick / 2;
	                binstart += (binstart+binshift<datamin) ? binshift : -binshift;
	            }
	        }
	
	        var bincount = 1 + Math.floor((datamax - binstart) / dummyax.dtick);
	        binend = binstart + bincount * dummyax.dtick;
	    }
	    else {
	        // calculate the endpoint for nonlinear ticks - you have to
	        // just increment until you're done
	        binend = binstart;
	        while(binend<=datamax) {
	            binend = axes.tickIncrement(binend, dummyax.dtick);
	        }
	    }
	
	    return {
	        start: binstart,
	        end: binend,
	        size: dummyax.dtick
	    };
	};
	
	
	// ----------------------------------------------------
	// Ticks and grids
	// ----------------------------------------------------
	
	// calculate the ticks: text, values, positioning
	// if ticks are set to automatic, determine the right values (tick0,dtick)
	// in any case, set tickround to # of digits to round tick labels to,
	// or codes to this effect for log and date scales
	axes.calcTicks = function calcTicks(ax) {
	    if(ax.tickmode === 'array') return arrayTicks(ax);
	
	    // calculate max number of (auto) ticks to display based on plot size
	    if(ax.tickmode === 'auto' || !ax.dtick) {
	        var nt = ax.nticks,
	            minPx;
	        if(!nt) {
	            if(ax.type === 'category') {
	                minPx = ax.tickfont ? (ax.tickfont.size || 12) * 1.2 : 15;
	                nt = ax._length / minPx;
	            }
	            else {
	                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;
	                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
	            }
	        }
	        axes.autoTicks(ax,Math.abs(ax.range[1]-ax.range[0])/nt);
	        // check for a forced minimum dtick
	        if(ax._minDtick>0 && ax.dtick<ax._minDtick*2) {
	            ax.dtick = ax._minDtick;
	            ax.tick0 = ax._forceTick0;
	        }
	    }
	
	    // check for missing tick0
	    if(!ax.tick0) {
	        ax.tick0 = (ax.type==='date') ?
	            new Date(2000,0,1).getTime() : 0;
	    }
	
	    // now figure out rounding of tick values
	    autoTickRound(ax);
	
	    // find the first tick
	    ax._tmin=axes.tickFirst(ax);
	
	    // check for reversed axis
	    var axrev = (ax.range[1]<ax.range[0]);
	
	    // return the full set of tick vals
	    var vals = [],
	        // add a tiny bit so we get ticks which may have rounded out
	        endtick = ax.range[1] * 1.0001 - ax.range[0]*0.0001;
	    if(ax.type==='category') {
	        endtick = (axrev) ? Math.max(-0.5,endtick) :
	            Math.min(ax._categories.length-0.5,endtick);
	    }
	    for(var x = ax._tmin;
	            (axrev)?(x>=endtick):(x<=endtick);
	            x = axes.tickIncrement(x,ax.dtick,axrev)) {
	        vals.push(x);
	
	        // prevent infinite loops
	        if(vals.length>1000) break;
	    }
	
	    // save the last tick as well as first, so we can
	    // show the exponent only on the last one
	    ax._tmax = vals[vals.length - 1];
	
	    var ticksOut = new Array(vals.length);
	    for(var i = 0; i < vals.length; i++) ticksOut[i] = axes.tickText(ax, vals[i]);
	
	    return ticksOut;
	};
	
	function arrayTicks(ax) {
	    var vals = ax.tickvals,
	        text = ax.ticktext,
	        ticksOut = new Array(vals.length),
	        r0expanded = ax.range[0] * 1.0001 - ax.range[1] * 0.0001,
	        r1expanded = ax.range[1] * 1.0001 - ax.range[0] * 0.0001,
	        tickMin = Math.min(r0expanded, r1expanded),
	        tickMax = Math.max(r0expanded, r1expanded),
	        vali,
	        i,
	        j = 0;
	
	
	    // without a text array, just format the given values as any other ticks
	    // except with more precision to the numbers
	    if(!Array.isArray(text)) text = [];
	
	    for(i = 0; i < vals.length; i++) {
	        vali = ax.d2l(vals[i]);
	        if(vali > tickMin && vali < tickMax) {
	            if(text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);
	            else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));
	            j++;
	        }
	    }
	
	    if(j < vals.length) ticksOut.splice(j, vals.length - j);
	
	    return ticksOut;
	}
	
	var roundBase10 = [2, 5, 10],
	    roundBase24 = [1, 2, 3, 6, 12],
	    roundBase60 = [1, 2, 5, 10, 15, 30],
	    // 2&3 day ticks are weird, but need something btwn 1&7
	    roundDays = [1, 2, 3, 7, 14],
	    // approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)
	    // these don't have to be exact, just close enough to round to the right value
	    roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1],
	    roundLog2 = [-0.301, 0, 0.301, 0.699, 1];
	
	function roundDTick(roughDTick, base, roundingSet) {
	    return base * Lib.roundUp(roughDTick / base, roundingSet);
	}
	
	// autoTicks: calculate best guess at pleasant ticks for this axis
	// inputs:
	//      ax - an axis object
	//      roughDTick - rough tick spacing (to be turned into a nice round number)
	// outputs (into ax):
	//   tick0: starting point for ticks (not necessarily on the graph)
	//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates
	//   dtick: the actual, nice round tick spacing, somewhat larger than roughDTick
	//      if the ticks are spaced linearly (linear scale, categories,
	//          log with only full powers, date ticks < month),
	//          this will just be a number
	//      months: M#
	//      years: M# where # is 12*number of years
	//      log with linear ticks: L# where # is the linear tick spacing
	//      log showing powers plus some intermediates:
	//          D1 shows all digits, D2 shows 2 and 5
	axes.autoTicks = function(ax, roughDTick) {
	    var base;
	
	    if(ax.type === 'date') {
	        ax.tick0 = new Date(2000, 0, 1).getTime();
	
	        if(roughDTick > 15778800000) {
	            // years if roughDTick > 6mo
	            roughDTick /= 31557600000;
	            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
	            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));
	        }
	        else if(roughDTick > 1209600000) {
	            // months if roughDTick > 2wk
	            roughDTick /= 2629800000;
	            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);
	        }
	        else if(roughDTick > 43200000) {
	            // days if roughDTick > 12h
	            ax.dtick = roundDTick(roughDTick, 86400000, roundDays);
	            // get week ticks on sunday
	            ax.tick0 = new Date(2000, 0, 2).getTime();
	        }
	        else if(roughDTick > 1800000) {
	            // hours if roughDTick > 30m
	            ax.dtick = roundDTick(roughDTick, 3600000, roundBase24);
	        }
	        else if(roughDTick > 30000) {
	            // minutes if roughDTick > 30sec
	            ax.dtick = roundDTick(roughDTick, 60000, roundBase60);
	        }
	        else if(roughDTick > 500) {
	            // seconds if roughDTick > 0.5sec
	            ax.dtick = roundDTick(roughDTick, 1000, roundBase60);
	        }
	        else {
	            //milliseconds
	            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
	            ax.dtick = roundDTick(roughDTick, base, roundBase10);
	        }
	    }
	    else if(ax.type === 'log') {
	        ax.tick0 = 0;
	
	        //only show powers of 10
	        if(roughDTick > 0.7) ax.dtick = Math.ceil(roughDTick);
	        else if(Math.abs(ax.range[1] - ax.range[0]) < 1) {
	            // span is less than one power of 10
	            var nt = 1.5 * Math.abs((ax.range[1] - ax.range[0]) / roughDTick);
	
	            // ticks on a linear scale, labeled fully
	            roughDTick = Math.abs(Math.pow(10, ax.range[1]) -
	                Math.pow(10, ax.range[0])) / nt;
	            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
	            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);
	        }
	        else {
	            // include intermediates between powers of 10,
	            // labeled with small digits
	            // ax.dtick = "D2" (show 2 and 5) or "D1" (show all digits)
	            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';
	        }
	    }
	    else if(ax.type==='category') {
	        ax.tick0 = 0;
	        ax.dtick = Math.ceil(Math.max(roughDTick, 1));
	    }
	    else {
	        // auto ticks always start at 0
	        ax.tick0 = 0;
	        base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
	        ax.dtick = roundDTick(roughDTick, base, roundBase10);
	    }
	
	    // prevent infinite loops
	    if(ax.dtick === 0) ax.dtick = 1;
	
	    // TODO: this is from log axis histograms with autorange off
	    if(!isNumeric(ax.dtick) && typeof ax.dtick !=='string') {
	        var olddtick = ax.dtick;
	        ax.dtick = 1;
	        throw 'ax.dtick error: ' + String(olddtick);
	    }
	};
	
	// after dtick is already known, find tickround = precision
	// to display in tick labels
	//   for numeric ticks, integer # digits after . to round to
	//   for date ticks, the last date part to show (y,m,d,H,M,S)
	//      or an integer # digits past seconds
	function autoTickRound(ax) {
	    var dtick = ax.dtick,
	        maxend;
	
	    ax._tickexponent = 0;
	    if(!isNumeric(dtick) && typeof dtick !== 'string') dtick = 1;
	
	    if(ax.type === 'category') ax._tickround = null;
	    else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {
	        if(ax.type === 'date') {
	            if(dtick >= 86400000) ax._tickround = 'd';
	            else if(dtick >= 3600000) ax._tickround = 'H';
	            else if(dtick >= 60000) ax._tickround = 'M';
	            else if(dtick >= 1000) ax._tickround = 'S';
	            else ax._tickround = 3 - Math.round(Math.log(dtick / 2) / Math.LN10);
	        }
	        else {
	            if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));
	            // 2 digits past largest digit of dtick
	            ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);
	
	            if(ax.type === 'log') {
	                maxend = Math.pow(10, Math.max(ax.range[0], ax.range[1]));
	            }
	            else maxend = Math.max(Math.abs(ax.range[0]), Math.abs(ax.range[1]));
	
	            var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);
	            if(Math.abs(rangeexp) > 3) {
	                if(ax.exponentformat === 'SI' || ax.exponentformat === 'B') {
	                    ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);
	                }
	                else ax._tickexponent = rangeexp;
	            }
	        }
	    }
	    else if(dtick.charAt(0) === 'M') ax._tickround = (dtick.length===2) ? 'm' : 'y';
	    else ax._tickround = null;
	}
	
	// months and years don't have constant millisecond values
	// (but a year is always 12 months so we only need months)
	// log-scale ticks are also not consistently spaced, except
	// for pure powers of 10
	// numeric ticks always have constant differences, other datetime ticks
	// can all be calculated as constant number of milliseconds
	axes.tickIncrement = function(x, dtick, axrev) {
	    var axSign = axrev ? -1 : 1;
	
	    // includes all dates smaller than month, and pure 10^n in log
	    if(isNumeric(dtick)) return x + axSign * dtick;
	
	    var tType = dtick.charAt(0),
	        dtSigned = axSign * Number(dtick.substr(1));
	
	    // Dates: months (or years)
	    if(tType === 'M') {
	        var y = new Date(x);
	        // is this browser consistent? setMonth edits a date but
	        // returns that date's milliseconds
	        return y.setMonth(y.getMonth() + dtSigned);
	    }
	
	    // Log scales: Linear, Digits
	    else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;
	
	    // log10 of 2,5,10, or all digits (logs just have to be
	    // close enough to round)
	    else if(tType === 'D') {
	        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,
	            x2 = x + axSign * 0.01,
	            frac = Lib.roundUp(mod(x2, 1), tickset, axrev);
	
	        return Math.floor(x2) +
	            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
	    }
	    else throw 'unrecognized dtick ' + String(dtick);
	};
	
	// calculate the first tick on an axis
	axes.tickFirst = function(ax) {
	    var axrev = ax.range[1] < ax.range[0],
	        sRound = axrev ? Math.floor : Math.ceil,
	        // add a tiny extra bit to make sure we get ticks
	        // that may have been rounded out
	        r0 = ax.range[0] * 1.0001 - ax.range[1] * 0.0001,
	        dtick = ax.dtick,
	        tick0 = ax.tick0;
	    if(isNumeric(dtick)) {
	        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;
	
	        // make sure no ticks outside the category list
	        if(ax.type === 'category') {
	            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
	        }
	        return tmin;
	    }
	
	    var tType = dtick.charAt(0),
	        dtNum = Number(dtick.substr(1)),
	        t0,
	        mdif,
	        t1;
	
	    // Dates: months (or years)
	    if(tType === 'M') {
	        t0 = new Date(tick0);
	        r0 = new Date(r0);
	        mdif = (r0.getFullYear() - t0.getFullYear()) * 12 +
	            r0.getMonth() - t0.getMonth();
	        t1 = t0.setMonth(t0.getMonth() +
	            (Math.round(mdif / dtNum) + (axrev ? 1 : -1)) * dtNum);
	
	        while(axrev ? t1 > r0 : t1 < r0) {
	            t1 = axes.tickIncrement(t1, dtick, axrev);
	        }
	        return t1;
	    }
	
	    // Log scales: Linear, Digits
	    else if(tType === 'L') {
	        return Math.log(sRound(
	            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;
	    }
	    else if(tType === 'D') {
	        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,
	            frac = Lib.roundUp(mod(r0, 1), tickset, axrev);
	
	        return Math.floor(r0) +
	            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
	    }
	    else throw 'unrecognized dtick ' + String(dtick);
	};
	
	var yearFormat = d3.time.format('%Y'),
	    monthFormat = d3.time.format('%b %Y'),
	    dayFormat = d3.time.format('%b %-d'),
	    hourFormat = d3.time.format('%b %-d %Hh'),
	    minuteFormat = d3.time.format('%H:%M'),
	    secondFormat = d3.time.format(':%S');
	
	// add one item to d3's vocabulary:
	// %{n}f where n is the max number of digits
	// of fractional seconds
	var fracMatch = /%(\d?)f/g;
	function modDateFormat(fmt,x) {
	    var fm = fmt.match(fracMatch),
	        d = new Date(x);
	    if(fm) {
	        var digits = Math.min(+fm[1]||6,6),
	            fracSecs = String((x/1000 % 1) + 2.0000005)
	                .substr(2,digits).replace(/0+$/,'')||'0';
	        return d3.time.format(fmt.replace(fracMatch,fracSecs))(d);
	    }
	    else {
	        return d3.time.format(fmt)(d);
	    }
	}
	
	// draw the text for one tick.
	// px,py are the location on gd.paper
	// prefix is there so the x axis ticks can be dropped a line
	// ax is the axis layout, x is the tick value
	// hover is a (truthy) flag for whether to show numbers with a bit
	// more precision for hovertext
	axes.tickText = function(ax, x, hover) {
	    var out = tickTextObj(ax, x),
	        hideexp,
	        arrayMode = ax.tickmode === 'array',
	        extraPrecision = hover || arrayMode,
	        i;
	
	    if(arrayMode && Array.isArray(ax.ticktext)) {
	        var minDiff = Math.abs(ax.range[1] - ax.range[0]) / 10000;
	        for(i = 0; i < ax.ticktext.length; i++) {
	            if(Math.abs(x - ax.d2l(ax.tickvals[i])) < minDiff) break;
	        }
	        if(i < ax.ticktext.length) {
	            out.text = String(ax.ticktext[i]);
	            return out;
	        }
	    }
	
	    function isHidden(showAttr) {
	        var first_or_last;
	
	        if(showAttr === undefined) return true;
	        if(hover) return showAttr==='none';
	
	        first_or_last = {
	            first: ax._tmin,
	            last: ax._tmax
	        }[showAttr];
	
	        return showAttr!=='all' && x!==first_or_last;
	    }
	
	    hideexp = ax.exponentformat!=='none' && isHidden(ax.showexponent) ? 'hide' : '';
	
	    if(ax.type==='date') formatDate(ax, out, hover, extraPrecision);
	    else if(ax.type==='log') formatLog(ax, out, hover, extraPrecision, hideexp);
	    else if(ax.type==='category') formatCategory(ax, out);
	    else formatLinear(ax, out, hover, extraPrecision, hideexp);
	
	    // add prefix and suffix
	    if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
	    if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;
	
	    return out;
	};
	
	function tickTextObj(ax, x, text) {
	    var tf = ax.tickfont || ax._gd._fullLayout.font;
	
	    return {
	        x: x,
	        dx: 0,
	        dy: 0,
	        text: text || '',
	        fontSize: tf.size,
	        font: tf.family,
	        fontColor: tf.color
	    };
	}
	
	function formatDate(ax, out, hover, extraPrecision) {
	    var x = out.x,
	        tr = ax._tickround,
	        d = new Date(x),
	        // suffix completes the full date info, to be included
	        // with only the first tick
	        suffix = '',
	        tt;
	    if(hover && ax.hoverformat) {
	        tt = modDateFormat(ax.hoverformat,x);
	    }
	    else if(ax.tickformat) {
	        tt = modDateFormat(ax.tickformat,x);
	        // TODO: potentially hunt for ways to automatically add more
	        // precision to the hover text?
	    }
	    else {
	        if(extraPrecision) {
	            if(isNumeric(tr)) tr+=2;
	            else tr = {y: 'm', m: 'd', d: 'H', H: 'M', M: 'S', S: 2}[tr];
	        }
	        if(tr==='y') tt = yearFormat(d);
	        else if(tr==='m') tt = monthFormat(d);
	        else {
	            if(x===ax._tmin && !hover) {
	                suffix = '<br>'+yearFormat(d);
	            }
	
	            if(tr==='d') tt = dayFormat(d);
	            else if(tr==='H') tt = hourFormat(d);
	            else {
	                if(x===ax._tmin && !hover) {
	                    suffix = '<br>'+dayFormat(d)+', '+yearFormat(d);
	                }
	
	                tt = minuteFormat(d);
	                if(tr!=='M') {
	                    tt += secondFormat(d);
	                    if(tr!=='S') {
	                        tt += numFormat(mod(x/1000,1),ax,'none',hover)
	                            .substr(1);
	                    }
	                }
	            }
	        }
	    }
	    out.text = tt + suffix;
	}
	
	function formatLog(ax, out, hover, extraPrecision, hideexp) {
	    var dtick = ax.dtick,
	        x = out.x;
	    if(extraPrecision && ((typeof dtick !== 'string') || dtick.charAt(0)!=='L')) dtick = 'L3';
	
	    if(ax.tickformat || (typeof dtick === 'string' && dtick.charAt(0) === 'L')) {
	        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);
	    }
	    else if(isNumeric(dtick)||((dtick.charAt(0)==='D')&&(mod(x+0.01,1)<0.1))) {
	        if(['e','E','power'].indexOf(ax.exponentformat)!==-1) {
	            var p = Math.round(x);
	            if(p === 0) out.text = 1;
	            else if(p === 1) out.text = '10';
	            else if(p > 1) out.text = '10<sup>' + p + '</sup>';
	            else out.text = '10<sup>\u2212' + -p + '</sup>';
	
	            out.fontSize *= 1.25;
	        }
	        else {
	            out.text = numFormat(Math.pow(10,x), ax,'','fakehover');
	            if(dtick==='D1' && ax._id.charAt(0)==='y') {
	                out.dy -= out.fontSize/6;
	            }
	        }
	    }
	    else if(dtick.charAt(0) === 'D') {
	        out.text = String(Math.round(Math.pow(10, mod(x, 1))));
	        out.fontSize *= 0.75;
	    }
	    else throw 'unrecognized dtick ' + String(dtick);
	
	    // if 9's are printed on log scale, move the 10's away a bit
	    if(ax.dtick==='D1') {
	        var firstChar = String(out.text).charAt(0);
	        if(firstChar === '0' || firstChar === '1') {
	            if(ax._id.charAt(0) === 'y') {
	                out.dx -= out.fontSize / 4;
	            }
	            else {
	                out.dy += out.fontSize / 2;
	                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *
	                    out.fontSize * (x < 0 ? 0.5 : 0.25);
	            }
	        }
	    }
	}
	
	function formatCategory(ax, out) {
	    var tt = ax._categories[Math.round(out.x)];
	    if(tt === undefined) tt = '';
	    out.text = String(tt);
	}
	
	function formatLinear(ax, out, hover, extraPrecision, hideexp) {
	    // don't add an exponent to zero if we're showing all exponents
	    // so the only reason you'd show an exponent on zero is if it's the
	    // ONLY tick to get an exponent (first or last)
	    if(ax.showexponent==='all' && Math.abs(out.x/ax.dtick)<1e-6) {
	        hideexp = 'hide';
	    }
	    out.text = numFormat(out.x, ax, hideexp, extraPrecision);
	}
	
	// format a number (tick value) according to the axis settings
	// new, more reliable procedure than d3.round or similar:
	// add half the rounding increment, then stringify and truncate
	// also automatically switch to sci. notation
	var SIPREFIXES = ['f', 'p', 'n', '&mu;', 'm', '', 'k', 'M', 'G', 'T'];
	function numFormat(v, ax, fmtoverride, hover) {
	        // negative?
	    var isNeg = v < 0,
	        // max number of digits past decimal point to show
	        tickRound = ax._tickround,
	        exponentFormat = fmtoverride || ax.exponentformat || 'B',
	        exponent = ax._tickexponent,
	        tickformat = ax.tickformat;
	
	    // special case for hover: set exponent just for this value, and
	    // add a couple more digits of precision over tick labels
	    if(hover) {
	        // make a dummy axis obj to get the auto rounding and exponent
	        var ah = {
	            exponentformat: ax.exponentformat,
	            dtick: ax.showexponent==='none' ? ax.dtick :
	                (isNumeric(v) ? Math.abs(v) || 1 : 1),
	            // if not showing any exponents, don't change the exponent
	            // from what we calculate
	            range: ax.showexponent === 'none' ? ax.range : [0, v || 1]
	        };
	        autoTickRound(ah);
	        tickRound = (Number(ah._tickround) || 0) + 4;
	        exponent = ah._tickexponent;
	        if(ax.hoverformat) tickformat = ax.hoverformat;
	    }
	
	    if(tickformat) return d3.format(tickformat)(v).replace(/-/g,'\u2212');
	
	    // 'epsilon' - rounding increment
	    var e = Math.pow(10, -tickRound) / 2;
	
	    // exponentFormat codes:
	    // 'e' (1.2e+6, default)
	    // 'E' (1.2E+6)
	    // 'SI' (1.2M)
	    // 'B' (same as SI except 10^9=B not G)
	    // 'none' (1200000)
	    // 'power' (1.2x10^6)
	    // 'hide' (1.2, use 3rd argument=='hide' to eg
	    //      only show exponent on last tick)
	    if(exponentFormat === 'none') exponent = 0;
	
	    // take the sign out, put it back manually at the end
	    // - makes cases easier
	    v = Math.abs(v);
	    if(v < e) {
	        // 0 is just 0, but may get exponent if it's the last tick
	        v = '0';
	        isNeg = false;
	    }
	    else {
	        v += e;
	        // take out a common exponent, if any
	        if(exponent) {
	            v *= Math.pow(10, -exponent);
	            tickRound += exponent;
	        }
	        // round the mantissa
	        if(tickRound === 0) v = String(Math.floor(v));
	        else if(tickRound < 0) {
	            v = String(Math.round(v));
	            v = v.substr(0, v.length + tickRound);
	            for(var i = tickRound; i < 0; i++) v += '0';
	        }
	        else {
	            v = String(v);
	            var dp = v.indexOf('.') + 1;
	            if(dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, '');
	        }
	        // insert appropriate decimal point and thousands separator
	        v = numSeparate(v, ax._gd._fullLayout.separators);
	    }
	
	    // add exponent
	    if(exponent && exponentFormat !== 'hide') {
	        var signedExponent;
	        if(exponent < 0) signedExponent = '\u2212' + -exponent;
	        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;
	        else signedExponent = String(exponent);
	
	        if(exponentFormat === 'e' ||
	                ((exponentFormat === 'SI' || exponentFormat === 'B') &&
	                 (exponent > 12 || exponent < -15))) {
	            v += 'e' + signedExponent;
	        }
	        else if(exponentFormat === 'E') {
	            v += 'E' + signedExponent;
	        }
	        else if(exponentFormat === 'power') {
	            v += '&times;10<sup>' + signedExponent + '</sup>';
	        }
	        else if(exponentFormat === 'B' && exponent === 9) {
	            v += 'B';
	        }
	        else if(exponentFormat === 'SI' || exponentFormat === 'B') {
	            v += SIPREFIXES[exponent / 3 + 5];
	        }
	    }
	
	    // put sign back in and return
	    // replace standard minus character (which is technically a hyphen)
	    // with a true minus sign
	    if(isNeg) return '\u2212' + v;
	    return v;
	}
	
	// add arbitrary decimal point and thousands separator
	var findThousands = /(\d+)(\d{3})/;
	function numSeparate(nStr, separators) {
	    // separators - first char is decimal point,
	    // next char is thousands separator if there is one
	
	    var dp = separators.charAt(0),
	        thou = separators.charAt(1),
	        x = nStr.split('.'),
	        x1 = x[0],
	        x2 = x.length > 1 ? dp + x[1] : '';
	    // even if there is a thousands separator, don't use it on
	    // 4-digit integers (like years)
	    if(thou && (x.length > 1 || x1.length>4)) {
	        while(findThousands.test(x1)) {
	            x1 = x1.replace(findThousands, '$1' + thou + '$2');
	        }
	    }
	    return x1 + x2;
	}
	
	
	axes.subplotMatch = /^x([0-9]*)y([0-9]*)$/;
	
	// getSubplots - extract all combinations of axes we need to make plots for
	// as an array of items like 'xy', 'x2y', 'x2y2'...
	// sorted by x (x,x2,x3...) then y
	// optionally restrict to only subplots containing axis object ax
	// looks both for combinations of x and y found in the data
	// and at axes and their anchors
	axes.getSubplots = function(gd, ax) {
	    var subplots = [];
	    var i, j, sp;
	
	    // look for subplots in the data
	    var data = gd.data || [];
	
	    for(i = 0; i < data.length; i++) {
	        var trace = data[i];
	
	        if(trace.visible === false || trace.visible === 'legendonly' ||
	            !(Plotly.Plots.traceIs(trace, 'cartesian') ||
	                Plotly.Plots.traceIs(trace, 'gl2d'))
	        ) continue;
	
	        var xId = trace.xaxis || 'x',
	            yId = trace.yaxis || 'y';
	        sp = xId + yId;
	
	        if(subplots.indexOf(sp) === -1) subplots.push(sp);
	    }
	
	    // look for subplots in the axes/anchors, so that we at least draw all axes
	    var axesList = axes.list(gd, '', true);
	
	    function hasAx2(sp, ax2) {
	        return sp.indexOf(ax2._id) !== -1;
	    }
	
	    for(i = 0; i < axesList.length; i++) {
	        var ax2 = axesList[i],
	            ax2Letter = ax2._id.charAt(0),
	            ax3Id = (ax2.anchor === 'free') ?
	                ((ax2Letter === 'x') ? 'y' : 'x') :
	                ax2.anchor,
	            ax3 = axes.getFromId(gd, ax3Id);
	
	        // look if ax2 is already represented in the data
	        var foundAx2 = false;
	        for(j = 0; j < subplots.length; j++) {
	            if(hasAx2(subplots[j], ax2)) {
	                foundAx2 = true;
	                break;
	            }
	        }
	
	        // ignore free axes that already represented in the data
	        if(ax2.anchor === 'free' && foundAx2) continue;
	
	        // ignore anchor-less axes
	        if(!ax3) continue;
	
	        sp = (ax2Letter === 'x') ?
	            ax2._id + ax3._id :
	            ax3._id + ax2._id;
	
	        if(subplots.indexOf(sp) === -1) subplots.push(sp);
	    }
	
	    // filter invalid subplots
	    var spMatch = axes.subplotMatch,
	        allSubplots = [];
	
	    for(i = 0; i < subplots.length; i++) {
	        sp = subplots[i];
	        if(spMatch.test(sp)) allSubplots.push(sp);
	    }
	
	    // sort the subplot ids
	    allSubplots.sort(function(a, b) {
	        var aMatch = a.match(spMatch),
	            bMatch = b.match(spMatch);
	
	        if(aMatch[1] === bMatch[1]) {
	            return +(aMatch[2]||1) - (bMatch[2]||1);
	        }
	
	        return +(aMatch[1]||0) - (bMatch[1]||0);
	    });
	
	    if(ax) return axes.findSubplotsWithAxis(allSubplots, ax);
	    return allSubplots;
	};
	
	// find all subplots with axis 'ax'
	axes.findSubplotsWithAxis = function(subplots, ax) {
	    var axMatch = new RegExp(
	        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')
	    );
	    var subplotsWithAxis = [];
	
	    for(var i = 0; i < subplots.length; i++) {
	        var sp = subplots[i];
	        if(axMatch.test(sp)) subplotsWithAxis.push(sp);
	    }
	
	    return subplotsWithAxis;
	};
	
	// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings
	axes.makeClipPaths = function(gd) {
	    var layout = gd._fullLayout,
	        defs = layout._defs,
	        fullWidth = {_offset: 0, _length: layout.width, _id: ''},
	        fullHeight = {_offset: 0, _length: layout.height, _id: ''},
	        xaList = axes.list(gd, 'x', true),
	        yaList = axes.list(gd, 'y', true),
	        clipList = [],
	        i,
	        j;
	
	    for(i = 0; i < xaList.length; i++) {
	        clipList.push({x: xaList[i], y: fullHeight});
	        for(j = 0; j < yaList.length; j++) {
	            if(i===0) clipList.push({x: fullWidth, y: yaList[j]});
	            clipList.push({x: xaList[i], y: yaList[j]});
	        }
	    }
	
	    var defGroup = defs.selectAll('g.clips')
	        .data([0]);
	    defGroup.enter().append('g')
	        .classed('clips', true);
	
	    // selectors don't work right with camelCase tags,
	    // have to use class instead
	    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I
	    var axClips = defGroup.selectAll('.axesclip')
	        .data(clipList, function(d) { return d.x._id + d.y._id; });
	    axClips.enter().append('clipPath')
	        .classed('axesclip', true)
	        .attr('id', function(d) { return 'clip' + layout._uid + d.x._id + d.y._id; })
	      .append('rect');
	    axClips.exit().remove();
	    axClips.each(function(d) {
	        d3.select(this).select('rect').attr({
	            x: d.x._offset || 0,
	            y: d.y._offset || 0,
	            width: d.x._length || 1,
	            height: d.y._length || 1
	        });
	    });
	};
	
	
	// doTicks: draw ticks, grids, and tick labels
	// axid: 'x', 'y', 'x2' etc,
	//     blank to do all,
	//     'redraw' to force full redraw, and reset ax._r
	//          (stored range for use by zoom/pan)
	//     or can pass in an axis object directly
	axes.doTicks = function(gd, axid, skipTitle) {
	    var fullLayout = gd._fullLayout,
	        ax,
	        independent = false;
	
	    // allow passing an independent axis object instead of id
	    if(typeof axid === 'object') {
	        ax = axid;
	        axid = ax._id;
	        independent = true;
	    }
	    else {
	        ax = axes.getFromId(gd, axid);
	
	        if(axid === 'redraw') {
	            fullLayout._paper.selectAll('g.subplot').each(function(subplot) {
	                var plotinfo = fullLayout._plots[subplot],
	                    xa = plotinfo.x(),
	                    ya = plotinfo.y();
	
	                plotinfo.xaxislayer
	                    .selectAll('.' + xa._id + 'tick').remove();
	                plotinfo.yaxislayer
	                    .selectAll('.' + ya._id + 'tick').remove();
	                plotinfo.gridlayer
	                    .selectAll('path').remove();
	                plotinfo.zerolinelayer
	                    .selectAll('path').remove();
	            });
	        }
	
	        if(!axid || axid === 'redraw') {
	            return Lib.syncOrAsync(axes.list(gd, '', true).map(function(ax) {
	                return function() {
	                    if(!ax._id) return;
	                    var axDone = axes.doTicks(gd, ax._id);
	                    if(axid === 'redraw') ax._r = ax.range.slice();
	                    return axDone;
	                };
	            }));
	        }
	    }
	
	    // make sure we only have allowed options for exponents
	    // (others can make confusing errors)
	    if(!ax.tickformat) {
	        if(['none', 'e', 'E', 'power', 'SI', 'B'].indexOf(ax.exponentformat) === -1) {
	            ax.exponentformat = 'e';
	        }
	        if(['all', 'first', 'last', 'none'].indexOf(ax.showexponent) === -1) {
	            ax.showexponent = 'all';
	        }
	    }
	
	    // in case a val turns into string somehow
	    ax.range = [+ax.range[0], +ax.range[1]];
	
	    // set scaling to pixels
	    ax.setScale();
	
	    var axletter = axid.charAt(0),
	        counterLetter = axes.counterLetter(axid),
	        vals = axes.calcTicks(ax),
	        datafn = function(d) { return d.text + d.x + ax.mirror; },
	        tcls = axid + 'tick',
	        gcls = axid + 'grid',
	        zcls = axid + 'zl',
	        pad = (ax.linewidth || 1) / 2,
	        labelStandoff =
	            (ax.ticks === 'outside' ? ax.ticklen : 1) + (ax.linewidth || 0),
	        labelShift = 0,
	        gridWidth = Drawing.crispRound(gd, ax.gridwidth, 1),
	        zeroLineWidth = Drawing.crispRound(gd, ax.zerolinewidth, gridWidth),
	        tickWidth = Drawing.crispRound(gd, ax.tickwidth, 1),
	        sides, transfn, tickpathfn,
	        i;
	
	    if(ax._counterangle && ax.ticks === 'outside') {
	        var caRad = ax._counterangle * Math.PI / 180;
	        labelStandoff = ax.ticklen * Math.cos(caRad) + (ax.linewidth || 0);
	        labelShift = ax.ticklen * Math.sin(caRad);
	    }
	
	    // positioning arguments for x vs y axes
	    if(axletter === 'x') {
	        sides = ['bottom', 'top'];
	        transfn = function(d) {
	            return 'translate(' + ax.l2p(d.x) + ',0)';
	        };
	        tickpathfn = function(shift, len) {
	            if(ax._counterangle) {
	                var caRad = ax._counterangle * Math.PI / 180;
	                return 'M0,' + shift + 'l' + (Math.sin(caRad) * len) + ',' + (Math.cos(caRad) * len);
	            }
	            else return 'M0,' + shift + 'v' + len;
	        };
	    }
	    else if(axletter === 'y') {
	        sides = ['left', 'right'];
	        transfn = function(d) {
	            return 'translate(0,' + ax.l2p(d.x) + ')';
	        };
	        tickpathfn = function(shift, len) {
	            if(ax._counterangle) {
	                var caRad = ax._counterangle * Math.PI / 180;
	                return 'M' + shift + ',0l' + (Math.cos(caRad) * len) + ',' + (-Math.sin(caRad) * len);
	            }
	            else return 'M' + shift + ',0h' + len;
	        };
	    }
	    else {
	        console.log('unrecognized doTicks axis', axid);
	        return;
	    }
	    var axside = ax.side || sides[0],
	    // which direction do the side[0], side[1], and free ticks go?
	    // then we flip if outside XOR y axis
	        ticksign = [-1, 1, axside === sides[1] ? 1 : -1];
	    if((ax.ticks !== 'inside') === (axletter === 'x')) {
	        ticksign = ticksign.map(function(v) { return -v; });
	    }
	
	    // remove zero lines, grid lines, and inside ticks if they're within
	    // 1 pixel of the end
	    // The key case here is removing zero lines when the axis bound is zero.
	    function clipEnds(d) {
	        var p = ax.l2p(d.x);
	        return (p > 1 && p < ax._length - 1);
	    }
	    var valsClipped = vals.filter(clipEnds);
	
	    function drawTicks(container, tickpath) {
	        var ticks = container.selectAll('path.' + tcls)
	            .data(ax.ticks==='inside' ? valsClipped : vals, datafn);
	        if(tickpath && ax.ticks) {
	            ticks.enter().append('path').classed(tcls, 1).classed('ticks', 1)
	                .classed('crisp', 1)
	                .call(Color.stroke, ax.tickcolor)
	                .style('stroke-width', tickWidth + 'px')
	                .attr('d',tickpath);
	            ticks.attr('transform', transfn);
	            ticks.exit().remove();
	        }
	        else ticks.remove();
	    }
	
	    function drawLabels(container, position) {
	        // tick labels - for now just the main labels.
	        // TODO: mirror labels, esp for subplots
	        var tickLabels = container.selectAll('g.' + tcls).data(vals, datafn);
	        if(!ax.showticklabels || !isNumeric(position)) {
	            tickLabels.remove();
	            drawAxTitle(axid);
	            return;
	        }
	
	        var labelx, labely, labelanchor, labelpos0, flipit;
	        if(axletter === 'x') {
	            flipit = (axside === 'bottom') ? 1 : -1;
	            labelx = function(d) { return d.dx + labelShift * flipit; };
	            labelpos0 = position + (labelStandoff + pad) * flipit;
	            labely = function(d) {
	                return d.dy + labelpos0 + d.fontSize *
	                    ((axside === 'bottom') ? 1 : -0.5);
	            };
	            labelanchor = function(angle) {
	                if(!isNumeric(angle) || angle === 0 || angle === 180) {
	                    return 'middle';
	                }
	                return (angle * flipit < 0) ? 'end' : 'start';
	            };
	        }
	        else {
	            flipit = (axside === 'right') ? 1 : -1;
	            labely = function(d) { return d.dy + d.fontSize / 2 - labelShift * flipit; };
	            labelx = function(d) {
	                return d.dx + position + (labelStandoff + pad +
	                    ((Math.abs(ax.tickangle) === 90) ? d.fontSize / 2 : 0)) * flipit;
	            };
	            labelanchor = function(angle) {
	                if(isNumeric(angle) && Math.abs(angle) === 90) {
	                    return 'middle';
	                }
	                return axside==='right' ? 'start' : 'end';
	            };
	        }
	        var maxFontSize = 0,
	            autoangle = 0,
	            labelsReady = [];
	        tickLabels.enter().append('g').classed(tcls, 1)
	            .append('text')
	                // only so tex has predictable alignment that we can
	                // alter later
	                .attr('text-anchor', 'middle')
	                .each(function(d) {
	                    var thisLabel = d3.select(this),
	                        newPromise = gd._promises.length;
	                    thisLabel
	                        .call(Drawing.setPosition, labelx(d), labely(d))
	                        .call(Drawing.font, d.font, d.fontSize, d.fontColor)
	                        .text(d.text)
	                        .call(svgTextUtils.convertToTspans);
	                    newPromise = gd._promises[newPromise];
	                    if(newPromise) {
	                        // if we have an async label, we'll deal with that
	                        // all here so take it out of gd._promises and
	                        // instead position the label and promise this in
	                        // labelsReady
	                        labelsReady.push(gd._promises.pop().then(function() {
	                            positionLabels(thisLabel, ax.tickangle);
	                        }));
	                    }
	                    else {
	                        // sync label: just position it now.
	                        positionLabels(thisLabel, ax.tickangle);
	                    }
	                });
	        tickLabels.exit().remove();
	
	        tickLabels.each(function(d) {
	            maxFontSize = Math.max(maxFontSize, d.fontSize);
	        });
	
	        function positionLabels(s,angle) {
	            s.each(function(d) {
	                var anchor = labelanchor(angle);
	                var thisLabel = d3.select(this),
	                    mathjaxGroup = thisLabel.select('.text-math-group'),
	                    transform = transfn(d) +
	                        ((isNumeric(angle) && +angle !== 0) ?
	                        (' rotate(' + angle + ',' + labelx(d) + ',' +
	                            (labely(d) - d.fontSize / 2) + ')') :
	                        '');
	                if(mathjaxGroup.empty()) {
	                    var txt = thisLabel.select('text').attr({
	                        transform: transform,
	                        'text-anchor': anchor
	                    });
	
	                    if(!txt.empty()) {
	                        txt.selectAll('tspan.line').attr({
	                            x: txt.attr('x'),
	                            y: txt.attr('y')
	                        });
	                    }
	                }
	                else {
	                    var mjShift =
	                        Drawing.bBox(mathjaxGroup.node()).width *
	                            {end: -0.5, start: 0.5}[anchor];
	                    mathjaxGroup.attr('transform', transform +
	                        (mjShift ? 'translate(' + mjShift + ',0)' : ''));
	                }
	            });
	        }
	
	        // make sure all labels are correctly positioned at their base angle
	        // the positionLabels call above is only for newly drawn labels.
	        // do this without waiting, using the last calculated angle to
	        // minimize flicker, then do it again when we know all labels are
	        // there, putting back the prescribed angle to check for overlaps.
	        positionLabels(tickLabels,ax._lastangle || ax.tickangle);
	
	        function allLabelsReady() {
	            return labelsReady.length && Promise.all(labelsReady);
	        }
	
	        function fixLabelOverlaps() {
	            positionLabels(tickLabels, ax.tickangle);
	
	            // check for auto-angling if x labels overlap
	            // don't auto-angle at all for log axes with
	            // base and digit format
	            if(axletter==='x' && !isNumeric(ax.tickangle) &&
	                    (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {
	                var lbbArray = [];
	                tickLabels.each(function(d) {
	                    var s = d3.select(this),
	                        thisLabel = s.select('.text-math-group'),
	                        x = ax.l2p(d.x);
	                    if(thisLabel.empty()) thisLabel = s.select('text');
	
	                    var bb = Drawing.bBox(thisLabel.node());
	
	                    lbbArray.push({
	                        // ignore about y, just deal with x overlaps
	                        top: 0,
	                        bottom: 10,
	                        height: 10,
	                        left: x - bb.width / 2,
	                        // impose a 2px gap
	                        right: x + bb.width / 2 + 2,
	                        width: bb.width + 2
	                    });
	                });
	                for(i = 0; i < lbbArray.length - 1; i++) {
	                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1])) {
	                        // any overlap at all - set 30 degrees
	                        autoangle = 30;
	                        break;
	                    }
	                }
	                if(autoangle) {
	                    var tickspacing = Math.abs(
	                            (vals[vals.length - 1].x - vals[0].x) * ax._m
	                        ) / (vals.length - 1);
	                    if(tickspacing < maxFontSize * 2.5) {
	                        autoangle = 90;
	                    }
	                    positionLabels(tickLabels, autoangle);
	                }
	                ax._lastangle = autoangle;
	            }
	
	            // update the axis title
	            // (so it can move out of the way if needed)
	            // TODO: separate out scoot so we don't need to do
	            // a full redraw of the title (mostly relevant for MathJax)
	            drawAxTitle(axid);
	            return axid + ' done';
	        }
	
	        function calcBoundingBox() {
	            ax._boundingBox = container.node().getBoundingClientRect();
	        }
	
	        var done = Lib.syncOrAsync([
	            allLabelsReady,
	            fixLabelOverlaps,
	            calcBoundingBox
	        ]);
	        if(done && done.then) gd._promises.push(done);
	        return done;
	    }
	
	    function drawAxTitle(axid) {
	        if(skipTitle) return;
	
	        // now this only applies to regular cartesian axes; colorbars and
	        // others ALWAYS call doTicks with skipTitle=true so they can
	        // configure their own titles.
	        var ax = axisIds.getFromId(gd, axid),
	            avoidSelection = d3.select(gd).selectAll('g.' + axid + 'tick'),
	            avoid = {
	                selection: avoidSelection,
	                side: ax.side
	            },
	            axLetter = axid.charAt(0),
	            gs = gd._fullLayout._size,
	            offsetBase = 1.5,
	            fontSize = ax.titlefont.size,
	            transform,
	            counterAxis,
	            x,
	            y;
	        if(avoidSelection.size()) {
	            var avoidTransform = d3.select(avoidSelection.node().parentNode)
	                .attr('transform')
	                .match(/translate\(([-\.\d]+),([-\.\d]+)\)/);
	            if(avoidTransform) {
	                avoid.offsetLeft = +avoidTransform[1];
	                avoid.offsetTop = +avoidTransform[2];
	            }
	        }
	
	        if(axLetter === 'x') {
	            counterAxis = (ax.anchor === 'free') ?
	                {_offset: gs.t + (1 - (ax.position || 0)) * gs.h, _length: 0} :
	                axisIds.getFromId(gd, ax.anchor);
	
	            x = ax._offset + ax._length / 2;
	            y = counterAxis._offset + ((ax.side === 'top') ?
	                -10 - fontSize * (offsetBase + (ax.showticklabels ? 1 : 0)) :
	                counterAxis._length + 10 +
	                    fontSize * (offsetBase + (ax.showticklabels ? 1.5 : 0.5)));
	
	            if(ax.rangeslider && ax.rangeslider.visible && ax._boundingBox) {
	                y += (fullLayout.height - fullLayout.margin.b - fullLayout.margin.t) *
	                    ax.rangeslider.thickness + ax._boundingBox.height;
	            }
	
	            if(!avoid.side) avoid.side = 'bottom';
	        }
	        else {
	            counterAxis = (ax.anchor === 'free') ?
	                {_offset: gs.l + (ax.position || 0) * gs.w, _length: 0} :
	                axisIds.getFromId(gd, ax.anchor);
	
	            y = ax._offset + ax._length / 2;
	            x = counterAxis._offset + ((ax.side === 'right') ?
	                counterAxis._length + 10 +
	                    fontSize * (offsetBase + (ax.showticklabels ? 1 : 0.5)) :
	                -10 - fontSize * (offsetBase + (ax.showticklabels ? 0.5 : 0)));
	
	            transform = {rotate: '-90', offset: 0};
	            if(!avoid.side) avoid.side = 'left';
	        }
	
	        Titles.draw(gd, axid + 'title', {
	            propContainer: ax,
	            propName: ax._name + '.title',
	            dfltName: axLetter.toUpperCase() + ' axis',
	            avoid: avoid,
	            transform: transform,
	            attributes: {x: x, y: y, 'text-anchor': 'middle'}
	        });
	    }
	
	    function traceHasBarsOrFill(trace, subplot) {
	        if(trace.visible !== true || trace.xaxis + trace.yaxis !== subplot) return false;
	        if(Plotly.Plots.traceIs(trace, 'bar') && trace.orientation === {x: 'h', y: 'v'}[axletter]) return true;
	        return trace.fill && trace.fill.charAt(trace.fill.length - 1) === axletter;
	    }
	
	    function drawGrid(plotinfo, counteraxis, subplot) {
	        var gridcontainer = plotinfo.gridlayer,
	            zlcontainer = plotinfo.zerolinelayer,
	            gridvals = plotinfo['hidegrid' + axletter] ? [] : valsClipped,
	            gridpath = ax._gridpath ||
	                'M0,0' + ((axletter==='x') ? 'v' : 'h') + counteraxis._length,
	            grid = gridcontainer.selectAll('path.' + gcls)
	                .data((ax.showgrid === false) ? [] : gridvals, datafn);
	        grid.enter().append('path').classed(gcls, 1)
	            .classed('crisp', 1)
	            .attr('d', gridpath)
	            .each(function(d) {
	                if(ax.zeroline && (ax.type === 'linear' || ax.type === '-') &&
	                        Math.abs(d.x) < ax.dtick / 100) {
	                    d3.select(this).remove();
	                }
	            });
	        grid.attr('transform', transfn)
	            .call(Color.stroke, ax.gridcolor || '#ddd')
	            .style('stroke-width', gridWidth + 'px');
	        grid.exit().remove();
	
	        // zero line
	        if(zlcontainer) {
	            var hasBarsOrFill = false;
	            for(var i = 0; i < gd._fullData.length; i++) {
	                if(traceHasBarsOrFill(gd._fullData[i], subplot)) {
	                    hasBarsOrFill = true;
	                    break;
	                }
	            }
	            var showZl = (ax.range[0] * ax.range[1] <= 0) && ax.zeroline &&
	                (ax.type === 'linear' || ax.type === '-') && gridvals.length &&
	                (hasBarsOrFill || clipEnds({x: 0}) || !ax.showline);
	            var zl = zlcontainer.selectAll('path.' + zcls)
	                .data(showZl ? [{x: 0}] : []);
	            zl.enter().append('path').classed(zcls, 1).classed('zl', 1)
	                .classed('crisp', 1)
	                .attr('d', gridpath);
	            zl.attr('transform', transfn)
	                .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)
	                .style('stroke-width', zeroLineWidth + 'px');
	            zl.exit().remove();
	        }
	    }
	
	    if(independent) {
	        drawTicks(ax._axislayer, tickpathfn(ax._pos + pad * ticksign[2], ticksign[2] * ax.ticklen));
	        if(ax._counteraxis) {
	            var fictionalPlotinfo = {
	                gridlayer: ax._gridlayer,
	                zerolinelayer: ax._zerolinelayer
	            };
	            drawGrid(fictionalPlotinfo, ax._counteraxis);
	        }
	        return drawLabels(ax._axislayer, ax._pos);
	    }
	    else {
	        var alldone = axes.getSubplots(gd, ax).map(function(subplot) {
	            var plotinfo = fullLayout._plots[subplot];
	
	            if(!fullLayout._has('cartesian')) return;
	
	            var container = plotinfo[axletter + 'axislayer'],
	
	                // [bottom or left, top or right, free, main]
	                linepositions = ax._linepositions[subplot]||[],
	                counteraxis = plotinfo[counterLetter](),
	                mainSubplot = counteraxis._id === ax.anchor,
	                ticksides = [false, false, false],
	                tickpath = '';
	
	            // ticks
	            if(ax.mirror === 'allticks') ticksides = [true, true, false];
	            else if(mainSubplot) {
	                if(ax.mirror === 'ticks') ticksides = [true, true, false];
	                else ticksides[sides.indexOf(axside)] = true;
	            }
	            if(ax.mirrors) {
	                for(i = 0; i < 2; i++) {
	                    var thisMirror = ax.mirrors[counteraxis._id + sides[i]];
	                    if(thisMirror === 'ticks' || thisMirror === 'labels') {
	                        ticksides[i] = true;
	                    }
	                }
	            }
	
	            // free axis ticks
	            if(linepositions[2] !== undefined) ticksides[2] = true;
	
	            ticksides.forEach(function(showside, sidei) {
	                var pos = linepositions[sidei],
	                    tsign = ticksign[sidei];
	                if(showside && isNumeric(pos)) {
	                    tickpath += tickpathfn(pos + pad * tsign, tsign * ax.ticklen);
	                }
	            });
	
	            drawTicks(container, tickpath);
	            drawGrid(plotinfo, counteraxis, subplot);
	            return drawLabels(container, linepositions[3]);
	        }).filter(function(onedone) { return onedone && onedone.then; });
	
	        return alldone.length ? Promise.all(alldone) : 0;
	    }
	};
	
	// swap all the presentation attributes of the axes showing these traces
	axes.swap = function(gd, traces) {
	    var axGroups = makeAxisGroups(gd, traces);
	
	    for(var i = 0; i < axGroups.length; i++) {
	        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
	    }
	};
	
	function makeAxisGroups(gd, traces) {
	    var groups = [],
	        i,
	        j;
	
	    for(i = 0; i < traces.length; i++) {
	        var groupsi = [],
	            xi = gd._fullData[traces[i]].xaxis,
	            yi = gd._fullData[traces[i]].yaxis;
	        if(!xi || !yi) continue; // not a 2D cartesian trace?
	
	        for(j = 0; j < groups.length; j++) {
	            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {
	                groupsi.push(j);
	            }
	        }
	
	        if(!groupsi.length) {
	            groups.push({x: [xi], y: [yi]});
	            continue;
	        }
	
	        var group0 = groups[groupsi[0]],
	            groupj;
	
	        if(groupsi.length>1) {
	            for(j = 1; j < groupsi.length; j++) {
	                groupj = groups[groupsi[j]];
	                mergeAxisGroups(group0.x, groupj.x);
	                mergeAxisGroups(group0.y, groupj.y);
	            }
	        }
	        mergeAxisGroups(group0.x, [xi]);
	        mergeAxisGroups(group0.y, [yi]);
	    }
	
	    return groups;
	}
	
	function mergeAxisGroups(intoSet, fromSet) {
	    for(var i = 0; i < fromSet.length; i++) {
	        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);
	    }
	}
	
	function swapAxisGroup(gd, xIds, yIds) {
	    var i,
	        j,
	        xFullAxes = [],
	        yFullAxes = [],
	        layout = gd.layout;
	
	    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));
	    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));
	
	    var allAxKeys = Object.keys(xFullAxes[0]),
	        noSwapAttrs = [
	            'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle'
	        ],
	        numericTypes = ['linear', 'log'];
	
	    for(i = 0; i < allAxKeys.length; i++) {
	        var keyi = allAxKeys[i],
	            xVal = xFullAxes[0][keyi],
	            yVal = yFullAxes[0][keyi],
	            allEqual = true,
	            coerceLinearX = false,
	            coerceLinearY = false;
	        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||
	                noSwapAttrs.indexOf(keyi) !== -1) {
	            continue;
	        }
	        for(j = 1; j < xFullAxes.length && allEqual; j++) {
	            var xVali = xFullAxes[j][keyi];
	            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&
	                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {
	                // type is special - if we find a mixture of linear and log,
	                // coerce them all to linear on flipping
	                coerceLinearX = true;
	            }
	            else if(xVali !== xVal) allEqual = false;
	        }
	        for(j = 1; j < yFullAxes.length && allEqual; j++) {
	            var yVali = yFullAxes[j][keyi];
	            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&
	                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {
	                // type is special - if we find a mixture of linear and log,
	                // coerce them all to linear on flipping
	                coerceLinearY = true;
	            }
	            else if(yFullAxes[j][keyi] !== yVal) allEqual = false;
	        }
	        if(allEqual) {
	            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';
	            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';
	            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes);
	        }
	    }
	
	    // now swap x&y for any annotations anchored to these x & y
	    for(i = 0; i < gd._fullLayout.annotations.length; i++) {
	        var ann = gd._fullLayout.annotations[i];
	        if(xIds.indexOf(ann.xref) !== -1 &&
	                yIds.indexOf(ann.yref) !== -1) {
	            Lib.swapAttrs(layout.annotations[i],['?']);
	        }
	    }
	}
	
	function swapAxisAttrs(layout, key, xFullAxes, yFullAxes) {
	    // in case the value is the default for either axis,
	    // look at the first axis in each list and see if
	    // this key's value is undefined
	    var np = Lib.nestedProperty,
	        xVal = np(layout[xFullAxes[0]._name], key).get(),
	        yVal = np(layout[yFullAxes[0]._name], key).get(),
	        i;
	    if(key === 'title') {
	        // special handling of placeholder titles
	        if(xVal === 'Click to enter X axis title') {
	            xVal = 'Click to enter Y axis title';
	        }
	        if(yVal === 'Click to enter Y axis title') {
	            yVal = 'Click to enter X axis title';
	        }
	    }
	
	    for(i = 0; i < xFullAxes.length; i++) {
	        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);
	    }
	    for(i = 0; i < yFullAxes.length; i++) {
	        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);
	    }
	}
	
	// mod - version of modulus that always restricts to [0,divisor)
	// rather than built-in % which gives a negative value for negative v
	function mod(v,d) { return ((v%d) + d) % d; }


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Plots = __webpack_require__(332);
	var Lib = __webpack_require__(309);
	var Drawing = __webpack_require__(340);
	var Color = __webpack_require__(333);
	var svgTextUtils = __webpack_require__(326);
	
	
	var Titles = module.exports = {};
	
	/**
	 * Titles - (re)draw titles on the axes and plot:
	 * @param {DOM element} gd - the graphDiv
	 * @param {string} titleClass - the css class of this title
	 * @param {object} options - how and what to draw
	 *      propContainer - the layout object containing `title` and `titlefont`
	 *          attributes that apply to this title
	 *      propName - the full name of the title property (for Plotly.relayout)
	 *      [traceIndex] - include only if this property applies to one trace
	 *          (such as a colorbar title) - then editing pipes to Plotly.restyle
	 *          instead of Plotly.relayout
	 *      dfltName - the name of the title in placeholder text
	 *      [avoid] {object} - include if this title should move to avoid other elements
	 *          selection - d3 selection of elements to avoid
	 *          side - which direction to move if there is a conflict
	 *          [offsetLeft] - if these elements are subject to a translation
	 *              wrt the title element
	 *          [offsetTop]
	 *      attributes {object} - position and alignment attributes
	 *          x - pixels
	 *          y - pixels
	 *          text-anchor - start|middle|end
	 *      transform {object} - how to transform the title after positioning
	 *          rotate - degrees
	 *          offset - shift up/down in the rotated frame (unused?)
	 *      containerGroup - if an svg <g> element already exists to hold this
	 *          title, include here. Otherwise it will go in fullLayout._infolayer
	 */
	Titles.draw = function(gd, titleClass, options) {
	    var cont = options.propContainer,
	        prop = options.propName,
	        traceIndex = options.traceIndex,
	        name = options.dfltName,
	        avoid = options.avoid || {},
	        attributes = options.attributes,
	        transform = options.transform,
	        group = options.containerGroup,
	
	        fullLayout = gd._fullLayout,
	        font = cont.titlefont.family,
	        fontSize = cont.titlefont.size,
	        fontColor = cont.titlefont.color,
	
	        opacity = 1,
	        isplaceholder = false,
	        txt = cont.title.trim();
	    if(txt === '') opacity = 0;
	    if(txt.match(/Click to enter .+ title/)) {
	        opacity = 0.2;
	        isplaceholder = true;
	    }
	
	    if(!group) {
	        group = fullLayout._infolayer.selectAll('.g-' + titleClass)
	            .data([0]);
	        group.enter().append('g')
	            .classed('g-' + titleClass, true);
	    }
	
	    var el = group.selectAll('text')
	        .data([0]);
	    el.enter().append('text');
	    el.text(txt)
	        // this is hacky, but convertToTspans uses the class
	        // to determine whether to rotate mathJax...
	        // so we need to clear out any old class and put the
	        // correct one (only relevant for colorbars, at least
	        // for now) - ie don't use .classed
	        .attr('class', titleClass);
	
	    function titleLayout(titleEl) {
	        Lib.syncOrAsync([drawTitle,scootTitle], titleEl);
	    }
	
	    function drawTitle(titleEl) {
	        titleEl.attr('transform', transform ?
	            'rotate(' + [transform.rotate, attributes.x, attributes.y] +
	                ') translate(0, ' + transform.offset + ')' :
	            null);
	
	        titleEl.style({
	            'font-family': font,
	            'font-size': d3.round(fontSize,2) + 'px',
	            fill: Color.rgb(fontColor),
	            opacity: opacity * Color.opacity(fontColor),
	            'font-weight': Plots.fontWeight
	        })
	        .attr(attributes)
	        .call(svgTextUtils.convertToTspans)
	        .attr(attributes);
	
	        titleEl.selectAll('tspan.line')
	            .attr(attributes);
	        return Plots.previousPromises(gd);
	    }
	
	    function scootTitle(titleElIn) {
	        var titleGroup = d3.select(titleElIn.node().parentNode);
	
	        if(avoid && avoid.selection && avoid.side && txt) {
	            titleGroup.attr('transform', null);
	
	            // move toward avoid.side (= left, right, top, bottom) if needed
	            // can include pad (pixels, default 2)
	            var shift = 0,
	                backside = {
	                    left: 'right',
	                    right: 'left',
	                    top: 'bottom',
	                    bottom: 'top'
	                }[avoid.side],
	                shiftSign = (['left','top'].indexOf(avoid.side) !== -1) ?
	                    -1 : 1,
	                pad = isNumeric(avoid.pad) ? avoid.pad : 2,
	                titlebb = Drawing.bBox(titleGroup.node()),
	                paperbb = {
	                    left: 0,
	                    top: 0,
	                    right: fullLayout.width,
	                    bottom: fullLayout.height
	                },
	                maxshift = avoid.maxShift || (
	                    (paperbb[avoid.side]-titlebb[avoid.side]) *
	                    ((avoid.side === 'left' || avoid.side === 'top') ? -1 : 1));
	            // Prevent the title going off the paper
	            if(maxshift < 0) shift = maxshift;
	            else {
	                // so we don't have to offset each avoided element,
	                // give the title the opposite offset
	                titlebb.left -= avoid.offsetLeft;
	                titlebb.right -= avoid.offsetLeft;
	                titlebb.top -= avoid.offsetTop;
	                titlebb.bottom -= avoid.offsetTop;
	
	                // iterate over a set of elements (avoid.selection)
	                // to avoid collisions with
	                avoid.selection.each(function() {
	                    var avoidbb = Drawing.bBox(this);
	
	                    if(Lib.bBoxIntersect(titlebb, avoidbb, pad)) {
	                        shift = Math.max(shift, shiftSign * (
	                            avoidbb[avoid.side] - titlebb[backside]) + pad);
	                    }
	                });
	                shift = Math.min(maxshift, shift);
	            }
	            if(shift > 0 || maxshift < 0) {
	                var shiftTemplate = {
	                    left: [-shift, 0],
	                    right: [shift, 0],
	                    top: [0, -shift],
	                    bottom: [0, shift]
	                }[avoid.side];
	                titleGroup.attr('transform',
	                    'translate(' + shiftTemplate + ')');
	            }
	        }
	    }
	
	    el.attr({'data-unformatted': txt})
	        .call(titleLayout);
	
	    var placeholderText = 'Click to enter ' + name + ' title';
	
	    function setPlaceholder() {
	        opacity = 0;
	        isplaceholder = true;
	        txt = placeholderText;
	        fullLayout._infolayer.select('.' + titleClass)
	            .attr({'data-unformatted': txt})
	            .text(txt)
	            .on('mouseover.opacity', function() {
	                d3.select(this).transition()
	                    .duration(100).style('opacity', 1);
	            })
	            .on('mouseout.opacity',function() {
	                d3.select(this).transition()
	                    .duration(1000).style('opacity', 0);
	            });
	    }
	
	    if(gd._context.editable) {
	        if(!txt) setPlaceholder();
	
	        el.call(svgTextUtils.makeEditable)
	            .on('edit', function(text) {
	                if(traceIndex !== undefined) Plotly.restyle(gd, prop, text, traceIndex);
	                else Plotly.relayout(gd, prop, text);
	            })
	            .on('cancel', function() {
	                this.text(this.attr('data-unformatted'))
	                    .call(titleLayout);
	            })
	            .on('input', function(d) {
	                this.text(d || ' ').attr(attributes)
	                    .selectAll('tspan.line')
	                        .attr(attributes);
	            });
	    }
	    else if(!txt || txt.match(/Click to enter .+ title/)) {
	        el.remove();
	    }
	    el.classed('js-placeholder', isplaceholder);
	};


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Plots = __webpack_require__(332);
	var Color = __webpack_require__(333);
	var Colorscale = __webpack_require__(341);
	var Lib = __webpack_require__(309);
	var svgTextUtils = __webpack_require__(326);
	
	var xmlnsNamespaces = __webpack_require__(327);
	var subTypes = __webpack_require__(360);
	var makeBubbleSizeFn = __webpack_require__(361);
	
	var drawing = module.exports = {};
	
	// -----------------------------------------------------
	// styling functions for plot elements
	// -----------------------------------------------------
	
	drawing.font = function(s, family, size, color) {
	    // also allow the form font(s, {family, size, color})
	    if(family && family.family) {
	        color = family.color;
	        size = family.size;
	        family = family.family;
	    }
	    if(family) s.style('font-family', family);
	    if(size+1) s.style('font-size', size + 'px');
	    if(color) s.call(Color.fill, color);
	};
	
	drawing.setPosition = function(s, x, y) { s.attr('x',x).attr('y',y); };
	drawing.setSize = function(s, w, h) { s.attr('width',w).attr('height',h); };
	drawing.setRect = function(s, x, y, w, h) {
	    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);
	};
	
	drawing.translatePoints = function(s, xa, ya) {
	    s.each(function(d) {
	        // put xp and yp into d if pixel scaling is already done
	        var x = d.xp || xa.c2p(d.x),
	            y = d.yp || ya.c2p(d.y),
	            p = d3.select(this);
	        if(isNumeric(x) && isNumeric(y)) {
	            // for multiline text this works better
	            if(this.nodeName==='text') p.attr('x',x).attr('y',y);
	            else p.attr('transform', 'translate('+x+','+y+')');
	        }
	        else p.remove();
	    });
	};
	
	drawing.getPx = function(s, styleAttr) {
	    // helper to pull out a px value from a style that may contain px units
	    // s is a d3 selection (will pull from the first one)
	    return Number(s.style(styleAttr).replace(/px$/,''));
	};
	
	drawing.crispRound = function(td, lineWidth, dflt) {
	    // for lines that disable antialiasing we want to
	    // make sure the width is an integer, and at least 1 if it's nonzero
	
	    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;
	
	    // but not for static plots - these don't get antialiased anyway.
	    if(td._context.staticPlot) return lineWidth;
	
	    if(lineWidth<1) return 1;
	    return Math.round(lineWidth);
	};
	
	drawing.lineGroupStyle = function(s, lw, lc, ld) {
	    s.style('fill','none')
	    .each(function(d) {
	        var line = (((d||[])[0]||{}).trace||{}).line||{},
	            lw1 = lw||line.width||0,
	            dash = ld||line.dash||'';
	
	        d3.select(this)
	            .call(Color.stroke,lc||line.color)
	            .call(drawing.dashLine, dash, lw1);
	    });
	};
	
	drawing.dashLine = function(s, dash, lineWidth) {
	    var dlw = Math.max(lineWidth, 3);
	
	    if(dash==='solid') dash = '';
	    else if(dash==='dot') dash = dlw+'px,'+dlw+'px';
	    else if(dash==='dash') dash = (3*dlw)+'px,'+(3*dlw)+'px';
	    else if(dash==='longdash') dash = (5*dlw)+'px,'+(5*dlw)+'px';
	    else if(dash==='dashdot') {
	        dash = (3*dlw)+'px,'+dlw+'px,'+dlw+'px,'+dlw+'px';
	    }
	    else if(dash==='longdashdot') {
	        dash = (5*dlw)+'px,'+(2*dlw)+'px,'+dlw+'px,'+(2*dlw)+'px';
	    }
	    // otherwise user wrote the dasharray themselves - leave it be
	
	    s.style({
	        'stroke-dasharray': dash,
	        'stroke-width': lineWidth + 'px'
	    });
	};
	
	drawing.fillGroupStyle = function(s) {
	    s.style('stroke-width',0)
	    .each(function(d) {
	        var shape = d3.select(this);
	        try {
	            shape.call(Color.fill, d[0].trace.fillcolor);
	        }
	        catch(e) {
	            console.log(e,s);
	            shape.remove();
	        }
	    });
	};
	
	var SYMBOLDEFS = __webpack_require__(362);
	
	drawing.symbolNames = [];
	drawing.symbolFuncs = [];
	drawing.symbolNeedLines = {};
	drawing.symbolNoDot = {};
	drawing.symbolList = [];
	
	Object.keys(SYMBOLDEFS).forEach(function(k) {
	    var symDef = SYMBOLDEFS[k];
	    drawing.symbolList = drawing.symbolList.concat(
	        [symDef.n, k, symDef.n+100, k+'-open']);
	    drawing.symbolNames[symDef.n] = k;
	    drawing.symbolFuncs[symDef.n] = symDef.f;
	    if(symDef.needLine) {
	        drawing.symbolNeedLines[symDef.n] = true;
	    }
	    if(symDef.noDot) {
	        drawing.symbolNoDot[symDef.n] = true;
	    }
	    else {
	        drawing.symbolList = drawing.symbolList.concat(
	            [symDef.n+200, k+'-dot', symDef.n+300, k+'-open-dot']);
	    }
	});
	var MAXSYMBOL = drawing.symbolNames.length,
	    // add a dot in the middle of the symbol
	    DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';
	
	drawing.symbolNumber = function(v) {
	    if(typeof v === 'string') {
	        var vbase = 0;
	        if(v.indexOf('-open') > 0) {
	            vbase = 100;
	            v = v.replace('-open','');
	        }
	        if(v.indexOf('-dot') > 0) {
	            vbase += 200;
	            v = v.replace('-dot','');
	        }
	        v = drawing.symbolNames.indexOf(v);
	        if(v>=0) { v += vbase; }
	    }
	    if((v%100 >= MAXSYMBOL) || v>=400) { return 0; }
	    return Math.floor(Math.max(v,0));
	};
	
	drawing.pointStyle = function(s, trace) {
	    if(!s.size()) return;
	
	    var marker = trace.marker,
	        markerLine = marker.line;
	
	    // only scatter & box plots get marker path and opacity
	    // bars, histograms don't
	    if(Plots.traceIs(trace, 'symbols')) {
	        var sizeFn = makeBubbleSizeFn(trace);
	
	        s.attr('d', function(d) {
	            var r;
	
	            // handle multi-trace graph edit case
	            if(d.ms==='various' || marker.size==='various') r = 3;
	            else r = subTypes.isBubble(trace) ?
	                        sizeFn(d.ms) : (marker.size || 6) / 2;
	
	            // store the calculated size so hover can use it
	            d.mrc = r;
	
	            // turn the symbol into a sanitized number
	            var x = drawing.symbolNumber(d.mx || marker.symbol) || 0,
	                xBase = x%100;
	
	            // save if this marker is open
	            // because that impacts how to handle colors
	            d.om = x%200 >= 100;
	
	            return drawing.symbolFuncs[xBase](r) +
	                (x >= 200 ? DOTPATH : '');
	        })
	        .style('opacity',function(d) {
	            return (d.mo+1 || marker.opacity+1) - 1;
	        });
	    }
	    // allow array marker and marker line colors to be
	    // scaled by given max and min to colorscales
	    var markerIn = (trace._input||{}).marker||{},
	        markerScale = drawing.tryColorscale(marker, markerIn, ''),
	        lineScale = drawing.tryColorscale(marker, markerIn, 'line.');
	
	    s.each(function(d) {
	        // 'so' is suspected outliers, for box plots
	        var fillColor,
	            lineColor,
	            lineWidth;
	        if(d.so) {
	            lineWidth = markerLine.outlierwidth;
	            lineColor = markerLine.outliercolor;
	            fillColor = marker.outliercolor;
	        }
	        else {
	            lineWidth = (d.mlw+1 || markerLine.width+1 ||
	                // TODO: we need the latter for legends... can we get rid of it?
	                (d.trace ? d.trace.marker.line.width : 0) + 1) -1;
	
	            if('mlc' in d) lineColor = d.mlcc = lineScale(d.mlc);
	            // weird case: array wasn't long enough to apply to every point
	            else if(Array.isArray(markerLine.color)) lineColor = Color.defaultLine;
	            else lineColor = markerLine.color;
	
	            if('mc' in d) fillColor = d.mcc = markerScale(d.mc);
	            else if(Array.isArray(marker.color)) fillColor = Color.defaultLine;
	            else fillColor = marker.color || 'rgba(0,0,0,0)';
	        }
	
	        var p = d3.select(this);
	        if(d.om) {
	            // open markers can't have zero linewidth, default to 1px,
	            // and use fill color as stroke color
	            p.call(Color.stroke, fillColor)
	                .style({
	                    'stroke-width': (lineWidth||1) + 'px',
	                    fill: 'none'
	                });
	        }
	        else {
	            p.style('stroke-width', lineWidth + 'px')
	                .call(Color.fill, fillColor);
	            if(lineWidth) {
	                p.call(Color.stroke, lineColor);
	            }
	        }
	    });
	};
	
	// for a given color attribute (ie m -> mc = marker.color) look to see if we
	// have a colorscale for it (ie mscl, mcmin, mcmax) - if we do, translate
	// all numeric color values according to that scale
	drawing.tryColorscale = function(cont, contIn, prefix) {
	    var colorArray = Lib.nestedProperty(cont, prefix + 'color').get(),
	        scl = Lib.nestedProperty(cont, prefix + 'colorscale').get(),
	        auto = Lib.nestedProperty(cont, prefix + 'cauto').get(),
	        minProp = Lib.nestedProperty(cont, prefix + 'cmin'),
	        maxProp = Lib.nestedProperty(cont, prefix + 'cmax'),
	        min = minProp.get(),
	        max = maxProp.get();
	
	    // TODO handle this in Colorscale.calc
	    if(scl && Array.isArray(colorArray)) {
	        if(auto || !isNumeric(min) || !isNumeric(max)) {
	            min = Infinity;
	            max = -Infinity;
	            colorArray.forEach(function(color) {
	                if(isNumeric(color)) {
	                    if(min > color) min = +color;
	                    if(max < color) max = +color;
	                }
	            });
	            if(min > max) {
	                min = 0;
	                max = 1;
	            }
	            minProp.set(min);
	            maxProp.set(max);
	            Lib.nestedProperty(contIn, prefix + 'cmin').set(min);
	            Lib.nestedProperty(contIn, prefix + 'cmax').set(max);
	        }
	        return Colorscale.makeScaleFunction(scl, min, max);
	    }
	    else return Lib.identity;
	};
	
	// draw text at points
	var TEXTOFFSETSIGN = {start: 1, end: -1, middle: 0, bottom: 1, top: -1},
	    LINEEXPAND = 1.3;
	drawing.textPointStyle = function(s, trace) {
	    s.each(function(d) {
	        var p = d3.select(this),
	            text = d.tx || trace.text;
	        if(!text || Array.isArray(text)) {
	            // isArray test handles the case of (intentionally) missing
	            // or empty text within a text array
	            p.remove();
	            return;
	        }
	
	        var pos = d.tp || trace.textposition,
	            v = pos.indexOf('top')!==-1 ? 'top' :
	                pos.indexOf('bottom')!==-1 ? 'bottom' : 'middle',
	            h = pos.indexOf('left')!==-1 ? 'end' :
	                pos.indexOf('right')!==-1 ? 'start' : 'middle',
	            fontSize = d.ts || trace.textfont.size,
	            // if markers are shown, offset a little more than
	            // the nominal marker size
	            // ie 2/1.6 * nominal, bcs some markers are a bit bigger
	            r = d.mrc ? (d.mrc/0.8 + 1) : 0;
	
	        fontSize = (isNumeric(fontSize) && fontSize>0) ? fontSize : 0;
	
	        p.call(drawing.font,
	                d.tf || trace.textfont.family,
	                fontSize,
	                d.tc || trace.textfont.color)
	            .attr('text-anchor',h)
	            .text(text)
	            .call(svgTextUtils.convertToTspans);
	        var pgroup = d3.select(this.parentNode),
	            tspans = p.selectAll('tspan.line'),
	            numLines = ((tspans[0].length||1)-1)*LINEEXPAND+1,
	            dx = TEXTOFFSETSIGN[h]*r,
	            dy = fontSize*0.75 + TEXTOFFSETSIGN[v]*r +
	                (TEXTOFFSETSIGN[v]-1)*numLines*fontSize/2;
	
	        // fix the overall text group position
	        pgroup.attr('transform','translate('+dx+','+dy+')');
	
	        // then fix multiline text
	        if(numLines>1) {
	            tspans.attr({ x: p.attr('x'), y: p.attr('y') });
	        }
	    });
	};
	
	// generalized Catmull-Rom splines, per
	// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	var CatmullRomExp = 0.5;
	drawing.smoothopen = function(pts,smoothness) {
	    if(pts.length<3) { return 'M' + pts.join('L');}
	    var path = 'M'+pts[0],
	        tangents = [], i;
	    for(i=1; i<pts.length-1; i++) {
	        tangents.push(makeTangent(pts[i-1], pts[i], pts[i+1], smoothness));
	    }
	    path += 'Q'+tangents[0][0]+' '+pts[1];
	    for(i=2; i<pts.length-1; i++) {
	        path += 'C'+tangents[i-2][1]+' '+tangents[i-1][0]+' '+pts[i];
	    }
	    path += 'Q'+tangents[pts.length-3][1]+' '+pts[pts.length-1];
	    return path;
	};
	
	drawing.smoothclosed = function(pts,smoothness) {
	    if(pts.length<3) { return 'M' + pts.join('L') + 'Z'; }
	    var path = 'M'+pts[0],
	        pLast = pts.length-1,
	        tangents = [makeTangent(pts[pLast],
	                        pts[0], pts[1], smoothness)],
	        i;
	    for(i=1; i<pLast; i++) {
	        tangents.push(makeTangent(pts[i-1], pts[i], pts[i+1], smoothness));
	    }
	    tangents.push(
	        makeTangent(pts[pLast-1], pts[pLast], pts[0], smoothness)
	    );
	
	    for(i=1; i<=pLast; i++) {
	        path += 'C'+tangents[i-1][1]+' '+tangents[i][0]+' '+pts[i];
	    }
	    path += 'C'+tangents[pLast][1]+' '+tangents[0][0]+' '+pts[0] + 'Z';
	    return path;
	};
	
	function makeTangent(prevpt,thispt,nextpt,smoothness) {
	    var d1x = prevpt[0]-thispt[0],
	        d1y = prevpt[1]-thispt[1],
	        d2x = nextpt[0]-thispt[0],
	        d2y = nextpt[1]-thispt[1],
	        d1a = Math.pow(d1x*d1x + d1y*d1y, CatmullRomExp/2),
	        d2a = Math.pow(d2x*d2x + d2y*d2y, CatmullRomExp/2),
	        numx = (d2a*d2a*d1x - d1a*d1a*d2x)*smoothness,
	        numy = (d2a*d2a*d1y - d1a*d1a*d2y)*smoothness,
	        denom1 = 3*d2a*(d1a+d2a),
	        denom2 = 3*d1a*(d1a+d2a);
	    return [
	        [
	            d3.round(thispt[0]+(denom1 && numx/denom1),2),
	            d3.round(thispt[1]+(denom1 && numy/denom1),2)
	        ],[
	            d3.round(thispt[0]-(denom2 && numx/denom2),2),
	            d3.round(thispt[1]-(denom2 && numy/denom2),2)
	        ]
	    ];
	}
	
	// step paths - returns a generator function for paths
	// with the given step shape
	var STEPPATH = {
	    hv: function(p0,p1) {
	        return 'H'+d3.round(p1[0],2)+'V'+d3.round(p1[1],2);
	    },
	    vh: function(p0,p1) {
	        return 'V'+d3.round(p1[1],2)+'H'+d3.round(p1[0],2);
	    },
	    hvh: function(p0,p1) {
	        return 'H'+d3.round((p0[0]+p1[0])/2,2)+'V'+
	            d3.round(p1[1],2)+'H'+d3.round(p1[0],2);
	    },
	    vhv: function(p0,p1) {
	        return 'V'+d3.round((p0[1]+p1[1])/2,2)+'H'+
	            d3.round(p1[0],2)+'V'+d3.round(p1[1],2);
	    }
	};
	var STEPLINEAR = function(p0,p1) {
	    return 'L'+d3.round(p1[0],2)+','+d3.round(p1[1],2);
	};
	drawing.steps = function(shape) {
	    var onestep = STEPPATH[shape] || STEPLINEAR;
	    return function(pts) {
	        var path = 'M'+d3.round(pts[0][0],2)+','+d3.round(pts[0][1],2);
	        for(var i=1; i<pts.length; i++) {
	            path += onestep(pts[i-1],pts[i]);
	        }
	        return path;
	    };
	};
	
	// off-screen svg render testing element, shared by the whole page
	// uses the id 'js-plotly-tester' and stores it in gd._tester
	// makes a hash of cached text items in tester.node()._cache
	// so we can add references to rendered text (including all info
	// needed to fully determine its bounding rect)
	drawing.makeTester = function(gd) {
	    var tester = d3.select('body')
	        .selectAll('#js-plotly-tester')
	        .data([0]);
	
	    tester.enter().append('svg')
	        .attr('id', 'js-plotly-tester')
	        .attr(xmlnsNamespaces.svgAttrs)
	        .style({
	            position: 'absolute',
	            left: '-10000px',
	            top: '-10000px',
	            width: '9000px',
	            height: '9000px'
	        });
	
	    // browsers differ on how they describe the bounding rect of
	    // the svg if its contents spill over... so make a 1x1px
	    // reference point we can measure off of.
	    var testref = tester.selectAll('.js-reference-point').data([0]);
	    testref.enter().append('path')
	        .classed('js-reference-point', true)
	        .attr('d','M0,0H1V1H0Z')
	        .style({
	            'stroke-width': 0,
	            fill: 'black'
	        });
	
	    if(!tester.node()._cache) {
	        tester.node()._cache = {};
	    }
	
	    gd._tester = tester;
	    gd._testref = testref;
	};
	
	// use our offscreen tester to get a clientRect for an element,
	// in a reference frame where it isn't translated and its anchor
	// point is at (0,0)
	// always returns a copy of the bbox, so the caller can modify it safely
	var savedBBoxes = [],
	    maxSavedBBoxes = 10000;
	drawing.bBox = function(node) {
	    // cache elements we've already measured so we don't have to
	    // remeasure the same thing many times
	    var saveNum = node.attributes['data-bb'];
	    if(saveNum && saveNum.value) {
	        return Lib.extendFlat({}, savedBBoxes[saveNum.value]);
	    }
	
	    var test3 = d3.select('#js-plotly-tester'),
	        tester = test3.node();
	
	    // copy the node to test into the tester
	    var testNode = node.cloneNode(true);
	    tester.appendChild(testNode);
	    // standardize its position... do we really want to do this?
	    d3.select(testNode).attr({
	        x: 0,
	        y: 0,
	        transform: ''
	    });
	
	    var testRect = testNode.getBoundingClientRect(),
	        refRect = test3.select('.js-reference-point')
	            .node().getBoundingClientRect();
	
	    tester.removeChild(testNode);
	
	    var bb = {
	        height: testRect.height,
	        width: testRect.width,
	        left: testRect.left - refRect.left,
	        top: testRect.top - refRect.top,
	        right: testRect.right - refRect.left,
	        bottom: testRect.bottom - refRect.top
	    };
	
	    // make sure we don't have too many saved boxes,
	    // or a long session could overload on memory
	    // by saving boxes for long-gone elements
	    if(savedBBoxes.length>=maxSavedBBoxes) {
	        d3.selectAll('[data-bb]').attr('data-bb', null);
	        savedBBoxes = [];
	    }
	
	    // cache this bbox
	    node.setAttribute('data-bb',savedBBoxes.length);
	    savedBBoxes.push(bb);
	
	    return Lib.extendFlat({}, bb);
	};
	
	/*
	 * make a robust clipPath url from a local id
	 * note! We'd better not be exporting from a page
	 * with a <base> or the svg will not be portable!
	 */
	drawing.setClipUrl = function(s, localId) {
	    if(!localId) {
	        s.attr('clip-path', null);
	        return;
	    }
	
	    var url = '#' + localId,
	        base = d3.select('base');
	
	    if(base.size() && base.attr('href')) url = window.location.href + url;
	    s.attr('clip-path', 'url(' + url + ')');
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	exports.scales = __webpack_require__(317);
	
	exports.defaultScale = __webpack_require__(318);
	
	exports.attributes = __webpack_require__(342);
	
	exports.handleDefaults = __webpack_require__(343);
	
	exports.calc = __webpack_require__(357);
	
	exports.hasColorscale = __webpack_require__(358);
	
	exports.isValidScale = __webpack_require__(355);
	
	exports.getScale = __webpack_require__(316);
	
	exports.flipScale = __webpack_require__(356);
	
	exports.makeScaleFunction = __webpack_require__(359);


/***/ },
/* 342 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    zauto: {
	        valType: 'boolean',
	        role: 'info',
	        dflt: true,
	        description: [
	            'Determines the whether or not the color domain is computed',
	            'with respect to the input data.'
	        ].join(' ')
	    },
	    zmin: {
	        valType: 'number',
	        role: 'info',
	        dflt: null,
	        description: 'Sets the lower bound of color domain.'
	    },
	    zmax: {
	        valType: 'number',
	        role: 'info',
	        dflt: null,
	        description: 'Sets the upper bound of color domain.'
	    },
	    colorscale: {
	        valType: 'colorscale',
	        role: 'style',
	        description: [
	            'Sets the colorscale.',
	            'The colorscale must be an array containing',
	            'arrays mapping a normalized value to an',
	            'rgb, rgba, hex, hsl, hsv, or named color string.',
	            'At minimum, a mapping for the lowest (0) and highest (1)',
	            'values are required. For example,',
	            '`[[0, \'rgb(0,0,255)\', [1, \'rgb(255,0,0)\']]`.',
	            'To control the bounds of the colorscale in z space,',
	            'use zmin and zmax'
	        ].join(' ')
	    },
	    autocolorscale: {
	        valType: 'boolean',
	        role: 'style',
	        dflt: true,  // gets overrode in 'heatmap' & 'surface' for backwards comp.
	        description: [
	            'Determines whether or not the colorscale is picked using the sign of',
	            'the input z values.'
	        ].join(' ')
	    },
	    reversescale: {
	        valType: 'boolean',
	        role: 'style',
	        dflt: false,
	        description: 'Reverses the colorscale.'
	    },
	    showscale: {
	        valType: 'boolean',
	        role: 'info',
	        dflt: true,
	        description: [
	            'Determines whether or not a colorbar is displayed for this trace.'
	        ].join(' ')
	    },
	
	    _deprecated: {
	        scl: {
	            valType: 'colorscale',
	            role: 'style',
	            description: 'Renamed to `colorscale`.'
	        },
	        reversescl: {
	            valType: 'boolean',
	            role: 'style',
	            description: 'Renamed to `reversescale`.'
	        }
	    }
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	
	var hasColorbar = __webpack_require__(344);
	var colorbarDefaults = __webpack_require__(345);
	var isValidScale = __webpack_require__(355);
	var flipScale = __webpack_require__(356);
	
	
	module.exports = function colorScaleDefaults(traceIn, traceOut, layout, coerce, opts) {
	    var prefix = opts.prefix,
	        cLetter = opts.cLetter,
	        containerStr = prefix.slice(0, prefix.length-1),
	        containerIn = prefix ?
	            Lib.nestedProperty(traceIn, containerStr).get() || {} :
	            traceIn,
	        containerOut = prefix ?
	            Lib.nestedProperty(traceOut, containerStr).get() || {} :
	            traceOut,
	        minIn = containerIn[cLetter + 'min'],
	        maxIn = containerIn[cLetter + 'max'],
	        sclIn = containerIn.colorscale;
	
	    var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && (minIn < maxIn);
	    coerce(prefix + cLetter + 'auto', !validMinMax);
	    coerce(prefix + cLetter + 'min');
	    coerce(prefix + cLetter + 'max');
	
	    // handles both the trace case (autocolorscale is false by default) and
	    // the marker and marker.line case (autocolorscale is true by default)
	    var autoColorscaleDftl;
	    if(sclIn!==undefined) autoColorscaleDftl = !isValidScale(sclIn);
	    coerce(prefix + 'autocolorscale', autoColorscaleDftl);
	    var sclOut = coerce(prefix + 'colorscale');
	
	    // reversescale is handled at the containerOut level
	    var reverseScale = coerce(prefix + 'reversescale');
	    if(reverseScale) containerOut.colorscale = flipScale(sclOut);
	
	    // ... until Scatter.colorbar can handle marker line colorbars
	    if(prefix === 'marker.line.') return;
	
	    // handle both the trace case where the dflt is listed in attributes and
	    // the marker case where the dflt is determined by hasColorbar
	    var showScaleDftl;
	    if(prefix) showScaleDftl = hasColorbar(containerIn);
	    var showScale = coerce(prefix + 'showscale', showScaleDftl);
	
	    if(showScale) colorbarDefaults(containerIn, containerOut, layout);
	};


/***/ },
/* 344 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	module.exports = function hasColorbar(container) {
	    return (
	        typeof container.colorbar === 'object' &&
	        container.colorbar !== null
	    );
	};


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var handleTickValueDefaults = __webpack_require__(346);
	var handleTickMarkDefaults = __webpack_require__(347);
	var handleTickLabelDefaults = __webpack_require__(353);
	
	var attributes = __webpack_require__(354);
	
	
	module.exports = function colorbarDefaults(containerIn, containerOut, layout) {
	    var colorbarOut = containerOut.colorbar = {},
	        colorbarIn = containerIn.colorbar || {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);
	    }
	
	    var thicknessmode = coerce('thicknessmode');
	    coerce('thickness', (thicknessmode === 'fraction') ?
	        30 / (layout.width - layout.margin.l - layout.margin.r) :
	        30
	    );
	
	    var lenmode = coerce('lenmode');
	    coerce('len', (lenmode === 'fraction') ?
	        1 :
	        layout.height - layout.margin.t - layout.margin.b
	    );
	
	    coerce('x');
	    coerce('xanchor');
	    coerce('xpad');
	    coerce('y');
	    coerce('yanchor');
	    coerce('ypad');
	    Lib.noneOrAll(colorbarIn, colorbarOut, ['x', 'y']);
	
	    coerce('outlinecolor');
	    coerce('outlinewidth');
	    coerce('bordercolor');
	    coerce('borderwidth');
	    coerce('bgcolor');
	
	    handleTickValueDefaults(colorbarIn, colorbarOut, coerce, 'linear');
	
	    handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, 'linear',
	        {outerTicks: false, font: layout.font, noHover: true});
	
	    handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, 'linear',
	        {outerTicks: false, font: layout.font, noHover: true});
	
	    coerce('title');
	    Lib.coerceFont(coerce, 'titlefont', layout.font);
	    coerce('titleside');
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	
	module.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType) {
	    var tickmodeDefault = 'auto';
	
	    if(containerIn.tickmode === 'array' &&
	            (axType === 'log' || axType === 'date')) {
	        containerIn.tickmode = 'auto';
	    }
	
	    if(Array.isArray(containerIn.tickvals)) tickmodeDefault = 'array';
	    else if(containerIn.dtick && isNumeric(containerIn.dtick)) {
	        tickmodeDefault = 'linear';
	    }
	    var tickmode = coerce('tickmode', tickmodeDefault);
	
	    if(tickmode === 'auto') coerce('nticks');
	    else if(tickmode === 'linear') {
	        coerce('tick0');
	        coerce('dtick');
	    }
	    else {
	        var tickvals = coerce('tickvals');
	        if(tickvals === undefined) containerOut.tickmode = 'auto';
	        else coerce('ticktext');
	    }
	};


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	var layoutAttributes = __webpack_require__(348);
	
	
	/**
	 * options: inherits outerTicks from axes.handleAxisDefaults
	 */
	module.exports = function handleTickDefaults(containerIn, containerOut, coerce, options) {
	    var tickLen = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'ticklen'),
	        tickWidth = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'tickwidth'),
	        tickColor = Lib.coerce2(containerIn, containerOut, layoutAttributes, 'tickcolor', containerOut.color),
	        showTicks = coerce('ticks', (options.outerTicks || tickLen || tickWidth || tickColor) ? 'outside' : '');
	
	    if(!showTicks) {
	        delete containerOut.ticklen;
	        delete containerOut.tickwidth;
	        delete containerOut.tickcolor;
	    }
	};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var fontAttrs = __webpack_require__(336);
	var colorAttrs = __webpack_require__(334);
	var extendFlat = __webpack_require__(324).extendFlat;
	var rangeSliderAttrs = __webpack_require__(349);
	var rangeSelectorAttrs = __webpack_require__(350);
	
	var constants = __webpack_require__(352);
	
	
	module.exports = {
	    color: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: [
	            'Sets default for all colors associated with this axis',
	            'all at once: line, font, tick, and grid colors.',
	            'Grid color is lightened by blending this with the plot background',
	            'Individual pieces can override this.'
	        ].join(' ')
	    },
	    title: {
	        valType: 'string',
	        role: 'info',
	        description: 'Sets the title of this axis.'
	    },
	    titlefont: extendFlat({}, fontAttrs, {
	        description: [
	            'Sets this axis\' title font.'
	        ].join(' ')
	    }),
	    type: {
	        valType: 'enumerated',
	        // '-' means we haven't yet run autotype or couldn't find any data
	        // it gets turned into linear in td._fullLayout but not copied back
	        // to td.data like the others are.
	        values: ['-', 'linear', 'log', 'date', 'category'],
	        dflt: '-',
	        role: 'info',
	        description: [
	            'Sets the axis type.',
	            'By default, plotly attempts to determined the axis type',
	            'by looking into the data of the traces that referenced',
	            'the axis in question.'
	        ].join(' ')
	    },
	    autorange: {
	        valType: 'enumerated',
	        values: [true, false, 'reversed'],
	        dflt: true,
	        role: 'style',
	        description: [
	            'Determines whether or not the range of this axis is',
	            'computed in relation to the input data.',
	            'See `rangemode` for more info.',
	            'If `range` is provided, then `autorange` is set to *false*.'
	        ].join(' ')
	    },
	    rangemode: {
	        valType: 'enumerated',
	        values: ['normal', 'tozero', 'nonnegative'],
	        dflt: 'normal',
	        role: 'style',
	        description: [
	            'If *normal*, the range is computed in relation to the extrema',
	            'of the input data.',
	            'If *tozero*`, the range extends to 0,',
	            'regardless of the input data',
	            'If *nonnegative*, the range is non-negative,',
	            'regardless of the input data.'
	        ].join(' ')
	    },
	    range: {
	        valType: 'info_array',
	        role: 'info',
	        items: [
	            {valType: 'number'},
	            {valType: 'number'}
	        ],
	        description: [
	            'Sets the range of this axis.',
	            'If the axis `type` is *log*, then you must take the log of your desired range',
	            '(e.g. to set the range from 1 to 100, set the range from 0 to 2).',
	            'If the axis `type` is *date*, then you must convert the date to unix time in milliseconds',
	            '(the number of milliseconds since January 1st, 1970). For example, to set the date range from',
	            'January 1st 1970 to November 4th, 2013, set the range from 0 to 1380844800000.0'
	        ].join(' ')
	    },
	
	    rangeslider: rangeSliderAttrs,
	    rangeselector: rangeSelectorAttrs,
	
	    fixedrange: {
	        valType: 'boolean',
	        dflt: false,
	        role: 'info',
	        description: [
	            'Determines whether or not this axis is zoom-able.',
	            'If true, then zoom is disabled.'
	        ].join(' ')
	    },
	    // ticks
	    tickmode: {
	        valType: 'enumerated',
	        values: ['auto', 'linear', 'array'],
	        role: 'info',
	        description: [
	            'Sets the tick mode for this axis.',
	            'If *auto*, the number of ticks is set via `nticks`.',
	            'If *linear*, the placement of the ticks is determined by',
	            'a starting position `tick0` and a tick step `dtick`',
	            '(*linear* is the default value if `tick0` and `dtick` are provided).',
	            'If *array*, the placement of the ticks is set via `tickvals`',
	            'and the tick text is `ticktext`.',
	            '(*array* is the default value if `tickvals` is provided).'
	        ].join(' ')
	    },
	    nticks: {
	        valType: 'integer',
	        min: 0,
	        dflt: 0,
	        role: 'style',
	        description: [
	            'Sets the number of ticks.',
	            'Has an effect only if `tickmode` is set to *auto*.'
	        ].join(' ')
	    },
	    tick0: {
	        valType: 'number',
	        dflt: 0,
	        role: 'style',
	        description: [
	            'Sets the placement of the first tick on this axis.',
	            'Use with `dtick`.',
	            'If the axis `type` is *log*, then you must take the log of your starting tick',
	            '(e.g. to set the starting tick to 100, set the `tick0` to 2).',
	            'If the axis `type` is *date*, then you must convert the date to unix time in milliseconds',
	            '(the number of milliseconds since January 1st, 1970).',
	            'For example, to set the starting tick to',
	            'November 4th, 2013, set the range to 1380844800000.0.'
	        ].join(' ')
	    },
	    dtick: {
	        valType: 'any',
	        dflt: 1,
	        role: 'style',
	        description: [
	            'Sets the step in-between ticks on this axis',
	            'Use with `tick0`.',
	            'If the axis `type` is *log*, then ticks are set every 10^(n*dtick) where n',
	            'is the tick number. For example,',
	            'to set a tick mark at 1, 10, 100, 1000, ... set dtick to 1.',
	            'To set tick marks at 1, 100, 10000, ... set dtick to 2.',
	            'To set tick marks at 1, 5, 25, 125, 625, 3125, ... set dtick to log_10(5), or 0.69897000433.',
	            'If the axis `type` is *date*, then you must convert the time to milliseconds.',
	            'For example, to set the interval between ticks to one day,',
	            'set `dtick` to 86400000.0.'
	        ].join(' ')
	    },
	    tickvals: {
	        valType: 'data_array',
	        description: [
	            'Sets the values at which ticks on this axis appear.',
	            'Only has an effect if `tickmode` is set to *array*.',
	            'Used with `ticktext`.'
	        ].join(' ')
	    },
	    ticktext: {
	        valType: 'data_array',
	        description: [
	            'Sets the text displayed at the ticks position via `tickvals`.',
	            'Only has an effect if `tickmode` is set to *array*.',
	            'Used with `ticktext`.'
	        ].join(' ')
	    },
	    ticks: {
	        valType: 'enumerated',
	        values: ['outside', 'inside', ''],
	        role: 'style',
	        description: [
	            'Determines whether ticks are drawn or not.',
	            'If **, this axis\' ticks are not drawn.',
	            'If *outside* (*inside*), this axis\' are drawn outside (inside)',
	            'the axis lines.'
	        ].join(' ')
	    },
	    mirror: {
	        valType: 'enumerated',
	        values: [true, 'ticks', false, 'all', 'allticks'],
	        dflt: false,
	        role: 'style',
	        description: [
	            'Determines if the axis lines or/and ticks are mirrored to',
	            'the opposite side of the plotting area.',
	            'If *true*, the axis lines are mirrored.',
	            'If *ticks*, the axis lines and ticks are mirrored.',
	            'If *false*, mirroring is disable.',
	            'If *all*, axis lines are mirrored on all shared-axes subplots.',
	            'If *allticks*, axis lines and ticks are mirrored',
	            'on all shared-axes subplots.'
	        ].join(' ')
	    },
	    ticklen: {
	        valType: 'number',
	        min: 0,
	        dflt: 5,
	        role: 'style',
	        description: 'Sets the tick length (in px).'
	    },
	    tickwidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the tick width (in px).'
	    },
	    tickcolor: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: 'Sets the tick color.'
	    },
	    showticklabels: {
	        valType: 'boolean',
	        dflt: true,
	        role: 'style',
	        description: 'Determines whether or not the tick labels are drawn.'
	    },
	    tickfont: extendFlat({}, fontAttrs, {
	        description: 'Sets the tick font.'
	    }),
	    tickangle: {
	        valType: 'angle',
	        dflt: 'auto',
	        role: 'style',
	        description: [
	            'Sets the angle of the tick labels with respect to the horizontal.',
	            'For example, a `tickangle` of -90 draws the tick labels',
	            'vertically.'
	        ].join(' ')
	    },
	    tickprefix: {
	        valType: 'string',
	        dflt: '',
	        role: 'style',
	        description: 'Sets a tick label prefix.'
	    },
	    showtickprefix: {
	        valType: 'enumerated',
	        values: ['all', 'first', 'last', 'none'],
	        dflt: 'all',
	        role: 'style',
	        description: [
	            'If *all*, all tick labels are displayed with a prefix.',
	            'If *first*, only the first tick is displayed with a prefix.',
	            'If *last*, only the last tick is displayed with a suffix.',
	            'If *none*, tick prefixes are hidden.'
	        ].join(' ')
	    },
	    ticksuffix: {
	        valType: 'string',
	        dflt: '',
	        role: 'style',
	        description: 'Sets a tick label suffix.'
	    },
	    showticksuffix: {
	        valType: 'enumerated',
	        values: ['all', 'first', 'last', 'none'],
	        dflt: 'all',
	        role: 'style',
	        description: 'Same as `showtickprefix` but for tick suffixes.'
	    },
	    showexponent: {
	        valType: 'enumerated',
	        values: ['all', 'first', 'last', 'none'],
	        dflt: 'all',
	        role: 'style',
	        description: [
	            'If *all*, all exponents are shown besides their significands.',
	            'If *first*, only the exponent of the first tick is shown.',
	            'If *last*, only the exponent of the last tick is shown.',
	            'If *none*, no exponents appear.'
	        ].join(' ')
	    },
	    exponentformat: {
	        valType: 'enumerated',
	        values: ['none', 'e', 'E', 'power', 'SI', 'B'],
	        dflt: 'B',
	        role: 'style',
	        description: [
	            'Determines a formatting rule for the tick exponents.',
	            'For example, consider the number 1,000,000,000.',
	            'If *none*, it appears as 1,000,000,000.',
	            'If *e*, 1e+9.',
	            'If *E*, 1E+9.',
	            'If *power*, 1x10^9 (with 9 in a super script).',
	            'If *SI*, 1G.',
	            'If *B*, 1B.'
	        ].join(' ')
	    },
	    tickformat: {
	        valType: 'string',
	        dflt: '',
	        role: 'style',
	        description: [
	            'Sets the tick label formatting rule using the',
	            'python/d3 number formatting language.',
	            'See https://github.com/mbostock/d3/wiki/Formatting#numbers',
	            'or https://docs.python.org/release/3.1.3/library/string.html#formatspec',
	            'for more info.'
	        ].join(' ')
	    },
	    hoverformat: {
	        valType: 'string',
	        dflt: '',
	        role: 'style',
	        description: [
	            'Sets the hover text formatting rule for data values on this axis,',
	            'using the python/d3 number formatting language.',
	            'See https://github.com/mbostock/d3/wiki/Formatting#numbers',
	            'or https://docs.python.org/release/3.1.3/library/string.html#formatspec',
	            'for more info.'
	        ].join(' ')
	    },
	    // lines and grids
	    showline: {
	        valType: 'boolean',
	        dflt: false,
	        role: 'style',
	        description: [
	            'Determines whether or not a line bounding this axis is drawn.'
	        ].join(' ')
	    },
	    linecolor: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: 'Sets the axis line color.'
	    },
	    linewidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the width (in px) of the axis line.'
	    },
	    showgrid: {
	        valType: 'boolean',
	        role: 'style',
	        description: [
	            'Determines whether or not grid lines are drawn.',
	            'If *true*, the grid lines are drawn at every tick mark.'
	        ].join(' ')
	    },
	    gridcolor: {
	        valType: 'color',
	        dflt: colorAttrs.lightLine,
	        role: 'style',
	        description: 'Sets the color of the grid lines.'
	    },
	    gridwidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the width (in px) of the grid lines.'
	    },
	    zeroline: {
	        valType: 'boolean',
	        role: 'style',
	        description: [
	            'Determines whether or not a line is drawn at along the 0 value',
	            'of this axis.',
	            'If *true*, the zero line is drawn on top of the grid lines.'
	        ].join(' ')
	    },
	    zerolinecolor: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: 'Sets the line color of the zero line.'
	    },
	    zerolinewidth: {
	        valType: 'number',
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the width (in px) of the zero line.'
	    },
	    // positioning attributes
	    // anchor: not used directly, just put here for reference
	    // values are any opposite-letter axis id
	    anchor: {
	        valType: 'enumerated',
	        values: [
	            'free',
	            constants.idRegex.x.toString(),
	            constants.idRegex.y.toString()
	        ],
	        role: 'info',
	        description: [
	            'If set to an opposite-letter axis id (e.g. `xaxis2`, `yaxis`), this axis is bound to',
	            'the corresponding opposite-letter axis.',
	            'If set to *free*, this axis\' position is determined by `position`.'
	        ].join(' ')
	    },
	    // side: not used directly, as values depend on direction
	    // values are top, bottom for x axes, and left, right for y
	    side: {
	        valType: 'enumerated',
	        values: ['top', 'bottom', 'left', 'right'],
	        role: 'info',
	        description: [
	            'Determines whether a x (y) axis is positioned',
	            'at the *bottom* (*left*) or *top* (*right*)',
	            'of the plotting area.'
	        ].join(' ')
	    },
	    // overlaying: not used directly, just put here for reference
	    // values are false and any other same-letter axis id that's not
	    // itself overlaying anything
	    overlaying: {
	        valType: 'enumerated',
	        values: [
	            'free',
	            constants.idRegex.x.toString(),
	            constants.idRegex.y.toString()
	        ],
	        role: 'info',
	        description: [
	            'If set a same-letter axis id, this axis is overlaid on top of',
	            'the corresponding same-letter axis.',
	            'If *false*, this axis does not overlay any same-letter axes.'
	        ].join(' ')
	    },
	    domain: {
	        valType: 'info_array',
	        role: 'info',
	        items: [
	            {valType: 'number', min: 0, max: 1},
	            {valType: 'number', min: 0, max: 1}
	        ],
	        dflt: [0, 1],
	        description: [
	            'Sets the domain of this axis (in plot fraction).'
	        ].join(' ')
	    },
	    position: {
	        valType: 'number',
	        min: 0,
	        max: 1,
	        dflt: 0,
	        role: 'style',
	        description: [
	            'Sets the position of this axis in the plotting space',
	            '(in normalized coordinates).',
	            'Only has an effect if `anchor` is set to *free*.'
	        ].join(' ')
	    },
	    categoryorder: {
	        valType: 'enumerated',
	        values: [
	            'trace', 'category ascending', 'category descending', 'array'
	            /*, 'value ascending', 'value descending'*/ // value ascending / descending to be implemented later
	        ],
	        dflt: 'trace',
	        role: 'info',
	        description: [
	            'Specifies the ordering logic for the case of categorical variables.',
	            'By default, plotly uses *trace*, which specifies the order that is present in the data supplied.',
	            'Set `categoryorder` to *category ascending* or *category descending* if order should be determined by',
	            'the alphanumerical order of the category names.',
	            /*'Set `categoryorder` to *value ascending* or *value descending* if order should be determined by the',
	            'numerical order of the values.',*/ // // value ascending / descending to be implemented later
	            'Set `categoryorder` to *array* to derive the ordering from the attribute `categoryarray`. If a category',
	            'is not found in the `categoryarray` array, the sorting behavior for that attribute will be identical to',
	            'the *trace* mode. The unspecified categories will follow the categories in `categoryarray`.'
	        ].join(' ')
	    },
	    categoryarray: {
	        valType: 'data_array',
	        role: 'info',
	        description: [
	            'Sets the order in which categories on this axis appear.',
	            'Only has an effect if `categoryorder` is set to *array*.',
	            'Used with `categoryorder`.'
	        ].join(' ')
	    },
	
	
	    _deprecated: {
	        autotick: {
	            valType: 'boolean',
	            role: 'info',
	            description: [
	                'Obsolete.',
	                'Set `tickmode` to *auto* for old `autotick` *true* behavior.',
	                'Set `tickmode` to *linear* for `autotick` *false*.'
	            ].join(' ')
	        }
	    }
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var colorAttributes = __webpack_require__(334);
	
	module.exports = {
	    bgcolor: {
	        valType: 'color',
	        dflt: colorAttributes.background,
	        role: 'style',
	        description: 'Sets the background color of the range slider.'
	    },
	    bordercolor: {
	        valType: 'color',
	        dflt: colorAttributes.defaultLine,
	        role: 'style',
	        description: 'Sets the border color of the range slider.'
	    },
	    borderwidth: {
	        valType: 'integer',
	        dflt: 0,
	        min: 0,
	        role: 'style',
	        description: 'Sets the border color of the range slider.'
	    },
	    range: {
	        valType: 'info_array',
	        role: 'info',
	        items: [
	            {valType: 'number'},
	            {valType: 'number'}
	        ],
	        description: [
	            'Sets the range of the range slider.',
	            'If not set, defaults to the full xaxis range.',
	            'If the axis `type` is *log*, then you must take the',
	            'log of your desired range.',
	            'If the axis `type` is *date*, then you must convert',
	            'the date to unix time in milliseconds.'
	        ].join(' ')
	    },
	    thickness: {
	        valType: 'number',
	        dflt: 0.15,
	        min: 0,
	        max: 1,
	        role: 'style',
	        description: [
	            'The height of the range slider as a fraction of the',
	            'total plot area height.'
	        ].join(' ')
	    },
	    visible: {
	        valType: 'boolean',
	        dflt: true,
	        role: 'info',
	        description: [
	            'Determines whether or not the range slider will be visible.',
	            'If visible, perpendicular axes will be set to `fixedrange`'
	        ].join(' ')
	    }
	};


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var fontAttrs = __webpack_require__(336);
	var colorAttrs = __webpack_require__(334);
	var extendFlat = __webpack_require__(324).extendFlat;
	var buttonAttrs = __webpack_require__(351);
	
	buttonAttrs = extendFlat(buttonAttrs, {
	    _isLinkedToArray: true,
	    description: [
	        'Sets the specifications for each buttons.',
	        'By default, a range selector comes with no buttons.'
	    ].join(' ')
	});
	
	module.exports = {
	    visible: {
	        valType: 'boolean',
	        role: 'info',
	        description: [
	            'Determines whether or not this range selector is visible.',
	            'Note that range selectors are only available for x axes of',
	            '`type` set to or auto-typed to *date*.'
	        ].join(' ')
	    },
	
	    buttons: buttonAttrs,
	
	    x: {
	        valType: 'number',
	        min: -2,
	        max: 3,
	        role: 'style',
	        description: 'Sets the x position (in normalized coordinates) of the range selector.'
	    },
	    xanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'left', 'center', 'right'],
	        dflt: 'left',
	        role: 'info',
	        description: [
	            'Sets the range selector\'s horizontal position anchor.',
	            'This anchor binds the `x` position to the *left*, *center*',
	            'or *right* of the range selector.'
	        ].join(' ')
	    },
	    y: {
	        valType: 'number',
	        min: -2,
	        max: 3,
	        role: 'style',
	        description: 'Sets the y position (in normalized coordinates) of the range selector.'
	    },
	    yanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'top', 'middle', 'bottom'],
	        dflt: 'bottom',
	        role: 'info',
	        description: [
	            'Sets the range selector\'s vertical position anchor',
	            'This anchor binds the `y` position to the *top*, *middle*',
	            'or *bottom* of the range selector.'
	        ].join(' ')
	    },
	
	    font: extendFlat({}, fontAttrs, {
	        description: 'Sets the font of the range selector button text.'
	    }),
	
	    bgcolor: {
	        valType: 'color',
	        dflt: colorAttrs.lightLine,
	        role: 'style',
	        description: 'Sets the background color of the range selector buttons.'
	    },
	    bordercolor: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: 'Sets the color of the border enclosing the range selector.'
	    },
	    borderwidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 0,
	        role: 'style',
	        description: 'Sets the width (in px) of the border enclosing the range selector.'
	    }
	};


/***/ },
/* 351 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    step: {
	        valType: 'enumerated',
	        role: 'info',
	        values: ['month', 'year', 'day', 'hour', 'minute', 'second', 'all'],
	        dflt: 'month',
	        description: [
	            'The unit of measurement that the `count` value will set the range by.'
	        ].join(' ')
	    },
	    stepmode: {
	        valType: 'enumerated',
	        role: 'info',
	        values: ['backward', 'todate'],
	        dflt: 'backward',
	        description: [
	            'Sets the range update mode.',
	            'If *backward*, the range update shifts the start of range',
	            'back *count* times *step* milliseconds.',
	            'If *todate*, the range update shifts the start of range',
	            'back to the first timestamp from *count* times',
	            '*step* milliseconds back.',
	            'For example, with `step` set to *year* and `count` set to *1*',
	            'the range update shifts the start of the range back to',
	            'January 01 of the current year.'
	        ].join(' ')
	    },
	    count: {
	        valType: 'number',
	        role: 'info',
	        min: 0,
	        dflt: 1,
	        description: [
	            'Sets the number of steps to take to update the range.',
	            'Use with `step` to specify the update interval.'
	        ].join(' ')
	    },
	    label: {
	        valType: 'string',
	        role: 'info',
	        description: 'Sets the text label to appear on the button.'
	    }
	};


/***/ },
/* 352 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	
	    idRegex: {
	        x: /^x([2-9]|[1-9][0-9]+)?$/,
	        y: /^y([2-9]|[1-9][0-9]+)?$/
	    },
	
	    attrRegex: {
	        x: /^xaxis([2-9]|[1-9][0-9]+)?$/,
	        y: /^yaxis([2-9]|[1-9][0-9]+)?$/
	    },
	
	    /**
	     * standardize all missing data in calcdata to use undefined
	     * never null or NaN.
	     * that way we can use !==undefined, or !== BADNUM,
	     * to test for real data
	     */
	    BADNUM: undefined,
	
	    // axis match regular expression
	    xAxisMatch: /^xaxis[0-9]*$/,
	    yAxisMatch: /^yaxis[0-9]*$/,
	
	    // pattern matching axis ids and names
	    AX_ID_PATTERN: /^[xyz][0-9]*$/,
	    AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,
	
	    // ms between first mousedown and 2nd mouseup to constitute dblclick...
	    // we don't seem to have access to the system setting
	    DBLCLICKDELAY: 300,
	
	    // pixels to move mouse before you stop clamping to starting point
	    MINDRAG: 8,
	
	    // smallest dimension allowed for a select box
	    MINSELECT: 12,
	
	    // smallest dimension allowed for a zoombox
	    MINZOOM: 20,
	
	    // width of axis drag regions
	    DRAGGERSIZE: 20,
	
	    // max pixels away from mouse to allow a point to highlight
	    MAXDIST: 20,
	
	    // hover labels for multiple horizontal bars get tilted by this angle
	    YANGLE: 60,
	
	    // size and display constants for hover text
	    HOVERARROWSIZE: 6, // pixel size of hover arrows
	    HOVERTEXTPAD: 3, // pixels padding around text
	    HOVERFONTSIZE: 13,
	    HOVERFONT: 'Arial, sans-serif',
	
	    // minimum time (msec) between hover calls
	    HOVERMINTIME: 50,
	
	    // max pixels off straight before a lasso select line counts as bent
	    BENDPX: 1.5
	};


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	
	/**
	 * options: inherits font, outerTicks, noHover from axes.handleAxisDefaults
	 */
	module.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {
	    var showAttrDflt = getShowAttrDflt(containerIn);
	
	    var tickPrefix = coerce('tickprefix');
	    if(tickPrefix) coerce('showtickprefix', showAttrDflt);
	
	    var tickSuffix = coerce('ticksuffix');
	    if(tickSuffix) coerce('showticksuffix', showAttrDflt);
	
	    var showTickLabels = coerce('showticklabels');
	    if(showTickLabels) {
	        var font = options.font || {};
	        // as with titlefont.color, inherit axis.color only if one was
	        // explicitly provided
	        var dfltFontColor = (containerOut.color === containerIn.color) ?
	            containerOut.color : font.color;
	        Lib.coerceFont(coerce, 'tickfont', {
	            family: font.family,
	            size: font.size,
	            color: dfltFontColor
	        });
	        coerce('tickangle');
	
	        if(axType !== 'category') {
	            var tickFormat = coerce('tickformat');
	            if(!tickFormat && axType !== 'date') {
	                coerce('showexponent', showAttrDflt);
	                coerce('exponentformat');
	            }
	        }
	    }
	
	    if(axType !== 'category' && !options.noHover) coerce('hoverformat');
	};
	
	/*
	 * Attributes 'showexponent', 'showtickprefix' and 'showticksuffix'
	 * share values.
	 *
	 * If only 1 attribute is set,
	 * the remaining attributes inherit that value.
	 *
	 * If 2 attributes are set to the same value,
	 * the remaining attribute inherits that value.
	 *
	 * If 2 attributes are set to different values,
	 * the remaining is set to its dflt value.
	 *
	 */
	function getShowAttrDflt(containerIn) {
	    var showAttrsAll = ['showexponent',
	                        'showtickprefix',
	                        'showticksuffix'],
	        showAttrs = showAttrsAll.filter(function(a) {
	            return containerIn[a]!==undefined;
	        }),
	        sameVal = function(a) {
	            return containerIn[a]===containerIn[showAttrs[0]];
	        };
	
	    if(showAttrs.every(sameVal) || showAttrs.length===1) {
	        return containerIn[showAttrs[0]];
	    }
	}


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var axesAttrs = __webpack_require__(348);
	var fontAttrs = __webpack_require__(336);
	var extendFlat = __webpack_require__(324).extendFlat;
	
	
	module.exports = {
	// TODO: only right is supported currently
	//     orient: {
	//         valType: 'enumerated',
	//         role: 'info',
	//         values: ['left', 'right', 'top', 'bottom'],
	//         dflt: 'right',
	//         description: [
	//             'Determines which side are the labels on',
	//             '(so left and right make vertical bars, etc.)'
	//         ].join(' ')
	//     },
	    thicknessmode: {
	        valType: 'enumerated',
	        values: ['fraction', 'pixels'],
	        role: 'style',
	        dflt: 'pixels',
	        description: [
	            'Determines whether this color bar\'s thickness',
	            '(i.e. the measure in the constant color direction)',
	            'is set in units of plot *fraction* or in *pixels*.',
	            'Use `thickness` to set the value.'
	        ].join(' ')
	    },
	    thickness: {
	        valType: 'number',
	        role: 'style',
	        min: 0,
	        dflt: 30,
	        description: [
	            'Sets the thickness of the color bar',
	            'This measure excludes the size of the padding, ticks and labels.'
	        ].join(' ')
	    },
	    lenmode: {
	        valType: 'enumerated',
	        values: ['fraction', 'pixels'],
	        role: 'info',
	        dflt: 'fraction',
	        description: [
	            'Determines whether this color bar\'s length',
	            '(i.e. the measure in the color variation direction)',
	            'is set in units of plot *fraction* or in *pixels.',
	            'Use `len` to set the value.'
	        ].join(' ')
	    },
	    len: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: [
	            'Sets the length of the color bar',
	            'This measure excludes the padding of both ends.',
	            'That is, the color bar length is this length minus the',
	            'padding on both ends.'
	        ].join(' ')
	    },
	    x: {
	        valType: 'number',
	        dflt: 1.02,
	        min: -2,
	        max: 3,
	        role: 'style',
	        description: [
	            'Sets the x position of the color bar (in plot fraction).'
	        ].join(' ')
	    },
	    xanchor: {
	        valType: 'enumerated',
	        values: ['left', 'center', 'right'],
	        dflt: 'left',
	        role: 'style',
	        description: [
	            'Sets this color bar\'s horizontal position anchor.',
	            'This anchor binds the `x` position to the *left*, *center*',
	            'or *right* of the color bar.'
	        ].join(' ')
	    },
	    xpad: {
	        valType: 'number',
	        role: 'style',
	        min: 0,
	        dflt: 10,
	        description: 'Sets the amount of padding (in px) along the x direction.'
	    },
	    y: {
	        valType: 'number',
	        role: 'style',
	        dflt: 0.5,
	        min: -2,
	        max: 3,
	        description: [
	            'Sets the y position of the color bar (in plot fraction).'
	        ].join(' ')
	    },
	    yanchor: {
	        valType: 'enumerated',
	        values: ['top', 'middle', 'bottom'],
	        role: 'style',
	        dflt: 'middle',
	        description: [
	            'Sets this color bar\'s vertical position anchor',
	            'This anchor binds the `y` position to the *top*, *middle*',
	            'or *bottom* of the color bar.'
	        ].join(' ')
	    },
	    ypad: {
	        valType: 'number',
	        role: 'style',
	        min: 0,
	        dflt: 10,
	        description: 'Sets the amount of padding (in px) along the y direction.'
	    },
	    // a possible line around the bar itself
	    outlinecolor: axesAttrs.linecolor,
	    outlinewidth: axesAttrs.linewidth,
	    // Should outlinewidth have {dflt: 0} ?
	    // another possible line outside the padding and tick labels
	    bordercolor: axesAttrs.linecolor,
	    borderwidth: {
	        valType: 'number',
	        role: 'style',
	        min: 0,
	        dflt: 0,
	        description: [
	            'Sets the width (in px) or the border enclosing this color bar.'
	        ].join(' ')
	    },
	    bgcolor: {
	        valType: 'color',
	        role: 'style',
	        dflt: 'rgba(0,0,0,0)',
	        description: 'Sets the color of padded area.'
	    },
	    // tick and title properties named and function exactly as in axes
	    tickmode: axesAttrs.tickmode,
	    nticks: axesAttrs.nticks,
	    tick0: axesAttrs.tick0,
	    dtick: axesAttrs.dtick,
	    tickvals: axesAttrs.tickvals,
	    ticktext: axesAttrs.ticktext,
	    ticks: extendFlat({}, axesAttrs.ticks, {dflt: ''}),
	    ticklen: axesAttrs.ticklen,
	    tickwidth: axesAttrs.tickwidth,
	    tickcolor: axesAttrs.tickcolor,
	    showticklabels: axesAttrs.showticklabels,
	    tickfont: axesAttrs.tickfont,
	    tickangle: axesAttrs.tickangle,
	    tickformat: axesAttrs.tickformat,
	    tickprefix: axesAttrs.tickprefix,
	    showtickprefix: axesAttrs.showtickprefix,
	    ticksuffix: axesAttrs.ticksuffix,
	    showticksuffix: axesAttrs.showticksuffix,
	    exponentformat: axesAttrs.exponentformat,
	    showexponent: axesAttrs.showexponent,
	    title: {
	        valType: 'string',
	        role: 'info',
	        dflt: 'Click to enter colorscale title',
	        description: 'Sets the title of the color bar.'
	    },
	    titlefont: extendFlat({}, fontAttrs, {
	        description: [
	            'Sets this color bar\'s title font.'
	        ].join(' ')
	    }),
	    titleside: {
	        valType: 'enumerated',
	        values: ['right', 'top', 'bottom'],
	        role: 'style',
	        dflt: 'top',
	        description: [
	            'Determines the location of the colorbar title',
	            'with respect to the color bar.'
	        ].join(' ')
	    }
	};


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var scales = __webpack_require__(317);
	var isValidScaleArray = __webpack_require__(319);
	
	
	module.exports = function isValidScale(scl) {
	    if(scales[scl] !== undefined) return true;
	    else return isValidScaleArray(scl);
	};


/***/ },
/* 356 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	module.exports = function flipScale(scl) {
	    var N = scl.length,
	        sclNew = new Array(N),
	        si;
	
	    for(var i = N-1, j = 0; i >= 0; i--, j++) {
	        si = scl[i];
	        sclNew[j] = [1 - si[0], si[1]];
	    }
	
	    return sclNew;
	};


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	var scales = __webpack_require__(317);
	var flipScale = __webpack_require__(356);
	
	
	module.exports = function calc(trace, vals, containerStr, cLetter) {
	    var container, inputContainer;
	
	    if(containerStr) {
	        container = Lib.nestedProperty(trace, containerStr).get();
	        inputContainer = Lib.nestedProperty(trace._input, containerStr).get();
	    } else {
	        container = trace;
	        inputContainer = trace._input;
	    }
	
	    var auto = container[cLetter + 'auto'],
	        min = container[cLetter + 'min'],
	        max = container[cLetter + 'max'],
	        scl = container.colorscale;
	
	    if(auto!==false || min===undefined) {
	        min = Lib.aggNums(Math.min, null, vals);
	    }
	
	    if(auto!==false || max===undefined) {
	        max = Lib.aggNums(Math.max, null, vals);
	    }
	
	    if(min === max) {
	        min -= 0.5;
	        max += 0.5;
	    }
	
	    container[cLetter + 'min'] = min;
	    container[cLetter + 'max'] = max;
	
	    inputContainer[cLetter + 'min'] = min;
	    inputContainer[cLetter + 'max'] = max;
	
	    if(container.autocolorscale) {
	        if(min * max < 0) scl = scales.RdBu;
	        else if(min >= 0) scl = scales.Reds;
	        else scl = scales.Blues;
	
	        // reversescale is handled at the containerOut level
	        inputContainer.colorscale = scl;
	        if(container.reversescale) scl = flipScale(scl);
	        container.colorscale = scl;
	    }
	};


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	
	var isValidScale = __webpack_require__(355);
	
	
	module.exports = function hasColorscale(trace, containerStr) {
	    var container = containerStr ?
	            Lib.nestedProperty(trace, containerStr).get() || {} :
	            trace,
	        color = container.color,
	        isArrayWithOneNumber = false;
	
	    if(Array.isArray(color)) {
	        for(var i = 0; i < color.length; i++) {
	            if(isNumeric(color[i])) {
	                isArrayWithOneNumber = true;
	                break;
	            }
	        }
	    }
	
	    return (
	        (typeof container==='object' && container!==null) && (
	            isArrayWithOneNumber ||
	            container.showscale===true ||
	            (isNumeric(container.cmin) && isNumeric(container.cmax)) ||
	            isValidScale(container.colorscale) ||
	            (typeof container.colorbar==='object' && container.colorbar!==null)
	        )
	    );
	};


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var tinycolor = __webpack_require__(315);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	var Color = __webpack_require__(333);
	
	
	module.exports = function makeScaleFunction(scl, cmin, cmax) {
	    var N = scl.length,
	        domain = new Array(N),
	        range = new Array(N),
	        si;
	
	    for(var i = 0; i < N; i++) {
	        si = scl[i];
	        domain[i] = cmin + si[0] * (cmax - cmin);
	        range[i] = tinycolor(si[1]).toRgb();
	    }
	
	    var sclFunc = d3.scale.linear()
	        .domain(domain)
	        .interpolate(d3.interpolateObject)
	        .range(range);
	
	    return function(v) {
	        if(isNumeric(v)) {
	            var sclVal = Lib.constrain(v, cmin, cmax),
	                colorObj = sclFunc(sclVal);
	
	            return tinycolor(colorObj).toRgbString();
	        }
	        else if(tinycolor(v).isValid()) return v;
	        else return Color.defaultLine;
	    };
	};


/***/ },
/* 360 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	module.exports = {
	    hasLines: function(trace) {
	        return trace.visible && trace.mode &&
	            trace.mode.indexOf('lines') !== -1;
	    },
	
	    hasMarkers: function(trace) {
	        return trace.visible && trace.mode &&
	            trace.mode.indexOf('markers') !== -1;
	    },
	
	    hasText: function(trace) {
	        return trace.visible && trace.mode &&
	            trace.mode.indexOf('text') !== -1;
	    },
	
	    isBubble: function(trace) {
	        return (typeof trace.marker === 'object' &&
	                    Array.isArray(trace.marker.size));
	    }
	};


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	
	// used in the drawing step for 'scatter' and 'scattegeo' and
	// in the convert step for 'scatter3d'
	module.exports = function makeBubbleSizeFn(trace) {
	    var marker = trace.marker,
	        sizeRef = marker.sizeref || 1,
	        sizeMin = marker.sizemin || 0;
	
	    // for bubble charts, allow scaling the provided value linearly
	    // and by area or diameter.
	    // Note this only applies to the array-value sizes
	
	    var baseFn = (marker.sizemode === 'area') ?
	            function(v) { return Math.sqrt(v / sizeRef); } :
	            function(v) { return v / sizeRef; };
	
	    // TODO add support for position/negative bubbles?
	    // TODO add 'sizeoffset' attribute?
	    return function(v) {
	        var baseSize = baseFn(v / 2);
	
	        // don't show non-numeric and negative sizes
	        return (isNumeric(baseSize) && (baseSize > 0)) ?
	            Math.max(baseSize, sizeMin) :
	            0;
	    };
	};


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	/** Marker symbol definitions
	 * users can specify markers either by number or name
	 * add 100 (or '-open') and you get an open marker
	 *  open markers have no fill and use line color as the stroke color
	 * add 200 (or '-dot') and you get a dot in the middle
	 * add both and you get both
	 */
	
	module.exports = {
	    circle: {
	        n: 0,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+
	                'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';
	        }
	    },
	    square: {
	        n: 1,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';
	        }
	    },
	    diamond: {
	        n: 2,
	        f: function(r) {
	            var rd = d3.round(r*1.3,2);
	            return 'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z';
	        }
	    },
	    cross: {
	        n: 3,
	        f: function(r) {
	            var rc = d3.round(r*0.4,2),
	                rc2 = d3.round(r*1.2,2);
	            return 'M'+rc2+','+rc+'H'+rc+'V'+rc2+'H-'+rc+
	                'V'+rc+'H-'+rc2+'V-'+rc+'H-'+rc+'V-'+rc2+
	                'H'+rc+'V-'+rc+'H'+rc2+'Z';
	        }
	    },
	    x: {
	        n: 4,
	        f: function(r) {
	            var rx = d3.round(r*0.8/Math.sqrt(2),2),
	                ne = 'l'+rx+','+rx,
	                se = 'l'+rx+',-'+rx,
	                sw = 'l-'+rx+',-'+rx,
	                nw = 'l-'+rx+','+rx;
	            return 'M0,'+rx+ne+se+sw+se+sw+nw+sw+nw+ne+nw+ne+'Z';
	        }
	    },
	    'triangle-up': {
	        n: 5,
	        f: function(r) {
	            var rt = d3.round(r*2/Math.sqrt(3),2),
	                r2 = d3.round(r/2,2),
	                rs = d3.round(r,2);
	            return 'M-'+rt+','+r2+'H'+rt+'L0,-'+rs+'Z';
	        }
	    },
	    'triangle-down': {
	        n: 6,
	        f: function(r) {
	            var rt = d3.round(r*2/Math.sqrt(3),2),
	                r2 = d3.round(r/2,2),
	                rs = d3.round(r,2);
	            return 'M-'+rt+',-'+r2+'H'+rt+'L0,'+rs+'Z';
	        }
	    },
	    'triangle-left': {
	        n: 7,
	        f: function(r) {
	            var rt = d3.round(r*2/Math.sqrt(3),2),
	                r2 = d3.round(r/2,2),
	                rs = d3.round(r,2);
	            return 'M'+r2+',-'+rt+'V'+rt+'L-'+rs+',0Z';
	        }
	    },
	    'triangle-right': {
	        n: 8,
	        f: function(r) {
	            var rt = d3.round(r*2/Math.sqrt(3),2),
	                r2 = d3.round(r/2,2),
	                rs = d3.round(r,2);
	            return 'M-'+r2+',-'+rt+'V'+rt+'L'+rs+',0Z';
	        }
	    },
	    'triangle-ne': {
	        n: 9,
	        f: function(r) {
	            var r1 = d3.round(r*0.6,2),
	                r2 = d3.round(r*1.2,2);
	            return 'M-'+r2+',-'+r1+'H'+r1+'V'+r2+'Z';
	        }
	    },
	    'triangle-se': {
	        n: 10,
	        f: function(r) {
	            var r1 = d3.round(r*0.6,2),
	                r2 = d3.round(r*1.2,2);
	            return 'M'+r1+',-'+r2+'V'+r1+'H-'+r2+'Z';
	        }
	    },
	    'triangle-sw': {
	        n: 11,
	        f: function(r) {
	            var r1 = d3.round(r*0.6,2),
	                r2 = d3.round(r*1.2,2);
	            return 'M'+r2+','+r1+'H-'+r1+'V-'+r2+'Z';
	        }
	    },
	    'triangle-nw': {
	        n: 12,
	        f: function(r) {
	            var r1 = d3.round(r*0.6,2),
	                r2 = d3.round(r*1.2,2);
	            return 'M-'+r1+','+r2+'V-'+r1+'H'+r2+'Z';
	        }
	    },
	    pentagon: {
	        n: 13,
	        f: function(r) {
	            var x1 = d3.round(r*0.951,2),
	                x2 = d3.round(r*0.588,2),
	                y0 = d3.round(-r,2),
	                y1 = d3.round(r*-0.309,2),
	                y2 = d3.round(r*0.809,2);
	            return 'M'+x1+','+y1+'L'+x2+','+y2+'H-'+x2+
	                'L-'+x1+','+y1+'L0,'+y0+'Z';
	        }
	    },
	    hexagon: {
	        n: 14,
	        f: function(r) {
	            var y0 = d3.round(r,2),
	                y1 = d3.round(r/2,2),
	                x = d3.round(r*Math.sqrt(3)/2,2);
	            return 'M'+x+',-'+y1+'V'+y1+'L0,'+y0+
	                'L-'+x+','+y1+'V-'+y1+'L0,-'+y0+'Z';
	        }
	    },
	    hexagon2: {
	        n: 15,
	        f: function(r) {
	            var x0 = d3.round(r,2),
	                x1 = d3.round(r/2,2),
	                y = d3.round(r*Math.sqrt(3)/2,2);
	            return 'M-'+x1+','+y+'H'+x1+'L'+x0+
	                ',0L'+x1+',-'+y+'H-'+x1+'L-'+x0+',0Z';
	        }
	    },
	    octagon: {
	        n: 16,
	        f: function(r) {
	            var a = d3.round(r*0.924,2),
	                b = d3.round(r*0.383,2);
	            return 'M-'+b+',-'+a+'H'+b+'L'+a+',-'+b+'V'+b+
	                'L'+b+','+a+'H-'+b+'L-'+a+','+b+'V-'+b+'Z';
	        }
	    },
	    star: {
	        n: 17,
	        f: function(r) {
	            var rs = r*1.4,
	                x1 = d3.round(rs*0.225,2),
	                x2 = d3.round(rs*0.951,2),
	                x3 = d3.round(rs*0.363,2),
	                x4 = d3.round(rs*0.588,2),
	                y0 = d3.round(-rs,2),
	                y1 = d3.round(rs*-0.309,2),
	                y3 = d3.round(rs*0.118,2),
	                y4 = d3.round(rs*0.809,2),
	                y5 = d3.round(rs*0.382,2);
	            return 'M'+x1+','+y1+'H'+x2+'L'+x3+','+y3+
	                'L'+x4+','+y4+'L0,'+y5+'L-'+x4+','+y4+
	                'L-'+x3+','+y3+'L-'+x2+','+y1+'H-'+x1+
	                'L0,'+y0+'Z';
	        }
	    },
	    hexagram: {
	        n: 18,
	        f: function(r) {
	            var y = d3.round(r*0.66,2),
	                x1 = d3.round(r*0.38,2),
	                x2 = d3.round(r*0.76,2);
	            return 'M-'+x2+',0l-'+x1+',-'+y+'h'+x2+
	                'l'+x1+',-'+y+'l'+x1+','+y+'h'+x2+
	                'l-'+x1+','+y+'l'+x1+','+y+'h-'+x2+
	                'l-'+x1+','+y+'l-'+x1+',-'+y+'h-'+x2+'Z';
	        }
	    },
	    'star-triangle-up': {
	        n: 19,
	        f: function(r) {
	            var x = d3.round(r*Math.sqrt(3)*0.8,2),
	                y1 = d3.round(r*0.8,2),
	                y2 = d3.round(r*1.6,2),
	                rc = d3.round(r*4,2),
	                aPart = 'A '+rc+','+rc+' 0 0 1 ';
	            return 'M-'+x+','+y1+aPart+x+','+y1+
	                aPart+'0,-'+y2+aPart+'-'+x+','+y1+'Z';
	        }
	    },
	    'star-triangle-down': {
	        n: 20,
	        f: function(r) {
	            var x = d3.round(r*Math.sqrt(3)*0.8,2),
	                y1 = d3.round(r*0.8,2),
	                y2 = d3.round(r*1.6,2),
	                rc = d3.round(r*4,2),
	                aPart = 'A '+rc+','+rc+' 0 0 1 ';
	            return 'M'+x+',-'+y1+aPart+'-'+x+',-'+y1+
	                aPart+'0,'+y2+aPart+x+',-'+y1+'Z';
	        }
	    },
	    'star-square': {
	        n: 21,
	        f: function(r) {
	            var rp = d3.round(r*1.1,2),
	                rc = d3.round(r*2,2),
	                aPart = 'A '+rc+','+rc+' 0 0 1 ';
	            return 'M-'+rp+',-'+rp+aPart+'-'+rp+','+rp+
	                aPart+rp+','+rp+aPart+rp+',-'+rp+
	                aPart+'-'+rp+',-'+rp+'Z';
	        }
	    },
	    'star-diamond': {
	        n: 22,
	        f: function(r) {
	            var rp = d3.round(r*1.4,2),
	                rc = d3.round(r*1.9,2),
	                aPart = 'A '+rc+','+rc+' 0 0 1 ';
	            return 'M-'+rp+',0'+aPart+'0,'+rp+
	                aPart+rp+',0'+aPart+'0,-'+rp+
	                aPart+'-'+rp+',0'+'Z';
	        }
	    },
	    'diamond-tall': {
	        n: 23,
	        f: function(r) {
	            var x = d3.round(r*0.7,2),
	                y = d3.round(r*1.4,2);
	            return 'M0,'+y+'L'+x+',0L0,-'+y+'L-'+x+',0Z';
	        }
	    },
	    'diamond-wide': {
	        n: 24,
	        f: function(r) {
	            var x = d3.round(r*1.4,2),
	                y = d3.round(r*0.7,2);
	            return 'M0,'+y+'L'+x+',0L0,-'+y+'L-'+x+',0Z';
	        }
	    },
	    hourglass: {
	        n: 25,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M'+rs+','+rs+'H-'+rs+'L'+rs+',-'+rs+'H-'+rs+'Z';
	        },
	        noDot: true
	    },
	    bowtie: {
	        n: 26,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M'+rs+','+rs+'V-'+rs+'L-'+rs+','+rs+'V-'+rs+'Z';
	        },
	        noDot: true
	    },
	    'circle-cross': {
	        n: 27,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M0,'+rs+'V-'+rs+'M'+rs+',0H-'+rs+
	                'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+
	                'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'circle-x': {
	        n: 28,
	        f: function(r) {
	            var rs = d3.round(r,2),
	                rc = d3.round(r/Math.sqrt(2),2);
	            return 'M'+rc+','+rc+'L-'+rc+',-'+rc+
	                'M'+rc+',-'+rc+'L-'+rc+','+rc+
	                'M'+rs+',0A'+rs+','+rs+' 0 1,1 0,-'+rs+
	                'A'+rs+','+rs+' 0 0,1 '+rs+',0Z';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'square-cross': {
	        n: 29,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M0,'+rs+'V-'+rs+'M'+rs+',0H-'+rs+
	                'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'square-x': {
	        n: 30,
	        f: function(r) {
	            var rs = d3.round(r,2);
	            return 'M'+rs+','+rs+'L-'+rs+',-'+rs+
	                'M'+rs+',-'+rs+'L-'+rs+','+rs+
	                'M'+rs+','+rs+'H-'+rs+'V-'+rs+'H'+rs+'Z';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'diamond-cross': {
	        n: 31,
	        f: function(r) {
	            var rd = d3.round(r*1.3,2);
	            return 'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z'+
	                'M0,-'+rd+'V'+rd+'M-'+rd+',0H'+rd;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'diamond-x': {
	        n: 32,
	        f: function(r) {
	            var rd = d3.round(r*1.3,2),
	                r2 = d3.round(r*0.65,2);
	            return 'M'+rd+',0L0,'+rd+'L-'+rd+',0L0,-'+rd+'Z'+
	                'M-'+r2+',-'+r2+'L'+r2+','+r2+
	                'M-'+r2+','+r2+'L'+r2+',-'+r2;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'cross-thin': {
	        n: 33,
	        f: function(r) {
	            var rc = d3.round(r*1.4,2);
	            return 'M0,'+rc+'V-'+rc+'M'+rc+',0H-'+rc;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'x-thin': {
	        n: 34,
	        f: function(r) {
	            var rx = d3.round(r,2);
	            return 'M'+rx+','+rx+'L-'+rx+',-'+rx+
	                'M'+rx+',-'+rx+'L-'+rx+','+rx;
	        },
	        needLine: true,
	        noDot: true
	    },
	    asterisk: {
	        n: 35,
	        f: function(r) {
	            var rc = d3.round(r*1.2,2);
	            var rs = d3.round(r*0.85,2);
	            return 'M0,'+rc+'V-'+rc+'M'+rc+',0H-'+rc+
	                'M'+rs+','+rs+'L-'+rs+',-'+rs+
	                'M'+rs+',-'+rs+'L-'+rs+','+rs;
	        },
	        needLine: true,
	        noDot: true
	    },
	    hash: {
	        n: 36,
	        f: function(r) {
	            var r1 = d3.round(r/2,2),
	                r2 = d3.round(r,2);
	            return 'M'+r1+','+r2+'V-'+r2+
	                'm-'+r2+',0V'+r2+
	                'M'+r2+','+r1+'H-'+r2+
	                'm0,-'+r2+'H'+r2;
	        },
	        needLine: true
	    },
	    'y-up': {
	        n: 37,
	        f: function(r) {
	            var x = d3.round(r*1.2,2),
	                y0 = d3.round(r*1.6,2),
	                y1 = d3.round(r*0.8,2);
	            return 'M-'+x+','+y1+'L0,0M'+x+','+y1+'L0,0M0,-'+y0+'L0,0';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'y-down': {
	        n: 38,
	        f: function(r) {
	            var x = d3.round(r*1.2,2),
	                y0 = d3.round(r*1.6,2),
	                y1 = d3.round(r*0.8,2);
	            return 'M-'+x+',-'+y1+'L0,0M'+x+',-'+y1+'L0,0M0,'+y0+'L0,0';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'y-left': {
	        n: 39,
	        f: function(r) {
	            var y = d3.round(r*1.2,2),
	                x0 = d3.round(r*1.6,2),
	                x1 = d3.round(r*0.8,2);
	            return 'M'+x1+','+y+'L0,0M'+x1+',-'+y+'L0,0M-'+x0+',0L0,0';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'y-right': {
	        n: 40,
	        f: function(r) {
	            var y = d3.round(r*1.2,2),
	                x0 = d3.round(r*1.6,2),
	                x1 = d3.round(r*0.8,2);
	            return 'M-'+x1+','+y+'L0,0M-'+x1+',-'+y+'L0,0M'+x0+',0L0,0';
	        },
	        needLine: true,
	        noDot: true
	    },
	    'line-ew': {
	        n: 41,
	        f: function(r) {
	            var rc = d3.round(r*1.4,2);
	            return 'M'+rc+',0H-'+rc;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'line-ns': {
	        n: 42,
	        f: function(r) {
	            var rc = d3.round(r*1.4,2);
	            return 'M0,'+rc+'V-'+rc;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'line-ne': {
	        n: 43,
	        f: function(r) {
	            var rx = d3.round(r,2);
	            return 'M'+rx+',-'+rx+'L-'+rx+','+rx;
	        },
	        needLine: true,
	        noDot: true
	    },
	    'line-nw': {
	        n: 44,
	        f: function(r) {
	            var rx = d3.round(r,2);
	            return 'M'+rx+','+rx+'L-'+rx+',-'+rx;
	        },
	        needLine: true,
	        noDot: true
	    }
	};


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	var Color = __webpack_require__(333);
	
	var RangeSlider = __webpack_require__(364);
	var RangeSelector = __webpack_require__(369);
	
	var constants = __webpack_require__(352);
	var layoutAttributes = __webpack_require__(348);
	var handleAxisDefaults = __webpack_require__(376);
	var handlePositionDefaults = __webpack_require__(381);
	var axisIds = __webpack_require__(373);
	
	
	module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
	    var layoutKeys = Object.keys(layoutIn),
	        xaListCartesian = [],
	        yaListCartesian = [],
	        xaListGl2d = [],
	        yaListGl2d = [],
	        outerTicks = {},
	        noGrids = {},
	        i;
	
	    // look for axes in the data
	    for(i = 0; i < fullData.length; i++) {
	        var trace = fullData[i];
	        var listX, listY;
	
	        if(Plots.traceIs(trace, 'cartesian')) {
	            listX = xaListCartesian;
	            listY = yaListCartesian;
	        }
	        else if(Plots.traceIs(trace, 'gl2d')) {
	            listX = xaListGl2d;
	            listY = yaListGl2d;
	        }
	        else continue;
	
	        var xaName = axisIds.id2name(trace.xaxis),
	            yaName = axisIds.id2name(trace.yaxis);
	
	        // add axes implied by traces
	        if(xaName && listX.indexOf(xaName) === -1) listX.push(xaName);
	        if(yaName && listY.indexOf(yaName) === -1) listY.push(yaName);
	
	        // check for default formatting tweaks
	        if(Plots.traceIs(trace, '2dMap')) {
	            outerTicks[xaName] = true;
	            outerTicks[yaName] = true;
	        }
	
	        if(Plots.traceIs(trace, 'oriented')) {
	            var positionAxis = trace.orientation === 'h' ? yaName : xaName;
	            noGrids[positionAxis] = true;
	        }
	    }
	
	    // N.B. Ignore orphan axes (i.e. axes that have no data attached to them)
	    // if gl3d or geo is present on graph. This is retain backward compatible.
	    //
	    // TODO drop this in version 2.0
	    var ignoreOrphan = (layoutOut._has('gl3d') || layoutOut._has('geo'));
	
	    if(!ignoreOrphan) {
	        for(i = 0; i < layoutKeys.length; i++) {
	            var key = layoutKeys[i];
	
	            // orphan layout axes are considered cartesian subplots
	
	            if(xaListGl2d.indexOf(key) === -1 &&
	                xaListCartesian.indexOf(key) === -1 &&
	                    constants.xAxisMatch.test(key)) {
	                xaListCartesian.push(key);
	            }
	            else if(yaListGl2d.indexOf(key) === -1 &&
	                yaListCartesian.indexOf(key) === -1 &&
	                    constants.yAxisMatch.test(key)) {
	                yaListCartesian.push(key);
	            }
	        }
	    }
	
	    // make sure that plots with orphan cartesian axes
	    // are considered 'cartesian'
	    if(xaListCartesian.length && yaListCartesian.length) {
	        Lib.pushUnique(layoutOut._basePlotModules, Plots.subplotsRegistry.cartesian);
	    }
	
	    function axSort(a, b) {
	        var aNum = Number(a.substr(5) || 1),
	            bNum = Number(b.substr(5) || 1);
	        return aNum - bNum;
	    }
	
	    var xaList = xaListCartesian.concat(xaListGl2d).sort(axSort),
	        yaList = yaListCartesian.concat(yaListGl2d).sort(axSort),
	        axesList = xaList.concat(yaList);
	
	    // plot_bgcolor only makes sense if there's a (2D) plot!
	    // TODO: bgcolor for each subplot, to inherit from the main one
	    var plot_bgcolor = Color.background;
	    if(xaList.length && yaList.length) {
	        plot_bgcolor = Lib.coerce(layoutIn, layoutOut, Plots.layoutAttributes, 'plot_bgcolor');
	    }
	
	    var bgColor = Color.combine(plot_bgcolor, layoutOut.paper_bgcolor);
	
	    axesList.forEach(function(axName) {
	        var axLetter = axName.charAt(0),
	            axLayoutIn = layoutIn[axName] || {},
	            axLayoutOut = {},
	            defaultOptions = {
	                letter: axLetter,
	                font: layoutOut.font,
	                outerTicks: outerTicks[axName],
	                showGrid: !noGrids[axName],
	                name: axName,
	                data: fullData,
	                bgColor: bgColor
	            },
	            positioningOptions = {
	                letter: axLetter,
	                counterAxes: {x: yaList, y: xaList}[axLetter].map(axisIds.name2id),
	                overlayableAxes: {x: xaList, y: yaList}[axLetter].filter(function(axName2) {
	                    return axName2!==axName && !(layoutIn[axName2]||{}).overlaying;
	                }).map(axisIds.name2id)
	            };
	
	        function coerce(attr, dflt) {
	            return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
	        }
	
	        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);
	        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, positioningOptions);
	
	        layoutOut[axName] = axLayoutOut;
	
	        // so we don't have to repeat autotype unnecessarily,
	        // copy an autotype back to layoutIn
	        if(!layoutIn[axName] && axLayoutIn.type !== '-') {
	            layoutIn[axName] = {type: axLayoutIn.type};
	        }
	
	    });
	
	    // quick second pass for range slider and selector defaults
	    axesList.forEach(function(axName) {
	        var axLetter = axName.charAt(0),
	            axLayoutIn = layoutIn[axName],
	            axLayoutOut = layoutOut[axName],
	            counterAxes = {x: yaList, y: xaList}[axLetter];
	
	        RangeSlider.supplyLayoutDefaults(layoutIn, layoutOut, axName, counterAxes);
	
	        if(axLetter === 'x' && axLayoutOut.type === 'date') {
	            RangeSelector.supplyLayoutDefaults(axLayoutIn, axLayoutOut, layoutOut, counterAxes);
	        }
	    });
	};


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	var Plots = __webpack_require__(332);
	
	var createSlider = __webpack_require__(365);
	var supplyLayoutDefaults = __webpack_require__(368);
	
	
	module.exports = {
	    draw: draw,
	    supplyLayoutDefaults: supplyLayoutDefaults
	};
	
	function draw(gd) {
	    if(!gd._fullLayout.xaxis) return;
	
	    var fullLayout = gd._fullLayout,
	        sliderContainer = fullLayout._infolayer.selectAll('g.range-slider'),
	        options = fullLayout.xaxis.rangeslider;
	
	
	    if(!options || !options.visible) {
	        sliderContainer.data([])
	            .exit().remove();
	
	        Plots.autoMargin(gd, 'range-slider');
	
	        return;
	    }
	
	
	    var height = (fullLayout.height - fullLayout.margin.b - fullLayout.margin.t) * options.thickness,
	        offsetShift = Math.floor(options.borderwidth / 2);
	
	    if(sliderContainer[0].length === 0 && !fullLayout._has('gl2d')) createSlider(gd);
	
	    // Need to default to 0 for when making gl plots
	    var bb = fullLayout.xaxis._boundingBox ?
	        fullLayout.xaxis._boundingBox.height : 0;
	
	    Plots.autoMargin(gd, 'range-slider', {
	        x: 0, y: 0, l: 0, r: 0, t: 0,
	        b: height + fullLayout.margin.b + bb,
	        pad: 15 + offsetShift * 2
	    });
	}


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	var Plotly = __webpack_require__(304);
	var Axes = __webpack_require__(338);
	var Lib = __webpack_require__(309);
	
	var svgNS = __webpack_require__(327).svg;
	
	var helpers = __webpack_require__(366);
	var rangePlot = __webpack_require__(367);
	
	
	module.exports = function createSlider(gd) {
	    var fullLayout = gd._fullLayout,
	        sliderContainer = fullLayout._infolayer.selectAll('g.range-slider'),
	        options = fullLayout.xaxis.rangeslider,
	        width = fullLayout._size.w,
	        height = (fullLayout.height - fullLayout.margin.b - fullLayout.margin.t) * options.thickness,
	        handleWidth = 2,
	        offsetShift = Math.floor(options.borderwidth / 2),
	        x = fullLayout.margin.l,
	        y = fullLayout.height - height - fullLayout.margin.b;
	
	    var minStart = 0,
	        maxStart = width;
	
	    var slider = document.createElementNS(svgNS, 'g');
	    helpers.setAttributes(slider, {
	        'class': 'range-slider',
	        'data-min': minStart,
	        'data-max': maxStart,
	        'pointer-events': 'all',
	        'transform': 'translate(' + x + ',' + y + ')'
	    });
	
	
	    var sliderBg = document.createElementNS(svgNS, 'rect'),
	        borderCorrect = options.borderwidth % 2 === 0 ? options.borderwidth : options.borderwidth - 1;
	    helpers.setAttributes(sliderBg, {
	        'fill': options.bgcolor,
	        'stroke': options.bordercolor,
	        'stroke-width': options.borderwidth,
	        'height': height + borderCorrect,
	        'width': width + borderCorrect,
	        'transform': 'translate(-' + offsetShift + ', -' + offsetShift + ')',
	        'shape-rendering': 'crispEdges'
	    });
	
	
	    var maskMin = document.createElementNS(svgNS, 'rect');
	    helpers.setAttributes(maskMin, {
	        'x': 0,
	        'width': minStart,
	        'height': height,
	        'fill': 'rgba(0,0,0,0.4)'
	    });
	
	
	    var maskMax = document.createElementNS(svgNS, 'rect');
	    helpers.setAttributes(maskMax, {
	        'x': maxStart,
	        'width': width - maxStart,
	        'height': height,
	        'fill': 'rgba(0,0,0,0.4)'
	    });
	
	
	    var grabberMin = document.createElementNS(svgNS, 'g'),
	        grabAreaMin = document.createElementNS(svgNS, 'rect'),
	        handleMin = document.createElementNS(svgNS, 'rect');
	    helpers.setAttributes(grabberMin, { 'transform': 'translate(' + (minStart - handleWidth - 1) + ')' });
	    helpers.setAttributes(grabAreaMin, {
	        'width': 10,
	        'height': height,
	        'x': -6,
	        'fill': 'transparent',
	        'cursor': 'col-resize'
	    });
	    helpers.setAttributes(handleMin, {
	        'width': handleWidth,
	        'height': height / 2,
	        'y': height / 4,
	        'rx': 1,
	        'fill': 'white',
	        'stroke': '#666',
	        'shape-rendering': 'crispEdges'
	    });
	    helpers.appendChildren(grabberMin, [handleMin, grabAreaMin]);
	
	
	    var grabberMax = document.createElementNS(svgNS, 'g'),
	        grabAreaMax = document.createElementNS(svgNS, 'rect'),
	        handleMax = document.createElementNS(svgNS, 'rect');
	    helpers.setAttributes(grabberMax, { 'transform': 'translate(' + maxStart + ')' });
	    helpers.setAttributes(grabAreaMax, {
	        'width': 10,
	        'height': height,
	        'x': -2,
	        'fill': 'transparent',
	        'cursor': 'col-resize'
	    });
	    helpers.setAttributes(handleMax, {
	        'width': handleWidth,
	        'height': height / 2,
	        'y': height / 4,
	        'rx': 1,
	        'fill': 'white',
	        'stroke': '#666',
	        'shape-rendering': 'crispEdges'
	    });
	    helpers.appendChildren(grabberMax, [handleMax, grabAreaMax]);
	
	
	    var slideBox = document.createElementNS(svgNS, 'rect');
	    helpers.setAttributes(slideBox, {
	        'x': minStart,
	        'width': maxStart - minStart,
	        'height': height,
	        'cursor': 'ew-resize',
	        'fill': 'transparent'
	    });
	
	
	    slider.addEventListener('mousedown', function(event) {
	        var target = event.target,
	            startX = event.clientX,
	            offsetX = startX - slider.getBoundingClientRect().left,
	            minVal = slider.getAttribute('data-min'),
	            maxVal = slider.getAttribute('data-max');
	
	        window.addEventListener('mousemove', mouseMove);
	        window.addEventListener('mouseup', mouseUp);
	
	        function mouseMove(e) {
	            var delta = +e.clientX - startX;
	
	            switch(target) {
	                case slideBox:
	                    slider.style.cursor = 'ew-resize';
	                    setPixelRange(+maxVal + delta, +minVal + delta);
	                    break;
	
	                case grabAreaMin:
	                    slider.style.cursor = 'col-resize';
	                    setPixelRange(+minVal + delta, +maxVal);
	                    break;
	
	                case grabAreaMax:
	                    slider.style.cursor = 'col-resize';
	                    setPixelRange(+minVal, +maxVal + delta);
	                    break;
	
	                default:
	                    slider.style.cursor = 'ew-resize';
	                    setPixelRange(offsetX, offsetX + delta);
	                    break;
	            }
	        }
	
	        function mouseUp() {
	            window.removeEventListener('mousemove', mouseMove);
	            window.removeEventListener('mouseup', mouseUp);
	            slider.style.cursor = 'auto';
	        }
	    });
	
	
	    function setRange(min, max) {
	        min = min || -Infinity;
	        max = max || Infinity;
	
	        var rangeMin = options.range[0],
	            rangeMax = options.range[1],
	            range = rangeMax - rangeMin,
	            pixelMin = (min - rangeMin) / range * width,
	            pixelMax = (max - rangeMin) / range * width;
	
	        setPixelRange(pixelMin, pixelMax);
	    }
	
	
	    function setPixelRange(min, max) {
	
	        min = Lib.constrain(min, 0, width);
	        max = Lib.constrain(max, 0, width);
	
	        if(max < min) {
	            var temp = max;
	            max = min;
	            min = temp;
	        }
	
	        helpers.setAttributes(slider, {
	            'data-min': min,
	            'data-max': max
	        });
	
	        helpers.setAttributes(slideBox, {
	            'x': min,
	            'width': max - min
	        });
	
	        helpers.setAttributes(maskMin, { 'width': min });
	        helpers.setAttributes(maskMax, {
	            'x': max,
	            'width': width - max
	        });
	
	        helpers.setAttributes(grabberMin, { 'transform': 'translate(' + (min - handleWidth - 1) + ')' });
	        helpers.setAttributes(grabberMax, { 'transform': 'translate(' + max + ')' });
	
	        var rangeMin = options.range[0],
	            rangeMax = options.range[1],
	            range = rangeMax - rangeMin,
	            dataMin = min / width * range + rangeMin,
	            dataMax = max / width * range + rangeMin;
	
	        if(window.requestAnimationFrame) {
	            window.requestAnimationFrame(function() {
	                Plotly.relayout(gd, 'xaxis.range', [dataMin, dataMax]);
	            });
	        } else {
	            setTimeout(function() {
	                Plotly.relayout(gd, 'xaxis.range', [dataMin, dataMax]);
	            }, 16);
	        }
	    }
	
	
	    // Set slider range using axis autorange if necessary.
	    if(!options.range) {
	        options.range = Axes.getAutoRange(fullLayout.xaxis);
	    }
	
	    var rangePlots = rangePlot(gd, width, height);
	
	    helpers.appendChildren(slider, [
	        sliderBg,
	        rangePlots,
	        maskMin,
	        maskMax,
	        slideBox,
	        grabberMin,
	        grabberMax
	    ]);
	
	    // Set initially selected range
	    setRange(fullLayout.xaxis.range[0], fullLayout.xaxis.range[1]);
	
	    sliderContainer.data([0])
	        .enter().append(function() {
	            options.setRange = setRange;
	            return slider;
	        });
	};


/***/ },
/* 366 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	exports.setAttributes = function setAttributes(el, attributes) {
	    for(var key in attributes) {
	        el.setAttribute(key, attributes[key]);
	    }
	};
	
	
	exports.appendChildren = function appendChildren(el, children) {
	    for(var i = 0; i < children.length; i++) {
	        if(children[i]) {
	            el.appendChild(children[i]);
	        }
	    }
	};


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Symbols = __webpack_require__(362);
	var Drawing = __webpack_require__(340);
	
	var helpers = __webpack_require__(366);
	var svgNS = __webpack_require__(327).svg;
	
	module.exports = function rangePlot(gd, w, h) {
	
	    var fullLayout = gd._fullLayout,
	        traces = gd._fullData,
	        xaxis = fullLayout.xaxis,
	        yaxis = fullLayout.yaxis,
	        minX = xaxis.rangeslider.range[0],
	        maxX = xaxis.rangeslider.range[1],
	        minY = yaxis.range[0],
	        maxY = yaxis.range[1];
	
	
	    // create elements for plot and its clip
	    var clipPath = document.createElementNS(svgNS, 'path');
	    clipPath.setAttribute('d', ['M0,0', w + ',0', w + ',' + h, '0,' + h, 'Z'].join(' '));
	
	    var clip = document.createElementNS(svgNS, 'clipPath');
	    clip.setAttribute('id', 'range-clip-path');
	    clip.appendChild(clipPath);
	
	    var clipDefs = document.createElementNS(svgNS, 'defs');
	    clipDefs.appendChild(clip);
	
	    var rangePlot = document.createElementNS(svgNS, 'g');
	    d3.select(rangePlot).call(Drawing.setClipUrl, 'range-clip-path');
	    rangePlot.appendChild(clipDefs);
	
	
	    // for now, only scatter traces are supported
	    var allowedTypes = ['scatter'];
	
	    for(var i = 0; i < traces.length; i++) {
	
	        var trace = traces[i],
	            pointPairs = [];
	
	        if(allowedTypes.indexOf(trace.type) < 0) {
	            console.log('Trace type ' + trace.type + ' not supported for range slider!');
	            continue;
	        }
	
	        var x = makeLinearData(trace, xaxis),
	            y = makeLinearData(trace, yaxis);
	
	        for(var k = 0; k < x.length; k++) {
	
	            var posX = w * (x[k] - minX) / (maxX - minX),
	                posY = h * (1 - (y[k] - minY) / (maxY - minY));
	
	            if(!isNaN(posX) && !isNaN(posY)) {
	                pointPairs.push([posX, posY]);
	            }
	        }
	
	        // more trace type range plots can be added here
	        helpers.appendChildren(rangePlot, makeScatter(trace, pointPairs, w, h));
	    }
	
	
	    return rangePlot;
	};
	
	function makeLinearData(trace, axis) {
	    var data = axis.makeCalcdata(trace || [], axis._id[0]);
	
	    for(var i = 0; i < data.length; i++) {
	        data[i] = axis.c2l(data[i]);
	    }
	
	    return data;
	}
	
	
	function makeScatter(trace, pointPairs, w, h) {
	
	    // create the line
	    var line, markers, fill;
	
	    if(trace.line) {
	        line = document.createElementNS(svgNS, 'path');
	
	        var linePath = Drawing.smoothopen(pointPairs, trace.line.smoothing || 0);
	
	        helpers.setAttributes(line, {
	            'd': linePath,
	            'fill': 'none',
	            'stroke': trace.line ? trace.line.color : 'transparent',
	            'stroke-width': trace.line.width / 2 || 1,
	            'opacity': 1
	        });
	    }
	
	    // create points if there's markers
	    if(trace.marker) {
	        markers = document.createElementNS(svgNS, 'g');
	
	        var points = pointPairs.map(function(p, i) {
	            var point = document.createElementNS(svgNS, 'g'),
	                symbol = document.createElementNS(svgNS, 'path'),
	                size;
	
	            if(Array.isArray(trace.marker.size)) {
	                size = typeof trace.marker.size[i] === 'number' ?
	                    Math.max(trace.marker.size[i] / (trace.marker.sizeref || 1) / 15, 0) :
	                    0;
	            } else {
	                size = Math.max(trace.marker.size / 15, 2);
	            }
	
	            helpers.setAttributes(symbol, {
	                'd': Symbols[trace.marker.symbol].f(size),
	                'fill': trace.marker.color,
	                'stroke': trace.marker.line.color,
	                'stroke-width': trace.marker.line.width,
	                'opacity': trace.marker.opacity
	            });
	
	            helpers.setAttributes(point, {
	                'transform': 'translate(' + p[0] + ',' + p[1] + ')'
	            });
	
	            point.appendChild(symbol);
	
	            return point;
	        });
	
	        helpers.appendChildren(markers, points);
	    }
	
	
	    // create fill if set
	    if(trace.fill !== 'none') {
	        fill = document.createElementNS(svgNS, 'path');
	
	        switch(trace.fill) {
	            case 'tozeroy':
	                pointPairs.unshift([pointPairs[0][0], h]);
	                pointPairs.push([pointPairs[pointPairs.length - 1][0], h]);
	                break;
	
	            case 'tozerox':
	                pointPairs.unshift([0, pointPairs[pointPairs.length - 1][1]]);
	                break;
	
	            default:
	                console.log('Fill type ' + trace.fill + ' not supported for range slider! (yet...)');
	                break;
	        }
	
	        var fillPath = Drawing.smoothopen(pointPairs, trace.line.smoothing || 0);
	
	        helpers.setAttributes(fill, {
	            'd': fillPath,
	            'fill': trace.fillcolor || 'transparent'
	        });
	    }
	
	
	    return [line, markers, fill];
	}


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var attributes = __webpack_require__(349);
	
	
	module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, axName, counterAxes) {
	
	    if(!layoutIn[axName].rangeslider) return;
	
	    var containerIn = typeof layoutIn[axName].rangeslider === 'object' ?
	            layoutIn[axName].rangeslider : {},
	        containerOut = layoutOut[axName].rangeslider = {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
	    }
	
	    coerce('bgcolor');
	    coerce('bordercolor');
	    coerce('borderwidth');
	    coerce('thickness');
	    coerce('visible');
	    coerce('range');
	
	    // Expand slider range to the axis range
	    if(containerOut.range && !layoutOut[axName].autorange) {
	        var outRange = containerOut.range,
	            axRange = layoutOut[axName].range;
	
	        outRange[0] = Math.min(outRange[0], axRange[0]);
	        outRange[1] = Math.max(outRange[1], axRange[1]);
	    } else {
	        layoutOut[axName]._needsExpand = true;
	    }
	
	    if(containerOut.visible) {
	        counterAxes.forEach(function(ax) {
	            var opposing = layoutOut[ax] || {};
	            opposing.fixedrange = true;
	            layoutOut[ax] = opposing;
	        });
	    }
	};


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	exports.attributes = __webpack_require__(350);
	
	exports.supplyLayoutDefaults = __webpack_require__(370);
	
	exports.draw = __webpack_require__(372);


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	var attributes = __webpack_require__(350);
	var buttonAttrs = __webpack_require__(351);
	var constants = __webpack_require__(371);
	
	
	module.exports = function rangeSelectorDefaults(containerIn, containerOut, layout, counterAxes) {
	    var selectorIn = containerIn.rangeselector || {},
	        selectorOut = containerOut.rangeselector = {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
	    }
	
	    var buttons = buttonsDefaults(selectorIn, selectorOut);
	
	    var visible = coerce('visible', buttons.length > 0);
	    if(!visible) return;
	
	    var posDflt = getPosDflt(containerOut, layout, counterAxes);
	    coerce('x', posDflt[0]);
	    coerce('y', posDflt[1]);
	    Lib.noneOrAll(containerIn, containerOut, ['x', 'y']);
	
	    coerce('xanchor');
	    coerce('yanchor');
	
	    Lib.coerceFont(coerce, 'font', layout.font);
	
	    coerce('bgcolor');
	    coerce('bordercolor');
	    coerce('borderwidth');
	};
	
	function buttonsDefaults(containerIn, containerOut) {
	    var buttonsIn = containerIn.buttons || [],
	        buttonsOut = containerOut.buttons = [];
	
	    var buttonIn, buttonOut;
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
	    }
	
	    for(var i = 0; i < buttonsIn.length; i++) {
	        buttonIn = buttonsIn[i];
	        buttonOut = {};
	
	        var step = coerce('step');
	        if(step !== 'all') {
	            coerce('stepmode');
	            coerce('count');
	        }
	
	        coerce('label');
	
	        buttonsOut.push(buttonOut);
	    }
	
	    return buttonsOut;
	}
	
	function getPosDflt(containerOut, layout, counterAxes) {
	    var anchoredList = counterAxes.filter(function(ax) {
	        return layout[ax].anchor === containerOut._id;
	    });
	
	    var posY = 0;
	    for(var i = 0; i < anchoredList.length; i++) {
	        posY = Math.max(layout[anchoredList[i]].domain[1], posY);
	    }
	
	    return [containerOut.domain[0], posY + constants.yPad];
	}


/***/ },
/* 371 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	
	    // 'y' position pad above counter axis domain
	    yPad: 0.02,
	
	    // minimum button width (regardless of text size)
	    minButtonWidth: 30,
	
	    // buttons rect radii
	    rx: 3,
	    ry: 3,
	
	    // color given to active and hovered buttons
	    activeColor: '#d3d3d3'
	};


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Plotly = __webpack_require__(304);
	var Plots = __webpack_require__(332);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var svgTextUtils = __webpack_require__(326);
	var axisIds = __webpack_require__(373);
	var anchorUtils = __webpack_require__(374);
	
	var constants = __webpack_require__(371);
	var getUpdateObject = __webpack_require__(375);
	
	
	module.exports = function draw(gd) {
	    var fullLayout = gd._fullLayout;
	
	    var selectors = fullLayout._infolayer.selectAll('.rangeselector')
	        .data(makeSelectorData(gd), selectorKeyFunc);
	
	    selectors.enter().append('g')
	        .classed('rangeselector', true);
	
	    selectors.exit().remove();
	
	    selectors.style({
	        cursor: 'pointer',
	        'pointer-events': 'all'
	    });
	
	    selectors.each(function(d) {
	        var selector = d3.select(this),
	            axisLayout = d,
	            selectorLayout = axisLayout.rangeselector;
	
	        var buttons = selector.selectAll('g.button')
	            .data(selectorLayout.buttons);
	
	        buttons.enter().append('g')
	            .classed('button', true);
	
	        buttons.exit().remove();
	
	        buttons.each(function(d) {
	            var button = d3.select(this);
	            var update = getUpdateObject(axisLayout, d);
	
	            d.isActive = isActive(axisLayout, d, update);
	
	            button.call(drawButtonRect, selectorLayout, d);
	            button.call(drawButtonText, selectorLayout, d);
	
	            button.on('click', function() {
	                if(gd._dragged) return;
	
	                Plotly.relayout(gd, update);
	            });
	
	            button.on('mouseover', function() {
	                d.isHovered = true;
	                button.call(drawButtonRect, selectorLayout, d);
	            });
	
	            button.on('mouseout', function() {
	                d.isHovered = false;
	                button.call(drawButtonRect, selectorLayout, d);
	            });
	        });
	
	        // N.B. this mutates selectorLayout
	        reposition(gd, buttons, selectorLayout, axisLayout._name);
	
	        selector.attr('transform', 'translate(' +
	            selectorLayout.lx + ',' + selectorLayout.ly +
	        ')');
	    });
	
	};
	
	function makeSelectorData(gd) {
	    var axes = axisIds.list(gd, 'x', true);
	    var data = [];
	
	    for(var i = 0; i < axes.length; i++) {
	        var axis = axes[i];
	
	        if(axis.rangeselector && axis.rangeselector.visible) {
	            data.push(axis);
	        }
	    }
	
	    return data;
	}
	
	function selectorKeyFunc(d) {
	    return d._id;
	}
	
	function isActive(axisLayout, opts, update) {
	    if(opts.step === 'all') {
	        return axisLayout.autorange === true;
	    }
	    else {
	        var keys = Object.keys(update);
	
	        return (
	            axisLayout.range[0] === update[keys[0]] &&
	            axisLayout.range[1] === update[keys[1]]
	        );
	    }
	}
	
	function drawButtonRect(button, selectorLayout, d) {
	    var rect = button.selectAll('rect')
	        .data([0]);
	
	    rect.enter().append('rect')
	        .classed('selector-rect', true);
	
	    rect.attr('shape-rendering', 'crispEdges');
	
	    rect.attr({
	        'rx': constants.rx,
	        'ry': constants.ry
	    });
	
	    rect.call(Color.stroke, selectorLayout.bordercolor)
	        .call(Color.fill, getFillColor(selectorLayout, d))
	        .style('stroke-width', selectorLayout.borderwidth + 'px');
	}
	
	function getFillColor(selectorLayout, d) {
	    return (d.isActive || d.isHovered) ?
	        constants.activeColor :
	        selectorLayout.bgcolor;
	}
	
	function drawButtonText(button, selectorLayout, d) {
	    function textLayout(s) {
	        svgTextUtils.convertToTspans(s);
	
	        // TODO do we need anything else here?
	    }
	
	    var text = button.selectAll('text')
	        .data([0]);
	
	    text.enter().append('text')
	        .classed('selector-text', true)
	        .classed('user-select-none', true);
	
	    text.attr('text-anchor', 'middle');
	
	    text.call(Drawing.font, selectorLayout.font)
	        .text(getLabel(d))
	        .call(textLayout);
	}
	
	function getLabel(opts) {
	    if(opts.label) return opts.label;
	
	    if(opts.step === 'all') return 'all';
	
	    return opts.count + opts.step.charAt(0);
	}
	
	function reposition(gd, buttons, opts, axName) {
	    opts.width = 0;
	    opts.height = 0;
	
	    var borderWidth = opts.borderwidth;
	
	    buttons.each(function() {
	        var button = d3.select(this),
	            text = button.select('.selector-text'),
	            tspans = text.selectAll('tspan');
	
	        var tHeight = opts.font.size * 1.3,
	            tLines = tspans[0].length || 1,
	            hEff = Math.max(tHeight * tLines, 16) + 3;
	
	        opts.height = Math.max(opts.height, hEff);
	    });
	
	    buttons.each(function() {
	        var button = d3.select(this),
	            rect = button.select('.selector-rect'),
	            text = button.select('.selector-text'),
	            tspans = text.selectAll('tspan');
	
	        var tWidth = text.node() && Drawing.bBox(text.node()).width,
	            tHeight = opts.font.size * 1.3,
	            tLines = tspans[0].length || 1;
	
	        var wEff = Math.max(tWidth + 10, constants.minButtonWidth);
	
	        // TODO add MathJax support
	
	        // TODO add buttongap attribute
	
	        button.attr('transform', 'translate(' +
	            (borderWidth + opts.width) + ',' + borderWidth +
	        ')');
	
	        rect.attr({
	            x: 0,
	            y: 0,
	            width: wEff,
	            height: opts.height
	        });
	
	        var textAttrs = {
	            x: wEff / 2,
	            y: opts.height / 2 - ((tLines - 1) * tHeight / 2) + 3
	        };
	
	        text.attr(textAttrs);
	        tspans.attr(textAttrs);
	
	        opts.width += wEff + 5;
	    });
	
	    buttons.selectAll('rect').attr('height', opts.height);
	
	    var graphSize = gd._fullLayout._size;
	    opts.lx = graphSize.l + graphSize.w * opts.x;
	    opts.ly = graphSize.t + graphSize.h * (1 - opts.y);
	
	    var xanchor = 'left';
	    if(anchorUtils.isRightAnchor(opts)) {
	        opts.lx -= opts.width;
	        xanchor = 'right';
	    }
	    if(anchorUtils.isCenterAnchor(opts)) {
	        opts.lx -= opts.width / 2;
	        xanchor = 'center';
	    }
	
	    var yanchor = 'top';
	    if(anchorUtils.isBottomAnchor(opts)) {
	        opts.ly -= opts.height;
	        yanchor = 'bottom';
	    }
	    if(anchorUtils.isMiddleAnchor(opts)) {
	        opts.ly -= opts.height / 2;
	        yanchor = 'middle';
	    }
	
	    opts.width = Math.ceil(opts.width);
	    opts.height = Math.ceil(opts.height);
	    opts.lx = Math.round(opts.lx);
	    opts.ly = Math.round(opts.ly);
	
	    Plots.autoMargin(gd, axName + '-range-selector', {
	        x: opts.x,
	        y: opts.y,
	        l: opts.width * ({right: 1, center: 0.5}[xanchor] || 0),
	        r: opts.width * ({left: 1, center: 0.5}[xanchor] || 0),
	        b: opts.height * ({top: 1, middle: 0.5}[yanchor] || 0),
	        t: opts.height * ({bottom: 1, middle: 0.5}[yanchor] || 0)
	    });
	}


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Plots = __webpack_require__(332);
	var Lib = __webpack_require__(309);
	
	var constants = __webpack_require__(352);
	
	
	// convert between axis names (xaxis, xaxis2, etc, elements of gd.layout)
	// and axis id's (x, x2, etc). Would probably have ditched 'xaxis'
	// completely in favor of just 'x' if it weren't ingrained in the API etc.
	exports.id2name = function id2name(id) {
	    if(typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;
	    var axNum = id.substr(1);
	    if(axNum === '1') axNum = '';
	    return id.charAt(0) + 'axis' + axNum;
	};
	
	exports.name2id = function name2id(name) {
	    if(!name.match(constants.AX_NAME_PATTERN)) return;
	    var axNum = name.substr(5);
	    if(axNum === '1') axNum = '';
	    return name.charAt(0) + axNum;
	};
	
	exports.cleanId = function cleanId(id, axLetter) {
	    if(!id.match(constants.AX_ID_PATTERN)) return;
	    if(axLetter && id.charAt(0) !== axLetter) return;
	
	    var axNum = id.substr(1).replace(/^0+/,'');
	    if(axNum === '1') axNum = '';
	    return id.charAt(0) + axNum;
	};
	
	// get all axis object names
	// optionally restricted to only x or y or z by string axLetter
	// and optionally 2D axes only, not those inside 3D scenes
	function listNames(gd, axLetter, only2d) {
	    var fullLayout = gd._fullLayout;
	    if(!fullLayout) return [];
	
	    function filterAxis(obj, extra) {
	        var keys = Object.keys(obj),
	            axMatch = /^[xyz]axis[0-9]*/,
	            out = [];
	
	        for(var i = 0; i < keys.length; i++) {
	            var k = keys[i];
	            if(axLetter && k.charAt(0) !== axLetter) continue;
	            if(axMatch.test(k)) out.push(extra + k);
	        }
	
	        return out.sort();
	    }
	
	    var names = filterAxis(fullLayout, '');
	    if(only2d) return names;
	
	    var sceneIds3D = Plots.getSubplotIds(fullLayout, 'gl3d') || [];
	    for(var i = 0; i < sceneIds3D.length; i++) {
	        var sceneId = sceneIds3D[i];
	        names = names.concat(
	            filterAxis(fullLayout[sceneId], sceneId + '.')
	        );
	    }
	
	    return names;
	}
	
	// get all axis objects, as restricted in listNames
	exports.list = function(gd, axletter, only2d) {
	    return listNames(gd, axletter, only2d)
	        .map(function(axName) {
	            return Lib.nestedProperty(gd._fullLayout, axName).get();
	        });
	};
	
	// get all axis ids, optionally restricted by letter
	// this only makes sense for 2d axes
	exports.listIds = function(gd, axletter) {
	    return listNames(gd, axletter, true).map(exports.name2id);
	};
	
	// get an axis object from its id 'x','x2' etc
	// optionally, id can be a subplot (ie 'x2y3') and type gets x or y from it
	exports.getFromId = function(gd, id, type) {
	    var fullLayout = gd._fullLayout;
	
	    if(type === 'x') id = id.replace(/y[0-9]*/,'');
	    else if(type === 'y') id = id.replace(/x[0-9]*/,'');
	
	    return fullLayout[exports.id2name(id)];
	};
	
	// get an axis object of specified type from the containing trace
	exports.getFromTrace = function(gd, fullTrace, type) {
	    var fullLayout = gd._fullLayout;
	    var ax = null;
	
	    if(Plots.traceIs(fullTrace, 'gl3d')) {
	        var scene = fullTrace.scene;
	        if(scene.substr(0, 5) === 'scene') {
	            ax = fullLayout[scene][type + 'axis'];
	        }
	    }
	    else {
	        ax = exports.getFromId(gd, fullTrace[type + 'axis'] || type);
	    }
	
	    return ax;
	};


/***/ },
/* 374 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	/**
	 * Determine the position anchor property of x/y xanchor/yanchor components.
	 *
	 * - values < 1/3 align the low side at that fraction,
	 * - values [1/3, 2/3] align the center at that fraction,
	 * - values > 2/3 align the right at that fraction.
	 */
	
	exports.isRightAnchor = function isRightAnchor(opts) {
	    return (
	        opts.xanchor === 'right' ||
	        (opts.xanchor === 'auto' && opts.x >= 2 / 3)
	    );
	};
	
	exports.isCenterAnchor = function isCenterAnchor(opts) {
	    return (
	        opts.xanchor === 'center' ||
	        (opts.xanchor === 'auto' && opts.x > 1 / 3 && opts.x < 2 / 3)
	    );
	};
	
	exports.isBottomAnchor = function isBottomAnchor(opts) {
	    return (
	        opts.yanchor === 'bottom' ||
	        (opts.yanchor === 'auto' && opts.y <= 1 / 3)
	    );
	};
	
	exports.isMiddleAnchor = function isMiddleAnchor(opts) {
	    return (
	        opts.yanchor === 'middle' ||
	        (opts.yanchor === 'auto' && opts.y > 1 / 3 && opts.y < 2 / 3)
	    );
	};


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	
	module.exports = function getUpdateObject(axisLayout, buttonLayout) {
	    var axName = axisLayout._name;
	    var update = {};
	
	    if(buttonLayout.step === 'all') {
	        update[axName + '.autorange'] = true;
	    }
	    else {
	        var xrange = getXRange(axisLayout, buttonLayout);
	
	        update[axName + '.range[0]'] = xrange[0];
	        update[axName + '.range[1]'] = xrange[1];
	    }
	
	    return update;
	};
	
	function getXRange(axisLayout, buttonLayout) {
	    var currentRange = axisLayout.range;
	    var base = new Date(currentRange[1]);
	
	    var step = buttonLayout.step,
	        count = buttonLayout.count;
	
	    var range0;
	
	    switch(buttonLayout.stepmode) {
	        case 'backward':
	            range0 = d3.time[step].offset(base, -count).getTime();
	            break;
	
	        case 'todate':
	            var base2 = d3.time[step].offset(base, -(count - 1));
	
	            range0 = d3.time[step].floor(base2).getTime();
	            break;
	    }
	
	    var range1 = currentRange[1];
	
	    return [range0, range1];
	}


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	var colorMix = __webpack_require__(315).mix;
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	var lightFraction = __webpack_require__(334).lightFraction;
	
	var layoutAttributes = __webpack_require__(348);
	var handleTickValueDefaults = __webpack_require__(346);
	var handleTickMarkDefaults = __webpack_require__(347);
	var handleTickLabelDefaults = __webpack_require__(353);
	var handleCategoryOrderDefaults = __webpack_require__(377);
	var setConvert = __webpack_require__(378);
	var orderedCategories = __webpack_require__(380);
	var cleanDatum = __webpack_require__(379);
	var axisIds = __webpack_require__(373);
	
	
	/**
	 * options: object containing:
	 *
	 *  letter: 'x' or 'y'
	 *  title: name of the axis (ie 'Colorbar') to go in default title
	 *  name: axis object name (ie 'xaxis') if one should be stored
	 *  font: the default font to inherit
	 *  outerTicks: boolean, should ticks default to outside?
	 *  showGrid: boolean, should gridlines be shown by default?
	 *  noHover: boolean, this axis doesn't support hover effects?
	 *  data: the plot data to use in choosing auto type
	 *  bgColor: the plot background color, to calculate default gridline colors
	 */
	module.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options) {
	    var letter = options.letter,
	        font = options.font || {},
	        defaultTitle = 'Click to enter ' +
	            (options.title || (letter.toUpperCase() + ' axis')) +
	            ' title';
	
	    function coerce2(attr, dflt) {
	        return Lib.coerce2(containerIn, containerOut, layoutAttributes, attr, dflt);
	    }
	
	    // set up some private properties
	    if(options.name) {
	        containerOut._name = options.name;
	        containerOut._id = axisIds.name2id(options.name);
	    }
	
	    // now figure out type and do some more initialization
	    var axType = coerce('type');
	    if(axType === '-') {
	        setAutoType(containerOut, options.data);
	
	        if(containerOut.type === '-') {
	            containerOut.type = 'linear';
	        }
	        else {
	            // copy autoType back to input axis
	            // note that if this object didn't exist
	            // in the input layout, we have to put it in
	            // this happens in the main supplyDefaults function
	            axType = containerIn.type = containerOut.type;
	        }
	    }
	
	    setConvert(containerOut);
	
	    var dfltColor = coerce('color');
	    // if axis.color was provided, use it for fonts too; otherwise,
	    // inherit from global font color in case that was provided.
	    var dfltFontColor = (dfltColor === containerIn.color) ? dfltColor : font.color;
	
	    coerce('title', defaultTitle);
	    Lib.coerceFont(coerce, 'titlefont', {
	        family: font.family,
	        size: Math.round(font.size * 1.2),
	        color: dfltFontColor
	    });
	
	    var validRange = (
	        (containerIn.range || []).length === 2 &&
	        isNumeric(containerIn.range[0]) &&
	        isNumeric(containerIn.range[1])
	    );
	    var autoRange = coerce('autorange', !validRange);
	
	    if(autoRange) coerce('rangemode');
	    var range = coerce('range', [-1, letter === 'x' ? 6 : 4]);
	    if(range[0] === range[1]) {
	        containerOut.range = [range[0] - 1, range[0] + 1];
	    }
	    Lib.noneOrAll(containerIn.range, containerOut.range, [0, 1]);
	
	    coerce('fixedrange');
	
	    handleTickValueDefaults(containerIn, containerOut, coerce, axType);
	    handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);
	    handleTickMarkDefaults(containerIn, containerOut, coerce, options);
	    handleCategoryOrderDefaults(containerIn, containerOut, coerce);
	
	    var lineColor = coerce2('linecolor', dfltColor),
	        lineWidth = coerce2('linewidth'),
	        showLine = coerce('showline', !!lineColor || !!lineWidth);
	
	    if(!showLine) {
	        delete containerOut.linecolor;
	        delete containerOut.linewidth;
	    }
	
	    if(showLine || containerOut.ticks) coerce('mirror');
	
	    var gridColor = coerce2('gridcolor', colorMix(dfltColor, options.bgColor, lightFraction).toRgbString()),
	        gridWidth = coerce2('gridwidth'),
	        showGridLines = coerce('showgrid', options.showGrid || !!gridColor || !!gridWidth);
	
	    if(!showGridLines) {
	        delete containerOut.gridcolor;
	        delete containerOut.gridwidth;
	    }
	
	    var zeroLineColor = coerce2('zerolinecolor', dfltColor),
	        zeroLineWidth = coerce2('zerolinewidth'),
	        showZeroLine = coerce('zeroline', options.showGrid || !!zeroLineColor || !!zeroLineWidth);
	
	    if(!showZeroLine) {
	        delete containerOut.zerolinecolor;
	        delete containerOut.zerolinewidth;
	    }
	
	    // fill in categories
	    containerOut._initialCategories = axType === 'category' ?
	        orderedCategories(letter, containerOut.categoryorder, containerOut.categoryarray, options.data) :
	        [];
	
	    return containerOut;
	};
	
	function setAutoType(ax, data) {
	    // new logic: let people specify any type they want,
	    // only autotype if type is '-'
	    if(ax.type !== '-') return;
	
	    var id = ax._id,
	        axLetter = id.charAt(0);
	
	    // support 3d
	    if(id.indexOf('scene') !== -1) id = axLetter;
	
	    var d0 = getFirstNonEmptyTrace(data, id, axLetter);
	    if(!d0) return;
	
	    // first check for histograms, as the count direction
	    // should always default to a linear axis
	    if(d0.type==='histogram' &&
	            axLetter === {v: 'y', h: 'x'}[d0.orientation || 'v']) {
	        ax.type = 'linear';
	        return;
	    }
	
	    // check all boxes on this x axis to see
	    // if they're dates, numbers, or categories
	    if(isBoxWithoutPositionCoords(d0, axLetter)) {
	        var posLetter = getBoxPosLetter(d0),
	            boxPositions = [],
	            trace;
	
	        for(var i = 0; i < data.length; i++) {
	            trace = data[i];
	            if(!Plots.traceIs(trace, 'box') ||
	               (trace[axLetter + 'axis'] || axLetter) !== id) continue;
	
	            if(trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);
	            else if(trace.name !== undefined) boxPositions.push(trace.name);
	            else boxPositions.push('text');
	        }
	
	        ax.type = autoType(boxPositions);
	    }
	    else {
	        ax.type = autoType(d0[axLetter] || [d0[axLetter+'0']]);
	    }
	}
	
	function getBoxPosLetter(trace) {
	    return {v: 'x', h: 'y'}[trace.orientation || 'v'];
	}
	
	function isBoxWithoutPositionCoords(trace, axLetter) {
	    var posLetter = getBoxPosLetter(trace);
	
	    return (
	        Plots.traceIs(trace, 'box') &&
	        axLetter === posLetter &&
	        trace[posLetter] === undefined &&
	        trace[posLetter + '0'] === undefined
	    );
	}
	
	function autoType(array) {
	    if(moreDates(array)) return 'date';
	    if(category(array)) return 'category';
	    if(linearOK(array)) return 'linear';
	    else return '-';
	}
	
	function getFirstNonEmptyTrace(data, id, axLetter) {
	    for(var i = 0; i < data.length; i++) {
	        var trace = data[i];
	
	        if((trace[axLetter + 'axis'] || axLetter) === id) {
	            if(isBoxWithoutPositionCoords(trace, axLetter)) {
	                return trace;
	            }
	            else if((trace[axLetter] || []).length || trace[axLetter + '0']) {
	                return trace;
	            }
	        }
	    }
	}
	
	// is there at least one number in array? If not, we should leave
	// ax.type empty so it can be autoset later
	function linearOK(array) {
	    if(!array) return false;
	
	    for(var i = 0; i < array.length; i++) {
	        if(isNumeric(array[i])) return true;
	    }
	
	    return false;
	}
	
	// does the array a have mostly dates rather than numbers?
	// note: some values can be neither (such as blanks, text)
	// 2- or 4-digit integers can be both, so require twice as many
	// dates as non-dates, to exclude cases with mostly 2 & 4 digit
	// numbers and a few dates
	function moreDates(a) {
	    var dcnt = 0,
	        ncnt = 0,
	        // test at most 1000 points, evenly spaced
	        inc = Math.max(1, (a.length - 1) / 1000),
	        ai;
	
	    for(var i = 0; i < a.length; i += inc) {
	        ai = a[Math.round(i)];
	        if(Lib.isDateTime(ai)) dcnt += 1;
	        if(isNumeric(ai)) ncnt += 1;
	    }
	
	    return (dcnt > ncnt * 2);
	}
	
	// are the (x,y)-values in td.data mostly text?
	// require twice as many categories as numbers
	function category(a) {
	    // test at most 1000 points
	    var inc = Math.max(1, (a.length - 1) / 1000),
	        curvenums = 0,
	        curvecats = 0,
	        ai;
	
	    for(var i = 0; i < a.length; i += inc) {
	        ai = cleanDatum(a[Math.round(i)]);
	        if(isNumeric(ai)) curvenums++;
	        else if(typeof ai === 'string' && ai !== '' && ai !== 'None') curvecats++;
	    }
	
	    return curvecats > curvenums * 2;
	}


/***/ },
/* 377 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce) {
	    if(containerOut.type !== 'category') return;
	
	    var arrayIn = containerIn.categoryarray,
	        orderDefault;
	
	    var isValidArray = (Array.isArray(arrayIn) && arrayIn.length > 0);
	
	    // override default 'categoryorder' value when non-empty array is supplied
	    if(isValidArray) orderDefault = 'array';
	
	    var order = coerce('categoryorder', orderDefault);
	
	    // coerce 'categoryarray' only in array order case
	    if(order === 'array') coerce('categoryarray');
	
	    // cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'
	    if(!isValidArray && order === 'array') {
	        containerOut.categoryorder = 'trace';
	    }
	};


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	
	var constants = __webpack_require__(352);
	var cleanDatum = __webpack_require__(379);
	var axisIds = __webpack_require__(373);
	
	
	/**
	 * Define the conversion functions for an axis data is used in 4 ways:
	 *
	 *  d: data, in whatever form it's provided
	 *  c: calcdata: turned into numbers, but not linearized
	 *  l: linearized - same as c except for log axes (and other
	 *      mappings later?) this is used by ranges, and when we
	 *      need to know if it's *possible* to show some data on
	 *      this axis, without caring about the current range
	 *  p: pixel value - mapped to the screen with current size and zoom
	 *
	 * Creates/updates these conversion functions
	 * also clears the autorange bounds ._min and ._max
	 * and the autotick constraints ._minDtick, ._forceTick0,
	 * and looks for date ranges that aren't yet in numeric format
	 */
	module.exports = function setConvert(ax) {
	
	    // clipMult: how many axis lengths past the edge do we render?
	    // for panning, 1-2 would suffice, but for zooming more is nice.
	    // also, clipping can affect the direction of lines off the edge...
	    var clipMult = 10;
	
	    function toLog(v, clip) {
	        if(v>0) return Math.log(v)/Math.LN10;
	
	        else if(v<=0 && clip && ax.range && ax.range.length===2) {
	            // clip NaN (ie past negative infinity) to clipMult axis
	            // length past the negative edge
	            var r0 = ax.range[0],
	                r1 = ax.range[1];
	            return 0.5*(r0 + r1 - 3 * clipMult * Math.abs(r0 - r1));
	        }
	
	        else return constants.BADNUM;
	    }
	    function fromLog(v) { return Math.pow(10,v); }
	    function num(v) { return isNumeric(v) ? Number(v) : constants.BADNUM; }
	
	    ax.c2l = (ax.type==='log') ? toLog : num;
	    ax.l2c = (ax.type==='log') ? fromLog : num;
	    ax.l2d = function(v) { return ax.c2d(ax.l2c(v)); };
	    ax.p2d = function(v) { return ax.l2d(ax.p2l(v)); };
	
	    // set scaling to pixels
	    ax.setScale = function() {
	        var gs = ax._gd._fullLayout._size,
	            i;
	
	        // TODO cleaner way to handle this case
	        if(!ax._categories) ax._categories = [];
	
	        // make sure we have a domain (pull it in from the axis
	        // this one is overlaying if necessary)
	        if(ax.overlaying) {
	            var ax2 = axisIds.getFromId(ax._gd, ax.overlaying);
	            ax.domain = ax2.domain;
	        }
	
	        // make sure we have a range (linearized data values)
	        // and that it stays away from the limits of javascript numbers
	        if(!ax.range || ax.range.length!==2 || ax.range[0]===ax.range[1]) {
	            ax.range = [-1,1];
	        }
	        for(i=0; i<2; i++) {
	            if(!isNumeric(ax.range[i])) {
	                ax.range[i] = isNumeric(ax.range[1-i]) ?
	                    (ax.range[1-i] * (i ? 10 : 0.1)) :
	                    (i ? 1 : -1);
	            }
	
	            if(ax.range[i]<-(Number.MAX_VALUE/2)) {
	                ax.range[i] = -(Number.MAX_VALUE/2);
	            }
	            else if(ax.range[i]>Number.MAX_VALUE/2) {
	                ax.range[i] = Number.MAX_VALUE/2;
	            }
	
	        }
	
	        if(ax._id.charAt(0)==='y') {
	            ax._offset = gs.t+(1-ax.domain[1])*gs.h;
	            ax._length = gs.h*(ax.domain[1]-ax.domain[0]);
	            ax._m = ax._length/(ax.range[0]-ax.range[1]);
	            ax._b = -ax._m*ax.range[1];
	        }
	        else {
	            ax._offset = gs.l+ax.domain[0]*gs.w;
	            ax._length = gs.w*(ax.domain[1]-ax.domain[0]);
	            ax._m = ax._length/(ax.range[1]-ax.range[0]);
	            ax._b = -ax._m*ax.range[0];
	        }
	
	        if(!isFinite(ax._m) || !isFinite(ax._b)) {
	            Lib.notifier(
	                'Something went wrong with axis scaling',
	                'long');
	            ax._gd._replotting = false;
	            throw new Error('axis scaling');
	        }
	    };
	
	    ax.l2p = function(v) {
	        if(!isNumeric(v)) return constants.BADNUM;
	
	        // include 2 fractional digits on pixel, for PDF zooming etc
	        return d3.round(ax._b + ax._m * v, 2);
	    };
	
	    ax.p2l = function(px) { return (px-ax._b)/ax._m; };
	
	    ax.c2p = function(v, clip) { return ax.l2p(ax.c2l(v, clip)); };
	    ax.p2c = function(px) { return ax.l2c(ax.p2l(px)); };
	
	    if(['linear','log','-'].indexOf(ax.type)!==-1) {
	        ax.c2d = num;
	        ax.d2c = function(v) {
	            v = cleanDatum(v);
	            return isNumeric(v) ? Number(v) : constants.BADNUM;
	        };
	        ax.d2l = function(v, clip) {
	            if(ax.type === 'log') return ax.c2l(ax.d2c(v), clip);
	            else return ax.d2c(v);
	        };
	    }
	    else if(ax.type==='date') {
	        ax.c2d = function(v) {
	            return isNumeric(v) ? Lib.ms2DateTime(v) : constants.BADNUM;
	        };
	
	        ax.d2c = function(v) {
	            return (isNumeric(v)) ? Number(v) : Lib.dateTime2ms(v);
	        };
	
	        ax.d2l = ax.d2c;
	
	        // check if date strings or js date objects are provided for range
	        // and convert to ms
	        if(ax.range && ax.range.length>1) {
	            try {
	                var ar1 = ax.range.map(Lib.dateTime2ms);
	                if(!isNumeric(ax.range[0]) && isNumeric(ar1[0])) {
	                    ax.range[0] = ar1[0];
	                }
	                if(!isNumeric(ax.range[1]) && isNumeric(ar1[1])) {
	                    ax.range[1] = ar1[1];
	                }
	            }
	            catch(e) { console.log(e, ax.range); }
	        }
	    }
	    else if(ax.type==='category') {
	
	        ax.c2d = function(v) {
	            return ax._categories[Math.round(v)];
	        };
	
	        ax.d2c = function(v) {
	            // create the category list
	            // this will enter the categories in the order it
	            // encounters them, ie all the categories from the
	            // first data set, then all the ones from the second
	            // that aren't in the first etc.
	            // it is assumed that this function is being invoked in the
	            // already sorted category order; otherwise there would be
	            // a disconnect between the array and the index returned
	
	            if(v !== null && v !== undefined && ax._categories.indexOf(v) === -1) {
	                ax._categories.push(v);
	            }
	
	            var c = ax._categories.indexOf(v);
	            return c === -1 ? constants.BADNUM : c;
	        };
	
	        ax.d2l = ax.d2c;
	    }
	
	    // makeCalcdata: takes an x or y array and converts it
	    // to a position on the axis object "ax"
	    // inputs:
	    //      tdc - a data object from td.data
	    //      axletter - a string, either 'x' or 'y', for which item
	    //          to convert (TODO: is this now always the same as
	    //          the first letter of ax._id?)
	    // in case the expected data isn't there, make a list of
	    // integers based on the opposite data
	    ax.makeCalcdata = function(tdc, axletter) {
	        var arrayIn, arrayOut, i;
	
	        if(axletter in tdc) {
	            arrayIn = tdc[axletter];
	            arrayOut = new Array(arrayIn.length);
	
	            for(i = 0; i < arrayIn.length; i++) arrayOut[i] = ax.d2c(arrayIn[i]);
	        }
	        else {
	            var v0 = ((axletter+'0') in tdc) ?
	                    ax.d2c(tdc[axletter+'0']) : 0,
	                dv = (tdc['d'+axletter]) ?
	                    Number(tdc['d'+axletter]) : 1;
	
	            // the opposing data, for size if we have x and dx etc
	            arrayIn = tdc[{x: 'y',y: 'x'}[axletter]];
	            arrayOut = new Array(arrayIn.length);
	
	            for(i = 0; i < arrayIn.length; i++) arrayOut[i] = v0+i*dv;
	        }
	        return arrayOut;
	    };
	
	    // for autoranging: arrays of objects:
	    //      {val: axis value, pad: pixel padding}
	    // on the low and high sides
	    ax._min = [];
	    ax._max = [];
	
	    // and for bar charts and box plots: reset forced minimum tick spacing
	    ax._minDtick = null;
	    ax._forceTick0 = null;
	};


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	
	
	/**
	 * cleanDatum: removes characters
	 * same replace criteria used in the grid.js:scrapeCol
	 * but also handling dates, numbers, and NaN, null, Infinity etc
	 */
	module.exports = function cleanDatum(c) {
	    try {
	        if(typeof c === 'object' && c !== null && c.getTime) {
	            return Lib.ms2DateTime(c);
	        }
	        if(typeof c !== 'string' && !isNumeric(c)) {
	            return '';
	        }
	        c = c.toString().replace(/['"%,$# ]/g, '');
	    }
	    catch(e) {
	        console.log(e, c);
	    }
	
	    return c;
	};


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	// flattenUniqueSort :: String -> Function -> [[String]] -> [String]
	function flattenUniqueSort(axisLetter, sortFunction, data) {
	
	    // Bisection based insertion sort of distinct values for logarithmic time complexity.
	    // Can't use a hashmap, which is O(1), because ES5 maps coerce keys to strings. If it ever becomes a bottleneck,
	    // code can be separated: a hashmap (JS object) based version if all values encountered are strings; and
	    // downgrading to this O(log(n)) array on the first encounter of a non-string value.
	
	    var categoryArray = [];
	
	    var traceLines = data.map(function(d) {return d[axisLetter];});
	
	    var i, j, tracePoints, category, insertionIndex;
	
	    var bisector = d3.bisector(sortFunction).left;
	
	    for(i = 0; i < traceLines.length; i++) {
	
	        tracePoints = traceLines[i];
	
	        for(j = 0; j < tracePoints.length; j++) {
	
	            category = tracePoints[j];
	
	            // skip loop: ignore null and undefined categories
	            if(category === null || category === undefined) continue;
	
	            insertionIndex = bisector(categoryArray, category);
	
	            // skip loop on already encountered values
	            if(insertionIndex < categoryArray.length - 1 && categoryArray[insertionIndex] === category) continue;
	
	            // insert value
	            categoryArray.splice(insertionIndex, 0, category);
	        }
	    }
	
	    return categoryArray;
	}
	
	
	/**
	 * This pure function returns the ordered categories for specified axisLetter, categoryorder, categoryarray and data.
	 *
	 * If categoryorder is 'array', the result is a fresh copy of categoryarray, or if unspecified, an empty array.
	 *
	 * If categoryorder is 'category ascending' or 'category descending', the result is an array of ascending or descending
	 * order of the unique categories encountered in the data for specified axisLetter.
	 *
	 * See cartesian/layout_attributes.js for the definition of categoryorder and categoryarray
	 *
	 */
	
	// orderedCategories :: String -> String -> [String] -> [[String]] -> [String]
	module.exports = function orderedCategories(axisLetter, categoryorder, categoryarray, data) {
	
	    switch(categoryorder) {
	        case 'array': return Array.isArray(categoryarray) ? categoryarray.slice() : [];
	        case 'category ascending': return flattenUniqueSort(axisLetter, d3.ascending, data);
	        case 'category descending': return flattenUniqueSort(axisLetter, d3.descending, data);
	        case 'trace': return [];
	        default: return [];
	    }
	};


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	
	
	module.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {
	    var counterAxes = options.counterAxes || [],
	        overlayableAxes = options.overlayableAxes || [],
	        letter = options.letter;
	
	    var anchor = Lib.coerce(containerIn, containerOut, {
	        anchor: {
	            valType: 'enumerated',
	            values: ['free'].concat(counterAxes),
	            dflt: isNumeric(containerIn.position) ? 'free' :
	                (counterAxes[0] || 'free')
	        }
	    }, 'anchor');
	
	    if(anchor === 'free') coerce('position');
	
	    Lib.coerce(containerIn, containerOut, {
	        side: {
	            valType: 'enumerated',
	            values: letter === 'x' ? ['bottom', 'top'] : ['left', 'right'],
	            dflt: letter === 'x' ? 'bottom' : 'left'
	        }
	    }, 'side');
	
	    var overlaying = false;
	    if(overlayableAxes.length) {
	        overlaying = Lib.coerce(containerIn, containerOut, {
	            overlaying: {
	                valType: 'enumerated',
	                values: [false].concat(overlayableAxes),
	                dflt: false
	            }
	        }, 'overlaying');
	    }
	
	    if(!overlaying) {
	        // TODO: right now I'm copying this domain over to overlaying axes
	        // in ax.setscale()... but this means we still need (imperfect) logic
	        // in the axes popover to hide domain for the overlaying axis.
	        // perhaps I should make a private version _domain that all axes get???
	        var domain = coerce('domain');
	        if(domain[0] > domain[1] - 0.01) containerOut.domain = [0, 1];
	        Lib.noneOrAll(containerIn.domain, containerOut.domain, [0, 1]);
	    }
	
	    return containerOut;
	};


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var tinycolor = __webpack_require__(315);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	var Events = __webpack_require__(383);
	var svgTextUtils = __webpack_require__(326);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var dragElement = __webpack_require__(385);
	
	var Axes = __webpack_require__(338);
	var constants = __webpack_require__(352);
	var dragBox = __webpack_require__(389);
	
	
	var fx = module.exports = {};
	
	// TODO remove this in version 2.0
	// copy on Fx for backward compatible
	fx.unhover = dragElement.unhover;
	
	fx.layoutAttributes = {
	    dragmode: {
	        valType: 'enumerated',
	        role: 'info',
	        values: ['zoom', 'pan', 'select', 'lasso', 'orbit', 'turntable'],
	        dflt: 'zoom',
	        description: [
	            'Determines the mode of drag interactions.',
	            '*select* and *lasso* apply only to scatter traces with',
	            'markers or text. *orbit* and *turntable* apply only to',
	            '3D scenes.'
	        ].join(' ')
	    },
	    hovermode: {
	        valType: 'enumerated',
	        role: 'info',
	        values: ['x', 'y', 'closest', false],
	        description: 'Determines the mode of hover interactions.'
	    }
	};
	
	fx.supplyLayoutDefaults = function(layoutIn, layoutOut, fullData) {
	    function coerce(attr, dflt) {
	        return Lib.coerce(layoutIn, layoutOut, fx.layoutAttributes, attr, dflt);
	    }
	
	    coerce('dragmode');
	
	    var hovermodeDflt;
	    if(layoutOut._has('cartesian')) {
	        // flag for 'horizontal' plots:
	        // determines the state of the mode bar 'compare' hovermode button
	        var isHoriz = layoutOut._isHoriz = fx.isHoriz(fullData);
	        hovermodeDflt = isHoriz ? 'y' : 'x';
	    }
	    else hovermodeDflt = 'closest';
	
	    coerce('hovermode', hovermodeDflt);
	};
	
	fx.isHoriz = function(fullData) {
	    var isHoriz = true;
	
	    for(var i = 0; i < fullData.length; i++) {
	        var trace = fullData[i];
	
	        if(trace.orientation !== 'h') {
	            isHoriz = false;
	            break;
	        }
	    }
	
	    return isHoriz;
	};
	
	fx.init = function(gd) {
	    var fullLayout = gd._fullLayout;
	
	    if(!fullLayout._has('cartesian') || gd._context.staticPlot) return;
	
	    var subplots = Object.keys(fullLayout._plots || {}).sort(function(a,b) {
	        // sort overlays last, then by x axis number, then y axis number
	        if((fullLayout._plots[a].mainplot && true) ===
	            (fullLayout._plots[b].mainplot && true)) {
	            var aParts = a.split('y'),
	                bParts = b.split('y');
	            return (aParts[0]===bParts[0]) ?
	                (Number(aParts[1]||1) - Number(bParts[1]||1)) :
	                (Number(aParts[0]||1) - Number(bParts[0]||1));
	        }
	        return fullLayout._plots[a].mainplot ? 1 : -1;
	    });
	
	    subplots.forEach(function(subplot) {
	        var plotinfo = fullLayout._plots[subplot];
	
	        if(!fullLayout._has('cartesian')) return;
	
	        var xa = plotinfo.x(),
	            ya = plotinfo.y(),
	
	            // the y position of the main x axis line
	            y0 = (xa._linepositions[subplot]||[])[3],
	
	            // the x position of the main y axis line
	            x0 = (ya._linepositions[subplot]||[])[3];
	
	        var DRAGGERSIZE = constants.DRAGGERSIZE;
	        if(isNumeric(y0) && xa.side==='top') y0 -= DRAGGERSIZE;
	        if(isNumeric(x0) && ya.side!=='right') x0 -= DRAGGERSIZE;
	
	        // main and corner draggers need not be repeated for
	        // overlaid subplots - these draggers drag them all
	        if(!plotinfo.mainplot) {
	            // main dragger goes over the grids and data, so we use its
	            // mousemove events for all data hover effects
	            var maindrag = dragBox(gd, plotinfo, 0, 0,
	                xa._length, ya._length,'ns','ew');
	
	            maindrag.onmousemove = function(evt) {
	                fx.hover(gd, evt, subplot);
	                fullLayout._lasthover = maindrag;
	                fullLayout._hoversubplot = subplot;
	            };
	
	            /*
	             * IMPORTANT:
	             * We must check for the presence of the drag cover here.
	             * If we don't, a 'mouseout' event is triggered on the
	             * maindrag before each 'click' event, which has the effect
	             * of clearing the hoverdata; thus, cancelling the click event.
	             */
	            maindrag.onmouseout = function(evt) {
	                if(gd._dragging) return;
	
	                dragElement.unhover(gd, evt);
	            };
	
	            maindrag.onclick = function(evt) {
	                fx.click(gd, evt);
	            };
	
	            // corner draggers
	            dragBox(gd, plotinfo, -DRAGGERSIZE, -DRAGGERSIZE,
	                DRAGGERSIZE, DRAGGERSIZE, 'n', 'w');
	            dragBox(gd, plotinfo, xa._length, -DRAGGERSIZE,
	                DRAGGERSIZE, DRAGGERSIZE, 'n', 'e');
	            dragBox(gd, plotinfo, -DRAGGERSIZE, ya._length,
	                DRAGGERSIZE, DRAGGERSIZE, 's', 'w');
	            dragBox(gd, plotinfo, xa._length, ya._length,
	                DRAGGERSIZE, DRAGGERSIZE, 's', 'e');
	        }
	
	        // x axis draggers - if you have overlaid plots,
	        // these drag each axis separately
	        if(isNumeric(y0)) {
	            if(xa.anchor==='free') y0 -= fullLayout._size.h*(1-ya.domain[1]);
	            dragBox(gd, plotinfo, xa._length*0.1, y0,
	                xa._length*0.8, DRAGGERSIZE, '', 'ew');
	            dragBox(gd, plotinfo, 0, y0,
	                xa._length*0.1, DRAGGERSIZE, '', 'w');
	            dragBox(gd, plotinfo, xa._length*0.9, y0,
	                xa._length*0.1, DRAGGERSIZE, '', 'e');
	        }
	        // y axis draggers
	        if(isNumeric(x0)) {
	            if(ya.anchor==='free') x0 -= fullLayout._size.w*xa.domain[0];
	            dragBox(gd, plotinfo, x0, ya._length*0.1,
	                DRAGGERSIZE, ya._length*0.8, 'ns', '');
	            dragBox(gd, plotinfo, x0, ya._length*0.9,
	                DRAGGERSIZE, ya._length*0.1, 's', '');
	            dragBox(gd, plotinfo, x0, 0,
	                DRAGGERSIZE, ya._length*0.1, 'n', '');
	        }
	    });
	
	    // In case you mousemove over some hovertext, send it to fx.hover too
	    // we do this so that we can put the hover text in front of everything,
	    // but still be able to interact with everything as if it isn't there
	    var hoverLayer = fullLayout._hoverlayer.node();
	
	    hoverLayer.onmousemove = function(evt) {
	        evt.target = fullLayout._lasthover;
	        fx.hover(gd, evt, fullLayout._hoversubplot);
	    };
	
	    hoverLayer.onclick = function(evt) {
	        evt.target = fullLayout._lasthover;
	        fx.click(gd, evt);
	    };
	
	    // also delegate mousedowns... TODO: does this actually work?
	    hoverLayer.onmousedown = function(evt) {
	        fullLayout._lasthover.onmousedown(evt);
	    };
	};
	
	// hover labels for multiple horizontal bars get tilted by some angle,
	// then need to be offset differently if they overlap
	var YANGLE = constants.YANGLE,
	    YA_RADIANS = Math.PI*YANGLE/180,
	
	    // expansion of projected height
	    YFACTOR = 1/Math.sin(YA_RADIANS),
	
	    // to make the appropriate post-rotation x offset,
	    // you need both x and y offsets
	    YSHIFTX = Math.cos(YA_RADIANS),
	    YSHIFTY = Math.sin(YA_RADIANS);
	
	// convenience functions for mapping all relevant axes
	function flat(subplots, v) {
	    var out = [];
	    for(var i=subplots.length; i>0; i--) out.push(v);
	    return out;
	}
	
	function p2c(axArray, v) {
	    var out = [];
	    for(var i=0; i<axArray.length; i++) out.push(axArray[i].p2c(v));
	    return out;
	}
	
	function quadrature(dx, dy) {
	    return function(di) {
	        var x = dx(di),
	            y = dy(di);
	        return Math.sqrt(x*x + y*y);
	    };
	}
	
	// size and display constants for hover text
	var HOVERARROWSIZE = constants.HOVERARROWSIZE,
	    HOVERTEXTPAD = constants.HOVERTEXTPAD,
	    HOVERFONTSIZE = constants.HOVERFONTSIZE,
	    HOVERFONT = constants.HOVERFONT;
	
	// fx.hover: highlight data on hover
	// evt can be a mousemove event, or an object with data about what points
	//   to hover on
	//      {xpx,ypx[,hovermode]} - pixel locations from top left
	//          (with optional overriding hovermode)
	//      {xval,yval[,hovermode]} - data values
	//      [{curveNumber,(pointNumber|xval and/or yval)}] -
	//              array of specific points to highlight
	//          pointNumber is a single integer if gd.data[curveNumber] is 1D,
	//              or a two-element array if it's 2D
	//          xval and yval are data values,
	//              1D data may specify either or both,
	//              2D data must specify both
	// subplot is an id string (default "xy")
	// makes use of gl.hovermode, which can be:
	//      x (find the points with the closest x values, ie a column),
	//      closest (find the single closest point)
	//    internally there are two more that occasionally get used:
	//      y (pick out a row - only used for multiple horizontal bar charts)
	//      array (used when the user specifies an explicit
	//          array of points to hover on)
	//
	// We wrap the hovers in a timer, to limit their frequency.
	// The actual rendering is done by private functions
	// hover() and unhover().
	
	fx.hover = function(gd, evt, subplot) {
	    if(typeof gd === 'string') gd = document.getElementById(gd);
	    if(gd._lastHoverTime === undefined) gd._lastHoverTime = 0;
	
	    // If we have an update queued, discard it now
	    if(gd._hoverTimer !== undefined) {
	        clearTimeout(gd._hoverTimer);
	        gd._hoverTimer = undefined;
	    }
	    // Is it more than 100ms since the last update?  If so, force
	    // an update now (synchronously) and exit
	    if(Date.now() > gd._lastHoverTime + constants.HOVERMINTIME) {
	        hover(gd,evt,subplot);
	        gd._lastHoverTime = Date.now();
	        return;
	    }
	    // Queue up the next hover for 100ms from now (if no further events)
	    gd._hoverTimer = setTimeout(function() {
	        hover(gd,evt,subplot);
	        gd._lastHoverTime = Date.now();
	        gd._hoverTimer = undefined;
	    }, constants.HOVERMINTIME);
	};
	
	// The actual implementation is here:
	
	function hover(gd, evt, subplot) {
	    if(subplot === 'pie') {
	        gd.emit('plotly_hover', {
	            points: [evt]
	        });
	        return;
	    }
	
	    if(!subplot) subplot = 'xy';
	
	    var fullLayout = gd._fullLayout,
	        plotinfo = fullLayout._plots[subplot],
	
	        //If the user passed in an array of subplots, use those instead of finding overlayed plots
	        subplots = Array.isArray(subplot) ?
	            subplot :
	            // list of all overlaid subplots to look at
	            [subplot].concat(plotinfo.overlays
	                .map(function(pi) { return pi.id; })),
	
	        xaArray = subplots.map(function(spId) {
	            var ternary = (gd._fullLayout[spId] || {})._ternary;
	            if(ternary) return ternary.xaxis;
	            return Axes.getFromId(gd, spId, 'x');
	        }),
	        yaArray = subplots.map(function(spId) {
	            var ternary = (gd._fullLayout[spId] || {})._ternary;
	            if(ternary) return ternary.yaxis;
	            return Axes.getFromId(gd, spId, 'y');
	        }),
	        hovermode = evt.hovermode || fullLayout.hovermode;
	
	    if(['x','y','closest'].indexOf(hovermode)===-1 || !gd.calcdata ||
	            gd.querySelector('.zoombox') || gd._dragging) {
	        return dragElement.unhoverRaw(gd, evt);
	    }
	
	        // hoverData: the set of candidate points we've found to highlight
	    var hoverData = [],
	
	        // searchData: the data to search in. Mostly this is just a copy of
	        // gd.calcdata, filtered to the subplot and overlays we're on
	        // but if a point array is supplied it will be a mapping
	        // of indicated curves
	        searchData = [],
	
	        // [x|y]valArray: the axis values of the hover event
	        // mapped onto each of the currently selected overlaid subplots
	        xvalArray,
	        yvalArray,
	
	        // used in loops
	        itemnum,
	        curvenum,
	        cd,
	        trace,
	        subploti,
	        mode,
	        xval,
	        yval,
	        pointData,
	        closedataPreviousLength;
	
	    // Figure out what we're hovering on:
	    // mouse location or user-supplied data
	
	    if(Array.isArray(evt)) {
	        // user specified an array of points to highlight
	        hovermode = 'array';
	        for(itemnum = 0; itemnum<evt.length; itemnum++) {
	            cd = gd.calcdata[evt[itemnum].curveNumber||0];
	            searchData.push(cd);
	        }
	    }
	    else {
	        for(curvenum = 0; curvenum<gd.calcdata.length; curvenum++) {
	            cd = gd.calcdata[curvenum];
	            trace = cd[0].trace;
	            if(subplots.indexOf(getSubplot(trace))!==-1) {
	                searchData.push(cd);
	            }
	        }
	
	        // [x|y]px: the pixels (from top left) of the mouse location
	        // on the currently selected plot area
	        var xpx, ypx;
	
	        // mouse event? ie is there a target element with
	        // clientX and clientY values?
	        if(evt.target && ('clientX' in evt) && ('clientY' in evt)) {
	
	            // fire the beforehover event and quit if it returns false
	            // note that we're only calling this on real mouse events, so
	            // manual calls to fx.hover will always run.
	            if(Events.triggerHandler(gd, 'plotly_beforehover', evt)===false) {
	                return;
	            }
	
	            var dbb = evt.target.getBoundingClientRect();
	
	            xpx = evt.clientX - dbb.left;
	            ypx = evt.clientY - dbb.top;
	
	            // in case hover was called from mouseout into hovertext,
	            // it's possible you're not actually over the plot anymore
	            if(xpx<0 || xpx>dbb.width || ypx<0 || ypx>dbb.height) {
	                return dragElement.unhoverRaw(gd,evt);
	            }
	        }
	        else {
	            if('xpx' in evt) xpx = evt.xpx;
	            else xpx = xaArray[0]._length/2;
	
	            if('ypx' in evt) ypx = evt.ypx;
	            else ypx = yaArray[0]._length/2;
	        }
	
	        if('xval' in evt) xvalArray = flat(subplots, evt.xval);
	        else xvalArray = p2c(xaArray, xpx);
	
	        if('yval' in evt) yvalArray = flat(subplots, evt.yval);
	        else yvalArray = p2c(yaArray, ypx);
	
	        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {
	            console.log('Plotly.Fx.hover failed', evt, gd);
	            return dragElement.unhoverRaw(gd, evt);
	        }
	    }
	
	    // the pixel distance to beat as a matching point
	    // in 'x' or 'y' mode this resets for each trace
	    var distance = Infinity;
	
	    // find the closest point in each trace
	    // this is minimum dx and/or dy, depending on mode
	    // and the pixel position for the label (labelXpx, labelYpx)
	    for(curvenum = 0; curvenum<searchData.length; curvenum++) {
	        cd = searchData[curvenum];
	
	        // filter out invisible or broken data
	        if(!cd || !cd[0] || !cd[0].trace || cd[0].trace.visible !== true) continue;
	
	        trace = cd[0].trace;
	        subploti = subplots.indexOf(getSubplot(trace));
	
	        // within one trace mode can sometimes be overridden
	        mode = hovermode;
	
	        // container for new point, also used to pass info into module.hoverPoints
	        pointData = {
	            // trace properties
	            cd: cd,
	            trace: trace,
	            xa: xaArray[subploti],
	            ya: yaArray[subploti],
	            name: (gd.data.length>1 || trace.hoverinfo.indexOf('name')!==-1) ? trace.name : undefined,
	            // point properties - override all of these
	            index: false, // point index in trace - only used by plotly.js hoverdata consumers
	            distance: Math.min(distance, constants.MAXDIST), // pixel distance or pseudo-distance
	            color: Color.defaultLine, // trace color
	            x0: undefined,
	            x1: undefined,
	            y0: undefined,
	            y1: undefined,
	            xLabelVal: undefined,
	            yLabelVal: undefined,
	            zLabelVal: undefined,
	            text: undefined
	        };
	
	        closedataPreviousLength = hoverData.length;
	
	        // for a highlighting array, figure out what
	        // we're searching for with this element
	        if(mode==='array') {
	            var selection = evt[curvenum];
	            if('pointNumber' in selection) {
	                pointData.index = selection.pointNumber;
	                mode = 'closest';
	            }
	            else {
	                mode = '';
	                if('xval' in selection) {
	                    xval = selection.xval;
	                    mode = 'x';
	                }
	                if('yval' in selection) {
	                    yval = selection.yval;
	                    mode = mode ? 'closest' : 'y';
	                }
	            }
	        }
	        else {
	            xval = xvalArray[subploti];
	            yval = yvalArray[subploti];
	        }
	
	        // Now find the points.
	        if(trace._module && trace._module.hoverPoints) {
	            var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode);
	            if(newPoints) {
	                var newPoint;
	                for(var newPointNum=0; newPointNum<newPoints.length; newPointNum++) {
	                    newPoint = newPoints[newPointNum];
	                    if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {
	                        hoverData.push(cleanPoint(newPoint, hovermode));
	                    }
	                }
	            }
	        }
	        else {
	            console.log('unrecognized trace type in hover', trace);
	        }
	
	        // in closest mode, remove any existing (farther) points
	        // and don't look any farther than this latest point (or points, if boxes)
	        if(hovermode==='closest' && hoverData.length > closedataPreviousLength) {
	            hoverData.splice(0, closedataPreviousLength);
	            distance = hoverData[0].distance;
	        }
	
	    }
	
	    // nothing left: remove all labels and quit
	    if(hoverData.length===0) return dragElement.unhoverRaw(gd,evt);
	
	    // if there's more than one horz bar trace,
	    // rotate the labels so they don't overlap
	    var rotateLabels = hovermode==='y' && searchData.length>1;
	
	    hoverData.sort(function(d1, d2) { return d1.distance - d2.distance; });
	
	    var bgColor = Color.combine(
	        fullLayout.plot_bgcolor || Color.background,
	        fullLayout.paper_bgcolor
	    );
	
	    var labelOpts = {
	        hovermode: hovermode,
	        rotateLabels: rotateLabels,
	        bgColor: bgColor,
	        container: fullLayout._hoverlayer,
	        outerContainer: fullLayout._paperdiv
	    };
	    var hoverLabels = createHoverText(hoverData, labelOpts);
	
	    hoverAvoidOverlaps(hoverData, rotateLabels ? 'xa' : 'ya');
	
	    alignHoverText(hoverLabels, rotateLabels);
	
	    // lastly, emit custom hover/unhover events
	    var oldhoverdata = gd._hoverdata,
	        newhoverdata = [];
	
	    // pull out just the data that's useful to
	    // other people and send it to the event
	    for(itemnum = 0; itemnum<hoverData.length; itemnum++) {
	        var pt = hoverData[itemnum];
	        var out = {
	            data: pt.trace._input,
	            fullData: pt.trace,
	            curveNumber: pt.trace.index,
	            pointNumber: pt.index,
	            x: pt.xVal,
	            y: pt.yVal,
	            xaxis: pt.xa,
	            yaxis: pt.ya
	        };
	        if(pt.zLabelVal!==undefined) out.z = pt.zLabelVal;
	        newhoverdata.push(out);
	    }
	    gd._hoverdata = newhoverdata;
	
	    if(!hoverChanged(gd, evt, oldhoverdata)) return;
	
	    /* Emit the custom hover handler. Bind this like:
	     *  gd.on('hover.plotly', function(extras) {
	     *      // do something with extras.data
	     *  });
	     */
	    if(oldhoverdata) {
	        gd.emit('plotly_unhover', { points: oldhoverdata });
	    }
	    gd.emit('plotly_hover', {
	        points: gd._hoverdata,
	        xaxes: xaArray,
	        yaxes: yaArray,
	        xvals: xvalArray,
	        yvals: yvalArray
	    });
	}
	
	// look for either .subplot (currently just ternary)
	// or xaxis and yaxis attributes
	function getSubplot(trace) {
	    return trace.subplot || (trace.xaxis + trace.yaxis);
	}
	
	fx.getDistanceFunction = function(mode, dx, dy, dxy) {
	    if(mode==='closest') return dxy || quadrature(dx, dy);
	    return mode==='x' ? dx : dy;
	};
	
	fx.getClosest = function(cd, distfn, pointData) {
	    // do we already have a point number? (array mode only)
	    if(pointData.index!==false) {
	        if(pointData.index>=0 && pointData.index<cd.length) {
	            pointData.distance = 0;
	        }
	        else pointData.index = false;
	    }
	    else {
	        // apply the distance function to each data point
	        // this is the longest loop... if this bogs down, we may need
	        // to create pre-sorted data (by x or y), not sure how to
	        // do this for 'closest'
	        for(var i=0; i<cd.length; i++) {
	            var newDistance = distfn(cd[i]);
	            if(newDistance <= pointData.distance) {
	                pointData.index = i;
	                pointData.distance = newDistance;
	            }
	        }
	    }
	    return pointData;
	};
	
	function cleanPoint(d, hovermode) {
	    d.posref = hovermode === 'y' ? (d.x0 + d.x1) / 2 : (d.y0 + d.y1) / 2;
	
	    // then constrain all the positions to be on the plot
	    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);
	    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);
	    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);
	    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);
	
	    // and convert the x and y label values into objects
	    // formatted as text, with font info
	    var logOffScale;
	    if(d.xLabelVal !== undefined) {
	        logOffScale = (d.xa.type === 'log' && d.xLabelVal <= 0);
	        var xLabelObj = Axes.tickText(d.xa,
	                d.xa.c2l(logOffScale ? -d.xLabelVal : d.xLabelVal), 'hover');
	        if(logOffScale) {
	            if(d.xLabelVal === 0) d.xLabel = '0';
	            else d.xLabel = '-' + xLabelObj.text;
	        }
	        else d.xLabel = xLabelObj.text;
	        d.xVal = d.xa.c2d(d.xLabelVal);
	    }
	
	    if(d.yLabelVal !== undefined) {
	        logOffScale = (d.ya.type === 'log' && d.yLabelVal <= 0);
	        var yLabelObj = Axes.tickText(d.ya,
	                d.ya.c2l(logOffScale ? -d.yLabelVal : d.yLabelVal), 'hover');
	        if(logOffScale) {
	            if(d.yLabelVal === 0) d.yLabel = '0';
	            else d.yLabel = '-' + yLabelObj.text;
	        }
	        else d.yLabel = yLabelObj.text;
	        d.yVal = d.ya.c2d(d.yLabelVal);
	    }
	
	    if(d.zLabelVal !== undefined) d.zLabel = String(d.zLabelVal);
	
	    // for box means and error bars, add the range to the label
	    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {
	        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;
	        if(d.xerrneg !== undefined) {
	            d.xLabel += ' +' + xeText + ' / -' +
	                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;
	        }
	        else d.xLabel += ' &plusmn; ' + xeText;
	
	        // small distance penalty for error bars, so that if there are
	        // traces with errors and some without, the error bar label will
	        // hoist up to the point
	        if(hovermode === 'x') d.distance += 1;
	    }
	    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {
	        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;
	        if(d.yerrneg !== undefined) {
	            d.yLabel += ' +' + yeText + ' / -' +
	                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;
	        }
	        else d.yLabel += ' &plusmn; ' + yeText;
	
	        if(hovermode === 'y') d.distance += 1;
	    }
	
	    var infomode = d.trace.hoverinfo;
	    if(infomode !== 'all') {
	        infomode = infomode.split('+');
	        if(infomode.indexOf('x') === -1) d.xLabel = undefined;
	        if(infomode.indexOf('y') === -1) d.yLabel = undefined;
	        if(infomode.indexOf('z') === -1) d.zLabel = undefined;
	        if(infomode.indexOf('text') === -1) d.text = undefined;
	        if(infomode.indexOf('name') === -1) d.name = undefined;
	    }
	    return d;
	}
	
	fx.loneHover = function(hoverItem, opts) {
	    // draw a single hover item in a pre-existing svg container somewhere
	    // hoverItem should have keys:
	    //    - x and y (or x0, x1, y0, and y1):
	    //      the pixel position to mark, relative to opts.container
	    //    - xLabel, yLabel, zLabel, text, and name:
	    //      info to go in the label
	    //    - color:
	    //      the background color for the label. text & outline color will
	    //      be chosen black or white to contrast with this
	    // opts should have keys:
	    //    - bgColor:
	    //      the background color this is against, used if the trace is
	    //      non-opaque, and for the name, which goes outside the box
	    //    - container:
	    //      a dom <svg> element - must be big enough to contain the whole
	    //      hover label
	    var pointData = {
	        color: hoverItem.color || Color.defaultLine,
	        x0: hoverItem.x0 || hoverItem.x || 0,
	        x1: hoverItem.x1 || hoverItem.x || 0,
	        y0: hoverItem.y0 || hoverItem.y || 0,
	        y1: hoverItem.y1 || hoverItem.y || 0,
	        xLabel: hoverItem.xLabel,
	        yLabel: hoverItem.yLabel,
	        zLabel: hoverItem.zLabel,
	        text: hoverItem.text,
	        name: hoverItem.name,
	        idealAlign: hoverItem.idealAlign,
	
	        // filler to make createHoverText happy
	        trace: {
	            index: 0,
	            hoverinfo: ''
	        },
	        xa: {_offset: 0},
	        ya: {_offset: 0},
	        index: 0
	    };
	
	    var container3 = d3.select(opts.container),
	        outerContainer3 = opts.outerContainer ?
	            d3.select(opts.outerContainer) : container3;
	
	    var fullOpts = {
	        hovermode: 'closest',
	        rotateLabels: false,
	        bgColor: opts.bgColor || Color.background,
	        container: container3,
	        outerContainer: outerContainer3
	    };
	
	    var hoverLabel = createHoverText([pointData], fullOpts);
	    alignHoverText(hoverLabel, fullOpts.rotateLabels);
	
	    return hoverLabel.node();
	};
	
	fx.loneUnhover = function(containerOrSelection) {
	    var selection = containerOrSelection instanceof d3.selection ?
	            containerOrSelection :
	            d3.select(containerOrSelection);
	
	    selection.selectAll('g.hovertext').remove();
	};
	
	function createHoverText(hoverData, opts) {
	    var hovermode = opts.hovermode,
	        rotateLabels = opts.rotateLabels,
	        bgColor = opts.bgColor,
	        container = opts.container,
	        outerContainer = opts.outerContainer,
	
	        c0 = hoverData[0],
	        xa = c0.xa,
	        ya = c0.ya,
	        commonAttr = hovermode==='y' ? 'yLabel' : 'xLabel',
	        t0 = c0[commonAttr],
	        t00 = (String(t0)||'').split(' ')[0],
	        outerContainerBB = outerContainer.node().getBoundingClientRect(),
	        outerTop = outerContainerBB.top,
	        outerWidth = outerContainerBB.width,
	        outerHeight = outerContainerBB.height;
	
	    // show the common label, if any, on the axis
	    // never show a common label in array mode,
	    // even if sometimes there could be one
	    var showCommonLabel = c0.distance<=constants.MAXDIST &&
	                          (hovermode==='x' || hovermode==='y');
	
	    // all hover traces hoverinfo must contain the hovermode
	    // to have common labels
	    var i, traceHoverinfo;
	    for(i = 0; i < hoverData.length; i++) {
	        traceHoverinfo = hoverData[i].trace.hoverinfo;
	        var parts = traceHoverinfo.split('+');
	        if(parts.indexOf('all') === -1 &&
	            parts.indexOf(hovermode) === -1) {
	            showCommonLabel = false;
	            break;
	        }
	    }
	
	    var commonLabel = container.selectAll('g.axistext')
	        .data(showCommonLabel ? [0] : []);
	    commonLabel.enter().append('g')
	        .classed('axistext', true);
	    commonLabel.exit().remove();
	
	    commonLabel.each(function() {
	        var label = d3.select(this),
	            lpath = label.selectAll('path').data([0]),
	            ltext = label.selectAll('text').data([0]);
	
	        lpath.enter().append('path')
	            .style({fill: Color.defaultLine, 'stroke-width': '1px', stroke: Color.background});
	        ltext.enter().append('text')
	            .call(Drawing.font, HOVERFONT, HOVERFONTSIZE, Color.background)
	            // prohibit tex interpretation until we can handle
	            // tex and regular text together
	            .attr('data-notex',1);
	
	        ltext.text(t0)
	            .call(svgTextUtils.convertToTspans)
	            .call(Drawing.setPosition, 0, 0)
	          .selectAll('tspan.line')
	            .call(Drawing.setPosition, 0, 0);
	        label.attr('transform','');
	
	        var tbb = ltext.node().getBoundingClientRect();
	        if(hovermode==='x') {
	            ltext.attr('text-anchor','middle')
	                .call(Drawing.setPosition,0,(xa.side==='top' ?
	                    (outerTop-tbb.bottom-HOVERARROWSIZE-HOVERTEXTPAD) :
	                    (outerTop-tbb.top+HOVERARROWSIZE+HOVERTEXTPAD)))
	                .selectAll('tspan.line')
	                    .attr({
	                        x: ltext.attr('x'),
	                        y: ltext.attr('y')
	                    });
	
	            var topsign = xa.side==='top' ? '-' : '';
	            lpath.attr('d','M0,0'+
	                'L'+HOVERARROWSIZE+','+topsign+HOVERARROWSIZE+
	                'H'+(HOVERTEXTPAD+tbb.width/2)+
	                'v'+topsign+(HOVERTEXTPAD*2+tbb.height)+
	                'H-'+(HOVERTEXTPAD+tbb.width/2)+
	                'V'+topsign+HOVERARROWSIZE+'H-'+HOVERARROWSIZE+'Z');
	
	            label.attr('transform','translate(' +
	                (xa._offset+(c0.x0+c0.x1)/2)+',' +
	                (ya._offset + (xa.side==='top' ? 0 : ya._length))+')');
	        }
	        else {
	            ltext.attr('text-anchor',ya.side==='right' ? 'start' : 'end')
	                .call(Drawing.setPosition,
	                    (ya.side==='right' ? 1 : -1)*(HOVERTEXTPAD+HOVERARROWSIZE),
	                    outerTop-tbb.top-tbb.height/2)
	                .selectAll('tspan.line')
	                    .attr({
	                        x: ltext.attr('x'),
	                        y: ltext.attr('y')
	                    });
	
	            var leftsign = ya.side==='right' ? '' : '-';
	            lpath.attr('d','M0,0'+
	                'L'+leftsign+HOVERARROWSIZE+','+HOVERARROWSIZE+
	                'V'+(HOVERTEXTPAD+tbb.height/2)+
	                'h'+leftsign+(HOVERTEXTPAD*2+tbb.width)+
	                'V-'+(HOVERTEXTPAD+tbb.height/2)+
	                'H'+leftsign+HOVERARROWSIZE+'V-'+HOVERARROWSIZE+'Z');
	
	            label.attr('transform','translate(' +
	                (xa._offset+(ya.side==='right' ? xa._length : 0))+',' +
	                (ya._offset+(c0.y0+c0.y1)/2)+')');
	        }
	        // remove the "close but not quite" points
	        // because of error bars, only take up to a space
	        hoverData = hoverData.filter(function(d) {
	            return (d.zLabelVal!==undefined) ||
	                (d[commonAttr]||'').split(' ')[0]===t00;
	        });
	    });
	
	    // show all the individual labels
	
	    // first create the objects
	    var hoverLabels = container.selectAll('g.hovertext')
	        .data(hoverData,function(d) {
	            return [d.trace.index,d.index,d.x0,d.y0,d.name,d.attr,d.xa,d.ya ||''].join(',');
	        });
	    hoverLabels.enter().append('g')
	        .classed('hovertext',true)
	        .each(function() {
	            var g = d3.select(this);
	            // trace name label (rect and text.name)
	            g.append('rect')
	                .call(Color.fill, Color.addOpacity(bgColor, 0.8));
	            g.append('text').classed('name', true)
	                .call(Drawing.font, HOVERFONT, HOVERFONTSIZE);
	            // trace data label (path and text.nums)
	            g.append('path')
	                .style('stroke-width', '1px');
	            g.append('text').classed('nums', true)
	                .call(Drawing.font, HOVERFONT, HOVERFONTSIZE);
	        });
	    hoverLabels.exit().remove();
	
	    // then put the text in, position the pointer to the data,
	    // and figure out sizes
	    hoverLabels.each(function(d) {
	        var g = d3.select(this).attr('transform', ''),
	            name = '',
	            text = '',
	            // combine possible non-opaque trace color with bgColor
	            baseColor = Color.opacity(d.color) ?
	                d.color : Color.defaultLine,
	            traceColor = Color.combine(baseColor, bgColor),
	
	            // find a contrasting color for border and text
	            contrastColor = tinycolor(traceColor).getBrightness()>128 ?
	                '#000' : Color.background;
	
	
	        if(d.name && d.zLabelVal===undefined) {
	            // strip out any html elements from d.name (if it exists at all)
	            // Note that this isn't an XSS vector, only because it never gets
	            // attached to the DOM
	            var tmp = document.createElement('p');
	            tmp.innerHTML = d.name;
	            name = tmp.textContent||'';
	
	            if(name.length>15) name = name.substr(0,12)+'...';
	        }
	
	        // used by other modules (initially just ternary) that
	        // manage their own hoverinfo independent of cleanPoint
	        // the rest of this will still apply, so such modules
	        // can still put things in (x|y|z)Label, text, and name
	        // and hoverinfo will still determine their visibility
	        if(d.extraText!==undefined) text += d.extraText;
	
	        if(d.zLabel!==undefined) {
	            if(d.xLabel!==undefined) text += 'x: ' + d.xLabel + '<br>';
	            if(d.yLabel!==undefined) text += 'y: ' + d.yLabel + '<br>';
	            text += (text ? 'z: ' : '') + d.zLabel;
	        }
	        else if(showCommonLabel && d[hovermode+'Label']===t0) {
	            text = d[(hovermode==='x' ? 'y' : 'x') + 'Label'] || '';
	        }
	        else if(d.xLabel===undefined) {
	            if(d.yLabel!==undefined) text = d.yLabel;
	        }
	        else if(d.yLabel===undefined) text = d.xLabel;
	        else text = '('+d.xLabel+', '+d.yLabel+')';
	
	        if(d.text && !Array.isArray(d.text)) text += (text ? '<br>' : '') + d.text;
	
	        // if 'text' is empty at this point,
	        // put 'name' in main label and don't show secondary label
	        if(text === '') {
	            // if 'name' is also empty, remove entire label
	            if(name === '') g.remove();
	            text = name;
	        }
	
	        // main label
	        var tx = g.select('text.nums')
	            .style('fill',contrastColor)
	            .call(Drawing.setPosition,0,0)
	            .text(text)
	            .attr('data-notex',1)
	            .call(svgTextUtils.convertToTspans);
	        tx.selectAll('tspan.line')
	            .call(Drawing.setPosition,0,0);
	
	        var tx2 = g.select('text.name'),
	            tx2width = 0;
	
	        // secondary label for non-empty 'name'
	        if(name && name!==text) {
	            tx2.style('fill',traceColor)
	                .text(name)
	                .call(Drawing.setPosition,0,0)
	                .attr('data-notex',1)
	                .call(svgTextUtils.convertToTspans);
	            tx2.selectAll('tspan.line')
	                .call(Drawing.setPosition,0,0);
	            tx2width = tx2.node().getBoundingClientRect().width+2*HOVERTEXTPAD;
	        }
	        else {
	            tx2.remove();
	            g.select('rect').remove();
	        }
	
	        g.select('path')
	            .style({
	                fill: traceColor,
	                stroke: contrastColor
	            });
	        var tbb = tx.node().getBoundingClientRect(),
	            htx = d.xa._offset+(d.x0+d.x1)/2,
	            hty = d.ya._offset+(d.y0+d.y1)/2,
	            dx = Math.abs(d.x1-d.x0),
	            dy = Math.abs(d.y1-d.y0),
	            txTotalWidth = tbb.width+HOVERARROWSIZE+HOVERTEXTPAD+tx2width,
	            anchorStartOK,
	            anchorEndOK;
	
	        d.ty0 = outerTop-tbb.top;
	        d.bx = tbb.width+2*HOVERTEXTPAD;
	        d.by = tbb.height+2*HOVERTEXTPAD;
	        d.anchor = 'start';
	        d.txwidth = tbb.width;
	        d.tx2width = tx2width;
	        d.offset = 0;
	
	        if(rotateLabels) {
	            d.pos = htx;
	            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;
	            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;
	            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {
	                hty -= dy / 2;
	                d.anchor = 'end';
	            } else if(anchorStartOK) {
	                hty += dy / 2;
	                d.anchor = 'start';
	            } else d.anchor = 'middle';
	        }
	        else {
	            d.pos = hty;
	            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;
	            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;
	            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {
	                htx -= dx / 2;
	                d.anchor = 'end';
	            } else if(anchorStartOK) {
	                htx += dx / 2;
	                d.anchor = 'start';
	            } else d.anchor = 'middle';
	        }
	
	        tx.attr('text-anchor',d.anchor);
	        if(tx2width) tx2.attr('text-anchor',d.anchor);
	        g.attr('transform','translate('+htx+','+hty+')'+
	            (rotateLabels ? 'rotate('+YANGLE+')' : ''));
	    });
	
	    return hoverLabels;
	}
	
	// Make groups of touching points, and within each group
	// move each point so that no labels overlap, but the average
	// label position is the same as it was before moving. Indicentally,
	// this is equivalent to saying all the labels are on equal linear
	// springs about their initial position. Initially, each point is
	// its own group, but as we find overlaps we will clump the points.
	//
	// Also, there are hard constraints at the edges of the graphs,
	// that push all groups to the middle so they are visible. I don't
	// know what happens if the group spans all the way from one edge to
	// the other, though it hardly matters - there's just too much
	// information then.
	function hoverAvoidOverlaps(hoverData, ax) {
	    var nummoves = 0,
	
	        // make groups of touching points
	        pointgroups = hoverData
	            .map(function(d,i) {
	                var axis = d[ax];
	                return [{
	                    i: i,
	                    dp: 0,
	                    pos: d.pos,
	                    posref: d.posref,
	                    size: d.by*(axis._id.charAt(0)==='x' ? YFACTOR : 1)/2,
	                    pmin: axis._offset,
	                    pmax: axis._offset+axis._length
	                }];
	            })
	            .sort(function(a,b) { return a[0].posref-b[0].posref; }),
	        donepositioning,
	        topOverlap,
	        bottomOverlap,
	        i, j,
	        pti,
	        sumdp;
	
	    function constrainGroup(grp) {
	        var minPt = grp[0],
	            maxPt = grp[grp.length-1];
	
	        // overlap with the top - positive vals are overlaps
	        topOverlap = minPt.pmin-minPt.pos-minPt.dp+minPt.size;
	
	        // overlap with the bottom - positive vals are overlaps
	        bottomOverlap = maxPt.pos+maxPt.dp+maxPt.size-minPt.pmax;
	
	        // check for min overlap first, so that we always
	        // see the largest labels
	        // allow for .01px overlap, so we don't get an
	        // infinite loop from rounding errors
	        if(topOverlap>0.01) {
	            for(j=grp.length-1; j>=0; j--) grp[j].dp += topOverlap;
	            donepositioning = false;
	        }
	        if(bottomOverlap<0.01) return;
	        if(topOverlap<-0.01) {
	            // make sure we're not pushing back and forth
	            for(j=grp.length-1; j>=0; j--) grp[j].dp -= bottomOverlap;
	            donepositioning = false;
	        }
	        if(!donepositioning) return;
	
	        // no room to fix positioning, delete off-screen points
	
	        // first see how many points we need to delete
	        var deleteCount = 0;
	        for(i=0; i<grp.length; i++) {
	            pti = grp[i];
	            if(pti.pos+pti.dp+pti.size>minPt.pmax) deleteCount++;
	        }
	
	        // start by deleting points whose data is off screen
	        for(i=grp.length-1; i>=0; i--) {
	            if(deleteCount<=0) break;
	            pti = grp[i];
	
	            // pos has already been constrained to [pmin,pmax]
	            // so look for points close to that to delete
	            if(pti.pos>minPt.pmax-1) {
	                pti.del = true;
	                deleteCount--;
	            }
	        }
	        for(i=0; i<grp.length; i++) {
	            if(deleteCount<=0) break;
	            pti = grp[i];
	
	            // pos has already been constrained to [pmin,pmax]
	            // so look for points close to that to delete
	            if(pti.pos<minPt.pmin+1) {
	                pti.del = true;
	                deleteCount--;
	
	                // shift the whole group minus into this new space
	                bottomOverlap = pti.size*2;
	                for(j=grp.length-1; j>=0; j--) grp[j].dp -= bottomOverlap;
	            }
	        }
	        // then delete points that go off the bottom
	        for(i=grp.length-1; i>=0; i--) {
	            if(deleteCount<=0) break;
	            pti = grp[i];
	            if(pti.pos+pti.dp+pti.size>minPt.pmax) {
	                pti.del = true;
	                deleteCount--;
	            }
	        }
	    }
	
	    // loop through groups, combining them if they overlap,
	    // until nothing moves
	    while(!donepositioning && nummoves<=hoverData.length) {
	        // to avoid infinite loops, don't move more times
	        // than there are traces
	        nummoves++;
	
	        // assume nothing will move in this iteration,
	        // reverse this if it does
	        donepositioning = true;
	        i = 0;
	        while(i<pointgroups.length-1) {
	                // the higher (g0) and lower (g1) point group
	            var g0 = pointgroups[i],
	                g1 = pointgroups[i+1],
	
	                // the lowest point in the higher group (p0)
	                // the highest point in the lower group (p1)
	                p0 = g0[g0.length-1],
	                p1 = g1[0];
	            topOverlap = p0.pos+p0.dp+p0.size-p1.pos-p1.dp+p1.size;
	
	            //Only group points that lie on the same axes
	            if(topOverlap>0.01 && (p0.pmin === p1.pmin) && (p0.pmax === p1.pmax)) {
	                // push the new point(s) added to this group out of the way
	                for(j=g1.length-1; j>=0; j--) g1[j].dp += topOverlap;
	
	                // add them to the group
	                g0.push.apply(g0,g1);
	                pointgroups.splice(i+1,1);
	
	                // adjust for minimum average movement
	                sumdp = 0;
	                for(j=g0.length-1; j>=0; j--) sumdp += g0[j].dp;
	                bottomOverlap = sumdp/g0.length;
	                for(j=g0.length-1; j>=0; j--) g0[j].dp -= bottomOverlap;
	                donepositioning = false;
	            }
	            else i++;
	        }
	
	        // check if we're going off the plot on either side and fix
	        pointgroups.forEach(constrainGroup);
	    }
	
	    // now put these offsets into hoverData
	    for(i=pointgroups.length-1; i>=0; i--) {
	        var grp = pointgroups[i];
	        for(j=grp.length-1; j>=0; j--) {
	            var pt = grp[j],
	                hoverPt = hoverData[pt.i];
	            hoverPt.offset = pt.dp;
	            hoverPt.del = pt.del;
	        }
	    }
	}
	
	function alignHoverText(hoverLabels, rotateLabels) {
	    // finally set the text positioning relative to the data and draw the
	    // box around it
	    hoverLabels.each(function(d) {
	        var g = d3.select(this);
	        if(d.del) {
	            g.remove();
	            return;
	        }
	        var horzSign = d.anchor==='end' ? -1 : 1,
	            tx = g.select('text.nums'),
	            alignShift = {start: 1, end: -1, middle: 0}[d.anchor],
	            txx = alignShift*(HOVERARROWSIZE+HOVERTEXTPAD),
	            tx2x = txx+alignShift*(d.txwidth+HOVERTEXTPAD),
	            offsetX = 0,
	            offsetY = d.offset;
	        if(d.anchor==='middle') {
	            txx-=d.tx2width/2;
	            tx2x-=d.tx2width/2;
	        }
	        if(rotateLabels) {
	            offsetY *= -YSHIFTY;
	            offsetX = d.offset*YSHIFTX;
	        }
	
	        g.select('path').attr('d',d.anchor==='middle' ?
	            // middle aligned: rect centered on data
	            ('M-'+(d.bx/2)+',-'+(d.by/2)+'h'+d.bx+'v'+d.by+'h-'+d.bx+'Z') :
	            // left or right aligned: side rect with arrow to data
	            ('M0,0L'+(horzSign*HOVERARROWSIZE+offsetX)+','+(HOVERARROWSIZE+offsetY)+
	                'v'+(d.by/2-HOVERARROWSIZE)+
	                'h'+(horzSign*d.bx)+
	                'v-'+d.by+
	                'H'+(horzSign*HOVERARROWSIZE+offsetX)+
	                'V'+(offsetY-HOVERARROWSIZE)+
	                'Z'));
	
	        tx.call(Drawing.setPosition,
	                txx+offsetX, offsetY+d.ty0-d.by/2+HOVERTEXTPAD)
	            .selectAll('tspan.line')
	                .attr({
	                    x: tx.attr('x'),
	                    y: tx.attr('y')
	                });
	
	        if(d.tx2width) {
	            g.select('text.name, text.name tspan.line')
	                .call(Drawing.setPosition,
	                    tx2x+alignShift*HOVERTEXTPAD+offsetX,
	                    offsetY+d.ty0-d.by/2+HOVERTEXTPAD);
	            g.select('rect')
	                .call(Drawing.setRect,
	                    tx2x+(alignShift-1)*d.tx2width/2+offsetX,
	                    offsetY-d.by/2-1,
	                    d.tx2width, d.by+2);
	        }
	    });
	}
	
	function hoverChanged(gd, evt, oldhoverdata) {
	    // don't emit any events if nothing changed or
	    // if fx.hover was called manually
	    if(!evt.target) return false;
	    if(!oldhoverdata || oldhoverdata.length!==gd._hoverdata.length) return true;
	
	    for(var i = oldhoverdata.length-1; i>=0; i--) {
	        var oldPt = oldhoverdata[i],
	            newPt = gd._hoverdata[i];
	        if(oldPt.curveNumber!==newPt.curveNumber ||
	                String(oldPt.pointNumber)!==String(newPt.pointNumber)) {
	            return true;
	        }
	    }
	    return false;
	}
	
	// on click
	fx.click = function(gd,evt) {
	    if(gd._hoverdata && evt && evt.target) {
	        gd.emit('plotly_click', {points: gd._hoverdata});
	        // why do we get a double event without this???
	        if(evt.stopImmediatePropagation) evt.stopImmediatePropagation();
	    }
	};
	
	
	// for bar charts and others with finite-size objects: you must be inside
	// it to see its hover info, so distance is infinite outside.
	// But make distance inside be at least 1/4 MAXDIST, and a little bigger
	// for bigger bars, to prioritize scatter and smaller bars over big bars
	
	// note that for closest mode, two inbox's will get added in quadrature
	// args are (signed) difference from the two opposite edges
	// count one edge as in, so that over continuous ranges you never get a gap
	fx.inbox = function(v0,v1) {
	    if(v0*v1<0 || v0===0) {
	        return constants.MAXDIST*(0.6-0.3/Math.max(3,Math.abs(v0-v1)));
	    }
	    return Infinity;
	};


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	/* global jQuery:false */
	
	var EventEmitter = __webpack_require__(384).EventEmitter;
	
	var Events = {
	
	    init: function(plotObj) {
	
	        /*
	         * If we have already instantiated an emitter for this plot
	         * return early.
	         */
	        if(plotObj._ev instanceof EventEmitter) return plotObj;
	
	        var ev = new EventEmitter();
	
	        /*
	         * Assign to plot._ev while we still live in a land
	         * where plot is a DOM element with stuff attached to it.
	         * In the future we can make plot the event emitter itself.
	         */
	        plotObj._ev = ev;
	
	        /*
	         * Assign bound methods from the ev to the plot object. These methods
	         * will reference the 'this' of plot._ev even though they are methods
	         * of plot. This will keep the event machinery away from the plot object
	         * which currently is often a DOM element but presents an API that will
	         * continue to function when plot becomes an emitter. Not all EventEmitter
	         * methods have been bound to `plot` as some do not currently add value to
	         * the Plotly event API.
	         */
	        plotObj.on = ev.on.bind(ev);
	        plotObj.once = ev.once.bind(ev);
	        plotObj.removeListener = ev.removeListener.bind(ev);
	        plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);
	
	        /*
	         * We must wrap emit to continue to support JQuery events. The idea
	         * is to check to see if the user is using JQuery events, if they are
	         * we emit JQuery events to trigger user handlers as well as the EventEmitter
	         * events.
	         */
	        plotObj.emit = function(event, data) {
	            if(typeof jQuery !== 'undefined') {
	                jQuery(plotObj).trigger(event, data);
	            }
	
	            ev.emit(event, data);
	        };
	
	        return plotObj;
	    },
	
	    /*
	     * This function behaves like jQueries triggerHandler. It calls
	     * all handlers for a particular event and returns the return value
	     * of the LAST handler. This function also triggers jQuery's
	     * triggerHandler for backwards compatibility.
	     */
	    triggerHandler: function(plotObj, event, data) {
	        var jQueryHandlerValue;
	        var nodeEventHandlerValue;
	        /*
	         * If Jquery exists run all its handlers for this event and
	         * collect the return value of the LAST handler function
	         */
	        if(typeof jQuery !== 'undefined') {
	            jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);
	        }
	
	        /*
	         * Now run all the node style event handlers
	         */
	        var ev = plotObj._ev;
	        if(!ev) return jQueryHandlerValue;
	
	        var handlers = ev._events[event];
	        if(!handlers) return jQueryHandlerValue;
	
	        /*
	         * handlers can be function or an array of functions
	         */
	        if(typeof handlers === 'function') handlers = [handlers];
	        var lastHandler = handlers.pop();
	
	        /*
	         * Call all the handlers except the last one.
	         */
	        for(var i = 0; i < handlers.length; i++) {
	            handlers[i](data);
	        }
	
	        /*
	         * Now call the final handler and collect its value
	         */
	        nodeEventHandlerValue = lastHandler(data);
	
	        /*
	         * Return either the jquery handler value if it exists or the
	         * nodeEventHandler value. Jquery event value superceeds nodejs
	         * events for backwards compatability reasons.
	         */
	        return jQueryHandlerValue !== undefined ? jQueryHandlerValue :
	            nodeEventHandlerValue;
	    },
	
	    purge: function(plotObj) {
	        delete plotObj._ev;
	        delete plotObj.on;
	        delete plotObj.once;
	        delete plotObj.removeListener;
	        delete plotObj.removeAllListeners;
	        delete plotObj.emit;
	
	        return plotObj;
	    }
	
	};
	
	module.exports = Events;


/***/ },
/* 384 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	
	var constants = __webpack_require__(352);
	
	
	var dragElement = module.exports = {};
	
	dragElement.align = __webpack_require__(386);
	dragElement.getCursor = __webpack_require__(387);
	
	var unhover = __webpack_require__(388);
	dragElement.unhover = unhover.wrapped;
	dragElement.unhoverRaw = unhover.raw;
	
	/**
	 * Abstracts click & drag interactions
	 * @param {object} options with keys:
	 *      element (required) the DOM element to drag
	 *      prepFn (optional) function(event, startX, startY)
	 *          executed on mousedown
	 *          startX and startY are the clientX and clientY pixel position
	 *          of the mousedown event
	 *      moveFn (optional) function(dx, dy, dragged)
	 *          executed on move
	 *          dx and dy are the net pixel offset of the drag,
	 *          dragged is true/false, has the mouse moved enough to
	 *          constitute a drag
	 *      doneFn (optional) function(dragged, numClicks)
	 *          executed on mouseup, or mouseout of window since
	 *          we don't get events after that
	 *          dragged is as in moveFn
	 *          numClicks is how many clicks we've registered within
	 *          a doubleclick time
	 */
	dragElement.init = function init(options) {
	    var gd = Lib.getPlotDiv(options.element) || {},
	        numClicks = 1,
	        DBLCLICKDELAY = constants.DBLCLICKDELAY,
	        startX,
	        startY,
	        newMouseDownTime,
	        dragCover,
	        initialTarget;
	
	    if(!gd._mouseDownTime) gd._mouseDownTime = 0;
	
	    function onStart(e) {
	        // make dragging and dragged into properties of gd
	        // so that others can look at and modify them
	        gd._dragged = false;
	        gd._dragging = true;
	        startX = e.clientX;
	        startY = e.clientY;
	        initialTarget = e.target;
	
	        newMouseDownTime = (new Date()).getTime();
	        if(newMouseDownTime - gd._mouseDownTime < DBLCLICKDELAY) {
	            // in a click train
	            numClicks += 1;
	        }
	        else {
	            // new click train
	            numClicks = 1;
	            gd._mouseDownTime = newMouseDownTime;
	        }
	
	        if(options.prepFn) options.prepFn(e, startX, startY);
	
	        dragCover = coverSlip();
	
	        dragCover.onmousemove = onMove;
	        dragCover.onmouseup = onDone;
	        dragCover.onmouseout = onDone;
	
	        dragCover.style.cursor = window.getComputedStyle(options.element).cursor;
	
	        return Lib.pauseEvent(e);
	    }
	
	    function onMove(e) {
	        var dx = e.clientX - startX,
	            dy = e.clientY - startY,
	            minDrag = options.minDrag || constants.MINDRAG;
	
	        if(Math.abs(dx) < minDrag) dx = 0;
	        if(Math.abs(dy) < minDrag) dy = 0;
	        if(dx||dy) {
	            gd._dragged = true;
	            dragElement.unhover(gd);
	        }
	
	        if(options.moveFn) options.moveFn(dx, dy, gd._dragged);
	
	        return Lib.pauseEvent(e);
	    }
	
	    function onDone(e) {
	        dragCover.onmousemove = null;
	        dragCover.onmouseup = null;
	        dragCover.onmouseout = null;
	        Lib.removeElement(dragCover);
	
	        if(!gd._dragging) {
	            gd._dragged = false;
	            return;
	        }
	        gd._dragging = false;
	
	        // don't count as a dblClick unless the mouseUp is also within
	        // the dblclick delay
	        if((new Date()).getTime() - gd._mouseDownTime > DBLCLICKDELAY) {
	            numClicks = Math.max(numClicks - 1, 1);
	        }
	
	        if(options.doneFn) options.doneFn(gd._dragged, numClicks);
	
	        if(!gd._dragged) {
	            var e2 = document.createEvent('MouseEvents');
	            e2.initEvent('click', true, true);
	            initialTarget.dispatchEvent(e2);
	        }
	
	        finishDrag(gd);
	
	        gd._dragged = false;
	
	        return Lib.pauseEvent(e);
	    }
	
	    options.element.onmousedown = onStart;
	    options.element.style.pointerEvents = 'all';
	};
	
	function coverSlip() {
	    var cover = document.createElement('div');
	
	    cover.className = 'dragcover';
	    var cStyle = cover.style;
	    cStyle.position = 'fixed';
	    cStyle.left = 0;
	    cStyle.right = 0;
	    cStyle.top = 0;
	    cStyle.bottom = 0;
	    cStyle.zIndex = 999999999;
	    cStyle.background = 'none';
	
	    document.body.appendChild(cover);
	
	    return cover;
	}
	
	function finishDrag(gd) {
	    gd._dragging = false;
	    if(gd._replotPending) Plotly.plot(gd);
	}


/***/ },
/* 386 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	// for automatic alignment on dragging, <1/3 means left align,
	// >2/3 means right, and between is center. Pick the right fraction
	// based on where you are, and return the fraction corresponding to
	// that position on the object
	module.exports = function align(v, dv, v0, v1, anchor) {
	    var vmin = (v - v0) / (v1 - v0),
	        vmax = vmin + dv / (v1 - v0),
	        vc = (vmin + vmax) / 2;
	
	    // explicitly specified anchor
	    if(anchor === 'left' || anchor === 'bottom') return vmin;
	    if(anchor === 'center' || anchor === 'middle') return vc;
	    if(anchor === 'right' || anchor === 'top') return vmax;
	
	    // automatic based on position
	    if(vmin < (2/3) - vc) return vmin;
	    if(vmax > (4/3) - vc) return vmax;
	    return vc;
	};


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	
	// set cursors pointing toward the closest corner/side,
	// to indicate alignment
	// x and y are 0-1, fractions of the plot area
	var cursorset = [
	    ['sw-resize', 's-resize', 'se-resize'],
	    ['w-resize', 'move', 'e-resize'],
	    ['nw-resize', 'n-resize', 'ne-resize']
	];
	
	module.exports = function getCursor(x, y, xanchor, yanchor) {
	    if(xanchor === 'left') x=0;
	    else if(xanchor === 'center') x=1;
	    else if(xanchor === 'right') x=2;
	    else x = Lib.constrain(Math.floor(x * 3), 0, 2);
	
	    if(yanchor === 'bottom') y = 0;
	    else if(yanchor === 'middle') y = 1;
	    else if(yanchor === 'top') y = 2;
	    else y = Lib.constrain(Math.floor(y * 3), 0, 2);
	
	    return cursorset[y][x];
	};


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	var Events = __webpack_require__(383);
	
	
	var unhover = module.exports = {};
	
	
	unhover.wrapped = function(gd, evt, subplot) {
	    if(typeof gd === 'string') gd = document.getElementById(gd);
	
	    // Important, clear any queued hovers
	    if(gd._hoverTimer) {
	        clearTimeout(gd._hoverTimer);
	        gd._hoverTimer = undefined;
	    }
	
	    unhover.raw(gd, evt, subplot);
	};
	
	
	// remove hover effects on mouse out, and emit unhover event
	unhover.raw = function unhoverRaw(gd, evt) {
	    var fullLayout = gd._fullLayout;
	
	    if(!evt) evt = {};
	    if(evt.target &&
	       Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {
	        return;
	    }
	
	    fullLayout._hoverlayer.selectAll('g').remove();
	
	    if(evt.target && gd._hoverdata) {
	        gd.emit('plotly_unhover', {points: gd._hoverdata});
	    }
	
	    gd._hoverdata = undefined;
	};


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var tinycolor = __webpack_require__(315);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var svgTextUtils = __webpack_require__(326);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var setCursor = __webpack_require__(390);
	var dragElement = __webpack_require__(385);
	
	var Axes = __webpack_require__(338);
	var prepSelect = __webpack_require__(391);
	var constants = __webpack_require__(352);
	
	
	// flag for showing "doubleclick to zoom out" only at the beginning
	var SHOWZOOMOUTTIP = true;
	
	// dragBox: create an element to drag one or more axis ends
	// inputs:
	//      plotinfo - which subplot are we making dragboxes on?
	//      x,y,w,h - left, top, width, height of the box
	//      ns - how does this drag the vertical axis?
	//          'n' - top only
	//          's' - bottom only
	//          'ns' - top and bottom together, difference unchanged
	//      ew - same for horizontal axis
	module.exports = function dragBox(gd, plotinfo, x, y, w, h, ns, ew) {
	    // mouseDown stores ms of first mousedown event in the last
	    // DBLCLICKDELAY ms on the drag bars
	    // numClicks stores how many mousedowns have been seen
	    // within DBLCLICKDELAY so we can check for click or doubleclick events
	    // dragged stores whether a drag has occurred, so we don't have to
	    // redraw unnecessarily, ie if no move bigger than MINDRAG or MINZOOM px
	    var fullLayout = gd._fullLayout,
	        // if we're dragging two axes at once, also drag overlays
	        subplots = [plotinfo].concat((ns && ew) ? plotinfo.overlays : []),
	        xa = [plotinfo.x()],
	        ya = [plotinfo.y()],
	        pw = xa[0]._length,
	        ph = ya[0]._length,
	        MINDRAG = constants.MINDRAG,
	        MINZOOM = constants.MINZOOM;
	
	    for(var i = 1; i < subplots.length; i++) {
	        var subplotXa = subplots[i].x(),
	            subplotYa = subplots[i].y();
	        if(xa.indexOf(subplotXa) === -1) xa.push(subplotXa);
	        if(ya.indexOf(subplotYa) === -1) ya.push(subplotYa);
	    }
	
	    function isDirectionActive(axList, activeVal) {
	        for(var i = 0; i < axList.length; i++) {
	            if(!axList[i].fixedrange) return activeVal;
	        }
	        return '';
	    }
	
	    var allaxes = xa.concat(ya),
	        xActive = isDirectionActive(xa, ew),
	        yActive = isDirectionActive(ya, ns),
	        cursor = getDragCursor(yActive + xActive, fullLayout.dragmode),
	        dragClass = ns + ew + 'drag';
	
	    var dragger3 = plotinfo.draglayer.selectAll('.' + dragClass).data([0]);
	    dragger3.enter().append('rect')
	        .classed('drag', true)
	        .classed(dragClass, true)
	        .style({fill: 'transparent', 'stroke-width': 0})
	        .attr('data-subplot', plotinfo.id);
	    dragger3.call(Drawing.setRect, x, y, w, h)
	        .call(setCursor,cursor);
	    var dragger = dragger3.node();
	
	    // still need to make the element if the axes are disabled
	    // but nuke its events (except for maindrag which needs them for hover)
	    // and stop there
	    if(!yActive && !xActive) {
	        dragger.onmousedown = null;
	        dragger.style.pointerEvents = (ns + ew === 'nsew') ? 'all' : 'none';
	        return dragger;
	    }
	
	    function forceNumbers(axRange) {
	        axRange[0] = Number(axRange[0]);
	        axRange[1] = Number(axRange[1]);
	    }
	
	    var dragOptions = {
	        element: dragger,
	        gd: gd,
	        plotinfo: plotinfo,
	        xaxes: xa,
	        yaxes: ya,
	        doubleclick: doubleClick,
	        prepFn: function(e, startX, startY) {
	            var dragModeNow = gd._fullLayout.dragmode;
	            if(ns + ew === 'nsew') {
	                // main dragger handles all drag modes, and changes
	                // to pan (or to zoom if it already is pan) on shift
	                if(e.shiftKey) {
	                    if(dragModeNow === 'pan') dragModeNow = 'zoom';
	                    else dragModeNow = 'pan';
	                }
	            }
	            // all other draggers just pan
	            else dragModeNow = 'pan';
	
	            if(dragModeNow === 'lasso') dragOptions.minDrag = 1;
	            else dragOptions.minDrag = undefined;
	
	            if(dragModeNow === 'zoom') {
	                dragOptions.moveFn = zoomMove;
	                dragOptions.doneFn = zoomDone;
	                zoomPrep(e, startX, startY);
	            }
	            else if(dragModeNow === 'pan') {
	                dragOptions.moveFn = plotDrag;
	                dragOptions.doneFn = dragDone;
	                clearSelect();
	            }
	            else if(dragModeNow === 'select' || dragModeNow === 'lasso') {
	                prepSelect(e, startX, startY, dragOptions, dragModeNow);
	            }
	        }
	    };
	
	    dragElement.init(dragOptions);
	
	    var zoomlayer = gd._fullLayout._zoomlayer,
	        xs = plotinfo.x()._offset,
	        ys = plotinfo.y()._offset,
	        x0,
	        y0,
	        box,
	        lum,
	        path0,
	        dimmed,
	        zoomMode,
	        zb,
	        corners;
	
	    function zoomPrep(e, startX, startY) {
	        var dragBBox = dragger.getBoundingClientRect();
	        x0 = startX - dragBBox.left;
	        y0 = startY - dragBBox.top;
	        box = {l: x0, r: x0, w: 0, t: y0, b: y0, h: 0};
	        lum = gd._hmpixcount ?
	            (gd._hmlumcount / gd._hmpixcount) :
	            tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();
	        path0 = 'M0,0H'+pw+'V'+ph+'H0V0';
	        dimmed = false;
	        zoomMode = 'xy';
	
	        zb = zoomlayer.append('path')
	            .attr('class', 'zoombox')
	            .style({
	                'fill': lum>0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
	                'stroke-width': 0
	            })
	            .attr('transform','translate(' + xs + ', ' + ys + ')')
	            .attr('d', path0 + 'Z');
	
	        corners = zoomlayer.append('path')
	            .attr('class', 'zoombox-corners')
	            .style({
	                fill: Color.background,
	                stroke: Color.defaultLine,
	                'stroke-width': 1,
	                opacity: 0
	            })
	            .attr('transform','translate(' + xs + ', ' + ys + ')')
	            .attr('d','M0,0Z');
	
	        clearSelect();
	        for(var i = 0; i < allaxes.length; i++) forceNumbers(allaxes[i].range);
	    }
	
	    function clearSelect() {
	        // until we get around to persistent selections, remove the outline
	        // here. The selection itself will be removed when the plot redraws
	        // at the end.
	        zoomlayer.selectAll('.select-outline').remove();
	    }
	
	    function zoomMove(dx0, dy0) {
	        var x1 = Math.max(0, Math.min(pw, dx0 + x0)),
	            y1 = Math.max(0, Math.min(ph, dy0 + y0)),
	            dx = Math.abs(x1 - x0),
	            dy = Math.abs(y1 - y0),
	            clen = Math.floor(Math.min(dy, dx, MINZOOM) / 2);
	
	        box.l = Math.min(x0, x1);
	        box.r = Math.max(x0, x1);
	        box.t = Math.min(y0, y1);
	        box.b = Math.max(y0, y1);
	
	        // look for small drags in one direction or the other,
	        // and only drag the other axis
	        if(!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {
	            if(dx < MINDRAG) {
	                zoomMode = '';
	                box.r = box.l;
	                box.t = box.b;
	                corners.attr('d', 'M0,0Z');
	            }
	            else {
	                box.t = 0;
	                box.b = ph;
	                zoomMode = 'x';
	                corners.attr('d',
	                    'M' + (box.l - 0.5) + ',' + (y0 - MINZOOM - 0.5) +
	                    'h-3v' + (2 * MINZOOM + 1) + 'h3ZM' +
	                    (box.r + 0.5) + ',' + (y0 - MINZOOM - 0.5) +
	                    'h3v' + (2 * MINZOOM + 1) + 'h-3Z');
	            }
	        }
	        else if(!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {
	            box.l = 0;
	            box.r = pw;
	            zoomMode = 'y';
	            corners.attr('d',
	                'M' + (x0 - MINZOOM - 0.5) + ',' + (box.t - 0.5) +
	                'v-3h' + (2 * MINZOOM + 1) + 'v3ZM' +
	                (x0 - MINZOOM - 0.5) + ',' + (box.b + 0.5) +
	                'v3h' + (2 * MINZOOM + 1) + 'v-3Z');
	        }
	        else {
	            zoomMode = 'xy';
	            corners.attr('d',
	                'M'+(box.l-3.5)+','+(box.t-0.5+clen)+'h3v'+(-clen)+
	                        'h'+clen+'v-3h-'+(clen+3)+'ZM'+
	                    (box.r+3.5)+','+(box.t-0.5+clen)+'h-3v'+(-clen)+
	                        'h'+(-clen)+'v-3h'+(clen+3)+'ZM'+
	                    (box.r+3.5)+','+(box.b+0.5-clen)+'h-3v'+clen+
	                        'h'+(-clen)+'v3h'+(clen+3)+'ZM'+
	                    (box.l-3.5)+','+(box.b+0.5-clen)+'h3v'+clen+
	                        'h'+clen+'v3h-'+(clen+3)+'Z');
	        }
	        box.w = box.r - box.l;
	        box.h = box.b - box.t;
	
	        // Not sure about the addition of window.scrollX/Y...
	        // seems to work but doesn't seem robust.
	        zb.attr('d',
	            path0+'M'+(box.l)+','+(box.t)+'v'+(box.h)+
	            'h'+(box.w)+'v-'+(box.h)+'h-'+(box.w)+'Z');
	        if(!dimmed) {
	            zb.transition()
	                .style('fill', lum>0.2 ? 'rgba(0,0,0,0.4)' :
	                    'rgba(255,255,255,0.3)')
	                .duration(200);
	            corners.transition()
	                .style('opacity',1)
	                .duration(200);
	            dimmed = true;
	        }
	    }
	
	    function zoomAxRanges(axList, r0Fraction, r1Fraction) {
	        var i,
	            axi,
	            axRange;
	
	        for(i = 0; i < axList.length; i++) {
	            axi = axList[i];
	            if(axi.fixedrange) continue;
	
	            axRange = axi.range;
	            axi.range = [
	                axRange[0] + (axRange[1] - axRange[0]) * r0Fraction,
	                axRange[0] + (axRange[1] - axRange[0]) * r1Fraction
	            ];
	        }
	    }
	
	    function zoomDone(dragged, numClicks) {
	        if(Math.min(box.h, box.w) < MINDRAG * 2) {
	            if(numClicks === 2) doubleClick();
	
	            return removeZoombox(gd);
	        }
	
	        if(zoomMode === 'xy' || zoomMode === 'x') zoomAxRanges(xa, box.l / pw, box.r / pw);
	        if(zoomMode === 'xy' || zoomMode === 'y') zoomAxRanges(ya, (ph - box.b) / ph, (ph - box.t) / ph);
	
	        removeZoombox(gd);
	        dragTail(zoomMode);
	
	        if(SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
	            Lib.notifier('Double-click to<br>zoom back out','long');
	            SHOWZOOMOUTTIP = false;
	        }
	    }
	
	    function dragDone(dragged, numClicks) {
	        var singleEnd = (ns + ew).length === 1;
	        if(dragged) dragTail();
	        else if(numClicks === 2 && !singleEnd) doubleClick();
	        else if(numClicks === 1 && singleEnd) {
	            var ax = ns ? ya[0] : xa[0],
	                end = (ns==='s' || ew==='w') ? 0 : 1,
	                attrStr = ax._name + '.range[' + end + ']',
	                initialText = getEndText(ax, end),
	                hAlign = 'left',
	                vAlign = 'middle';
	
	            if(ax.fixedrange) return;
	
	            if(ns) {
	                vAlign = (ns === 'n') ? 'top' : 'bottom';
	                if(ax.side === 'right') hAlign = 'right';
	            }
	            else if(ew === 'e') hAlign = 'right';
	
	            dragger3
	                .call(svgTextUtils.makeEditable, null, {
	                    immediate: true,
	                    background: fullLayout.paper_bgcolor,
	                    text: String(initialText),
	                    fill: ax.tickfont ? ax.tickfont.color : '#444',
	                    horizontalAlign: hAlign,
	                    verticalAlign: vAlign
	                })
	                .on('edit', function(text) {
	                    var v = ax.type==='category' ? ax.c2l(text) : ax.d2l(text);
	                    if(v !== undefined) {
	                        Plotly.relayout(gd, attrStr, v);
	                    }
	                });
	        }
	    }
	
	    // scroll zoom, on all draggers except corners
	    var scrollViewBox = [0,0,pw,ph],
	        // wait a little after scrolling before redrawing
	        redrawTimer = null,
	        REDRAWDELAY = 300,
	        mainplot = plotinfo.mainplot ?
	            fullLayout._plots[plotinfo.mainplot] : plotinfo;
	
	    function zoomWheel(e) {
	        // deactivate mousewheel scrolling on embedded graphs
	        // devs can override this with layout._enablescrollzoom,
	        // but _ ensures this setting won't leave their page
	        if(!gd._context.scrollZoom && !fullLayout._enablescrollzoom) {
	            return;
	        }
	        var pc = gd.querySelector('.plotly');
	
	        // if the plot has scrollbars (more than a tiny excess)
	        // disable scrollzoom too.
	        if(pc.scrollHeight-pc.clientHeight>10 ||
	                pc.scrollWidth-pc.clientWidth>10) {
	            return;
	        }
	
	        clearTimeout(redrawTimer);
	
	        var wheelDelta = -e.deltaY;
	        if(!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;
	        if(!isFinite(wheelDelta)) {
	            console.log('did not find wheel motion attributes', e);
	            return;
	        }
	
	        var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 100),
	            gbb = mainplot.draglayer.select('.nsewdrag')
	                .node().getBoundingClientRect(),
	            xfrac = (e.clientX - gbb.left) / gbb.width,
	            vbx0 = scrollViewBox[0] + scrollViewBox[2]*xfrac,
	            yfrac = (gbb.bottom - e.clientY)/gbb.height,
	            vby0 = scrollViewBox[1]+scrollViewBox[3]*(1-yfrac),
	            i;
	
	        function zoomWheelOneAxis(ax, centerFraction, zoom) {
	            if(ax.fixedrange) return;
	            forceNumbers(ax.range);
	            var axRange = ax.range,
	                v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;
	            ax.range = [v0 + (axRange[0] - v0) * zoom, v0 + (axRange[1] - v0) * zoom];
	        }
	
	        if(ew) {
	            for(i = 0; i < xa.length; i++) zoomWheelOneAxis(xa[i], xfrac, zoom);
	            scrollViewBox[2] *= zoom;
	            scrollViewBox[0] = vbx0 - scrollViewBox[2] * xfrac;
	        }
	        if(ns) {
	            for(i = 0; i < ya.length; i++) zoomWheelOneAxis(ya[i], yfrac, zoom);
	            scrollViewBox[3] *= zoom;
	            scrollViewBox[1] = vby0 - scrollViewBox[3] * (1 - yfrac);
	        }
	
	        // viewbox redraw at first
	        updateSubplots(scrollViewBox);
	        ticksAndAnnotations(ns,ew);
	
	        // then replot after a delay to make sure
	        // no more scrolling is coming
	        redrawTimer = setTimeout(function() {
	            scrollViewBox = [0,0,pw,ph];
	            dragTail();
	        }, REDRAWDELAY);
	
	        return Lib.pauseEvent(e);
	    }
	
	    // everything but the corners gets wheel zoom
	    if(ns.length*ew.length!==1) {
	        // still seems to be some confusion about onwheel vs onmousewheel...
	        if(dragger.onwheel!==undefined) dragger.onwheel = zoomWheel;
	        else if(dragger.onmousewheel!==undefined) dragger.onmousewheel = zoomWheel;
	    }
	
	    // plotDrag: move the plot in response to a drag
	    function plotDrag(dx,dy) {
	        function dragAxList(axList, pix) {
	            for(var i = 0; i < axList.length; i++) {
	                var axi = axList[i];
	                if(!axi.fixedrange) {
	                    axi.range = [axi._r[0] - pix / axi._m, axi._r[1] - pix / axi._m];
	                }
	            }
	        }
	
	        if(xActive === 'ew' || yActive === 'ns') {
	            if(xActive) dragAxList(xa, dx);
	            if(yActive) dragAxList(ya, dy);
	            updateSubplots([xActive ? -dx : 0, yActive ? -dy : 0, pw, ph]);
	            ticksAndAnnotations(yActive, xActive);
	            return;
	        }
	
	        // common transform for dragging one end of an axis
	        // d>0 is compressing scale (cursor is over the plot,
	        //  the axis end should move with the cursor)
	        // d<0 is expanding (cursor is off the plot, axis end moves
	        //  nonlinearly so you can expand far)
	        function dZoom(d) {
	            return 1-((d>=0) ? Math.min(d,0.9) :
	                1/(1/Math.max(d,-0.3)+3.222));
	        }
	
	        // dz: set a new value for one end (0 or 1) of an axis array ax,
	        // and return a pixel shift for that end for the viewbox
	        // based on pixel drag distance d
	        // TODO: this makes (generally non-fatal) errors when you get
	        // near floating point limits
	        function dz(ax, end, d) {
	            var otherEnd = 1 - end,
	                movedi = 0;
	            for(var i = 0; i < ax.length; i++) {
	                var axi = ax[i];
	                if(axi.fixedrange) continue;
	                movedi = i;
	                axi.range[end] = axi._r[otherEnd] +
	                    (axi._r[end] - axi._r[otherEnd]) / dZoom(d / axi._length);
	            }
	            return ax[movedi]._length * (ax[movedi]._r[end] - ax[movedi].range[end]) /
	                (ax[movedi]._r[end] - ax[movedi]._r[otherEnd]);
	        }
	
	        if(xActive === 'w') dx = dz(xa, 0, dx);
	        else if(xActive === 'e') dx = dz(xa, 1, -dx);
	        else if(!xActive) dx = 0;
	
	        if(yActive === 'n') dy = dz(ya, 1, dy);
	        else if(yActive === 's') dy = dz(ya, 0, -dy);
	        else if(!yActive) dy = 0;
	
	        updateSubplots([
	            (xActive === 'w') ? dx : 0,
	            (yActive === 'n') ? dy : 0,
	            pw - dx,
	            ph - dy
	        ]);
	        ticksAndAnnotations(yActive, xActive);
	    }
	
	    function ticksAndAnnotations(ns, ew) {
	        var activeAxIds = [],
	            i;
	
	        function pushActiveAxIds(axList) {
	            for(i = 0; i < axList.length; i++) {
	                if(!axList[i].fixedrange) activeAxIds.push(axList[i]._id);
	            }
	        }
	
	        if(ew) pushActiveAxIds(xa);
	        if(ns) pushActiveAxIds(ya);
	
	        for(i = 0; i < activeAxIds.length; i++) {
	            Axes.doTicks(gd, activeAxIds[i], true);
	        }
	
	        function redrawObjs(objArray, module) {
	            var obji;
	            for(i = 0; i < objArray.length; i++) {
	                obji = objArray[i];
	                if((ew && activeAxIds.indexOf(obji.xref) !== -1) ||
	                    (ns && activeAxIds.indexOf(obji.yref) !== -1)) {
	                    module.draw(gd, i);
	                }
	            }
	        }
	
	        redrawObjs(fullLayout.annotations || [], Plotly.Annotations);
	        redrawObjs(fullLayout.shapes || [], Plotly.Shapes);
	        redrawObjs(fullLayout.images || [], Plotly.Images);
	    }
	
	    function doubleClick() {
	        var doubleClickConfig = gd._context.doubleClick,
	            axList = (xActive ? xa : []).concat(yActive ? ya : []),
	            attrs = {};
	
	        var ax, i, rangeInitial;
	
	        if(doubleClickConfig === 'autosize') {
	            for(i = 0; i < axList.length; i++) {
	                ax = axList[i];
	                if(!ax.fixedrange) attrs[ax._name + '.autorange'] = true;
	            }
	        }
	        else if(doubleClickConfig === 'reset') {
	            for(i = 0; i < axList.length; i++) {
	                ax = axList[i];
	
	                if(!ax._rangeInitial) {
	                    attrs[ax._name + '.autorange'] = true;
	                }
	                else {
	                    rangeInitial = ax._rangeInitial.slice();
	                    attrs[ax._name + '.range[0]'] = rangeInitial[0];
	                    attrs[ax._name + '.range[1]'] = rangeInitial[1];
	                }
	            }
	        }
	        else if(doubleClickConfig === 'reset+autosize') {
	            for(i = 0; i < axList.length; i++) {
	                ax = axList[i];
	
	                if(ax.fixedrange) continue;
	                if(ax._rangeInitial === undefined ||
	                    ax.range[0] === ax._rangeInitial[0] &&
	                    ax.range[1] === ax._rangeInitial[1]
	                ) {
	                    attrs[ax._name + '.autorange'] = true;
	                }
	                else {
	                    rangeInitial = ax._rangeInitial.slice();
	                    attrs[ax._name + '.range[0]'] = rangeInitial[0];
	                    attrs[ax._name + '.range[1]'] = rangeInitial[1];
	                }
	            }
	        }
	
	        gd.emit('plotly_doubleclick', null);
	        Plotly.relayout(gd, attrs);
	    }
	
	    // dragTail - finish a drag event with a redraw
	    function dragTail(zoommode) {
	        var attrs = {};
	        // revert to the previous axis settings, then apply the new ones
	        // through relayout - this lets relayout manage undo/redo
	        for(var i = 0; i < allaxes.length; i++) {
	            var axi = allaxes[i];
	            if(zoommode && zoommode.indexOf(axi._id.charAt(0))===-1) {
	                continue;
	            }
	            if(axi._r[0] !== axi.range[0]) attrs[axi._name+'.range[0]'] = axi.range[0];
	            if(axi._r[1] !== axi.range[1]) attrs[axi._name+'.range[1]'] = axi.range[1];
	
	            axi.range=axi._r.slice();
	        }
	
	        updateSubplots([0,0,pw,ph]);
	        Plotly.relayout(gd,attrs);
	    }
	
	    // updateSubplots - find all plot viewboxes that should be
	    // affected by this drag, and update them. look for all plots
	    // sharing an affected axis (including the one being dragged)
	    function updateSubplots(viewBox) {
	        var plotinfos = fullLayout._plots,
	            subplots = Object.keys(plotinfos);
	
	        for(var i = 0; i < subplots.length; i++) {
	            var subplot = plotinfos[subplots[i]],
	                xa2 = subplot.x(),
	                ya2 = subplot.y(),
	                editX = ew && xa.indexOf(xa2)!==-1 && !xa2.fixedrange,
	                editY = ns && ya.indexOf(ya2)!==-1 && !ya2.fixedrange;
	
	            if(editX || editY) {
	                // plot requires offset position and
	                // clip moves with opposite sign
	                var clipDx = editX ? viewBox[0] : 0,
	                    clipDy = editY ? viewBox[1] : 0,
	                    plotDx = xa2._offset - clipDx,
	                    plotDy = ya2._offset - clipDy;
	
	                var clipId = 'clip' + fullLayout._uid + subplots[i] + 'plot';
	
	                fullLayout._defs.selectAll('#' + clipId)
	                    .attr('transform', 'translate(' + clipDx + ', ' + clipDy + ')');
	                subplot.plot
	                    .attr('transform', 'translate(' + plotDx + ', ' + plotDy + ')');
	            }
	        }
	    }
	
	    return dragger;
	};
	
	function getEndText(ax, end) {
	    var initialVal = ax.range[end],
	        diff = Math.abs(initialVal - ax.range[1 - end]),
	        dig;
	
	    if(ax.type === 'date') {
	        return Lib.ms2DateTime(initialVal, diff);
	    }
	    else if(ax.type==='log') {
	        dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;
	        return d3.format('.' + dig + 'g')(Math.pow(10, initialVal));
	    }
	    else { // linear numeric (or category... but just show numbers here)
	        dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) -
	            Math.floor(Math.log(diff) / Math.LN10) + 4;
	        return d3.format('.'+String(dig)+'g')(initialVal);
	    }
	}
	
	function getDragCursor(nsew, dragmode) {
	    if(!nsew) return 'pointer';
	    if(nsew === 'nsew') {
	        if(dragmode === 'pan') return 'move';
	        return 'crosshair';
	    }
	    return nsew.toLowerCase() + '-resize';
	}
	
	function removeZoombox(gd) {
	    d3.select(gd)
	        .selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners')
	        .remove();
	}


/***/ },
/* 390 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	// works with our CSS cursor classes (see css/_cursor.scss)
	// to apply cursors to d3 single-element selections.
	// omit cursor to revert to the default.
	module.exports = function setCursor(el3, csr) {
	    (el3.attr('class') || '').split(' ').forEach(function(cls) {
	        if(cls.indexOf('cursor-') === 0) el3.classed(cls, false);
	    });
	
	    if(csr) el3.classed('cursor-' + csr, true);
	};


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var polygon = __webpack_require__(392);
	var color = __webpack_require__(333);
	
	var axes = __webpack_require__(338);
	var constants = __webpack_require__(352);
	
	var filteredPolygon = polygon.filter;
	var polygonTester = polygon.tester;
	var MINSELECT = constants.MINSELECT;
	
	function getAxId(ax) { return ax._id; }
	
	module.exports = function prepSelect(e, startX, startY, dragOptions, mode) {
	    var plot = dragOptions.gd._fullLayout._zoomlayer,
	        dragBBox = dragOptions.element.getBoundingClientRect(),
	        xs = dragOptions.plotinfo.x()._offset,
	        ys = dragOptions.plotinfo.y()._offset,
	        x0 = startX - dragBBox.left,
	        y0 = startY - dragBBox.top,
	        x1 = x0,
	        y1 = y0,
	        path0 = 'M' + x0 + ',' + y0,
	        pw = dragOptions.xaxes[0]._length,
	        ph = dragOptions.yaxes[0]._length,
	        xAxisIds = dragOptions.xaxes.map(getAxId),
	        yAxisIds = dragOptions.yaxes.map(getAxId),
	        allAxes = dragOptions.xaxes.concat(dragOptions.yaxes),
	        pts;
	
	    if(mode === 'lasso') {
	        pts = filteredPolygon([[x0, y0]], constants.BENDPX);
	    }
	
	    var outlines = plot.selectAll('path.select-outline').data([1,2]);
	
	    outlines.enter()
	        .append('path')
	        .attr('class', function(d) { return 'select-outline select-outline-' + d; })
	        .attr('transform','translate(' + xs + ', ' + ys + ')')
	        .attr('d', path0 + 'Z');
	
	    var corners = plot.append('path')
	        .attr('class', 'zoombox-corners')
	        .style({
	            fill: color.background,
	            stroke: color.defaultLine,
	            'stroke-width': 1
	        })
	        .attr('transform','translate(' + xs + ', ' + ys + ')')
	        .attr('d','M0,0Z');
	
	
	    // find the traces to search for selection points
	    var searchTraces = [],
	        gd = dragOptions.gd,
	        i,
	        cd,
	        trace,
	        searchInfo,
	        selection = [],
	        eventData;
	    for(i = 0; i < gd.calcdata.length; i++) {
	        cd = gd.calcdata[i];
	        trace = cd[0].trace;
	        if(!trace._module || !trace._module.selectPoints) continue;
	
	        if(dragOptions.subplot) {
	            if(trace.subplot !== dragOptions.subplot) continue;
	
	            searchTraces.push({
	                selectPoints: trace._module.selectPoints,
	                cd: cd,
	                xaxis: dragOptions.xaxes[0],
	                yaxis: dragOptions.yaxes[0]
	            });
	        }
	        else {
	            if(xAxisIds.indexOf(trace.xaxis) === -1) continue;
	            if(yAxisIds.indexOf(trace.yaxis) === -1) continue;
	
	            searchTraces.push({
	                selectPoints: trace._module.selectPoints,
	                cd: cd,
	                xaxis: axes.getFromId(gd, trace.xaxis),
	                yaxis: axes.getFromId(gd, trace.yaxis)
	            });
	        }
	    }
	
	    function axValue(ax) {
	        var index = (ax._id.charAt(0) === 'y') ? 1 : 0;
	        return function(v) { return ax.p2d(v[index]); };
	    }
	
	    function ascending(a, b) { return a - b; }
	
	    dragOptions.moveFn = function(dx0, dy0) {
	        var poly,
	            ax;
	        x1 = Math.max(0, Math.min(pw, dx0 + x0));
	        y1 = Math.max(0, Math.min(ph, dy0 + y0));
	
	        var dx = Math.abs(x1 - x0),
	            dy = Math.abs(y1 - y0);
	
	        if(mode === 'select') {
	            if(dy < Math.min(dx * 0.6, MINSELECT)) {
	                // horizontal motion: make a vertical box
	                poly = polygonTester([[x0, 0], [x0, ph], [x1, ph], [x1, 0]]);
	                // extras to guide users in keeping a straight selection
	                corners.attr('d', 'M' + poly.xmin + ',' + (y0 - MINSELECT) +
	                    'h-4v' + (2 * MINSELECT) + 'h4Z' +
	                    'M' + (poly.xmax - 1) + ',' + (y0 - MINSELECT) +
	                    'h4v' + (2 * MINSELECT) + 'h-4Z');
	
	            }
	            else if(dx < Math.min(dy * 0.6, MINSELECT)) {
	                // vertical motion: make a horizontal box
	                poly = polygonTester([[0, y0], [0, y1], [pw, y1], [pw, y0]]);
	                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + poly.ymin +
	                    'v-4h' + (2 * MINSELECT) + 'v4Z' +
	                    'M' + (x0 - MINSELECT) + ',' + (poly.ymax - 1) +
	                    'v4h' + (2 * MINSELECT) + 'v-4Z');
	            }
	            else {
	                // diagonal motion
	                poly = polygonTester([[x0, y0], [x0, y1], [x1, y1], [x1, y0]]);
	                corners.attr('d','M0,0Z');
	            }
	            outlines.attr('d', 'M' + poly.xmin + ',' + poly.ymin +
	                'H' + (poly.xmax - 1) + 'V' + (poly.ymax - 1) +
	                'H' + poly.xmin + 'Z');
	        }
	        else if(mode === 'lasso') {
	            pts.addPt([x1, y1]);
	            poly = polygonTester(pts.filtered);
	            outlines.attr('d', 'M' + pts.filtered.join('L') + 'Z');
	        }
	
	        selection = [];
	        for(i = 0; i < searchTraces.length; i++) {
	            searchInfo = searchTraces[i];
	            [].push.apply(selection, searchInfo.selectPoints(searchInfo, poly));
	        }
	
	        eventData = {points: selection};
	
	        if(mode === 'select') {
	            var ranges = eventData.range = {},
	                axLetter;
	
	            for(i = 0; i < allAxes.length; i++) {
	                ax = allAxes[i];
	                axLetter = ax._id.charAt(0);
	                ranges[ax._id] = [
	                    ax.p2d(poly[axLetter + 'min']),
	                    ax.p2d(poly[axLetter + 'max'])].sort(ascending);
	            }
	        }
	        else {
	            var dataPts = eventData.lassoPoints = {};
	
	            for(i = 0; i < allAxes.length; i++) {
	                ax = allAxes[i];
	                dataPts[ax._id] = pts.filtered.map(axValue(ax));
	            }
	        }
	        dragOptions.gd.emit('plotly_selecting', eventData);
	    };
	
	    dragOptions.doneFn = function(dragged, numclicks) {
	        corners.remove();
	        if(!dragged && numclicks === 2) {
	            // clear selection on doubleclick
	            outlines.remove();
	            for(i = 0; i < searchTraces.length; i++) {
	                searchInfo = searchTraces[i];
	                searchInfo.selectPoints(searchInfo, false);
	            }
	
	            gd.emit('plotly_deselect', null);
	        }
	        else {
	            dragOptions.gd.emit('plotly_selected', eventData);
	        }
	    };
	};


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var dot = __webpack_require__(323).dot;
	
	var polygon = module.exports = {};
	
	/**
	 * Turn an array of [x, y] pairs into a polygon object
	 * that can test if points are inside it
	 *
	 * @param ptsIn Array of [x, y] pairs
	 *
	 * @returns polygon Object {xmin, xmax, ymin, ymax, pts, contains}
	 *      (x|y)(min|max) are the bounding rect of the polygon
	 *      pts is the original array, with the first pair repeated at the end
	 *      contains is a function: (pt, omitFirstEdge)
	 *          pt is the [x, y] pair to test
	 *          omitFirstEdge truthy means points exactly on the first edge don't
	 *              count. This is for use adding one polygon to another so we
	 *              don't double-count the edge where they meet.
	 *          returns boolean: is pt inside the polygon (including on its edges)
	 */
	polygon.tester = function tester(ptsIn) {
	    var pts = ptsIn.slice(),
	        xmin = pts[0][0],
	        xmax = xmin,
	        ymin = pts[0][1],
	        ymax = ymin;
	
	    pts.push(pts[0]);
	    for(var i = 1; i < pts.length; i++) {
	        xmin = Math.min(xmin, pts[i][0]);
	        xmax = Math.max(xmax, pts[i][0]);
	        ymin = Math.min(ymin, pts[i][1]);
	        ymax = Math.max(ymax, pts[i][1]);
	    }
	
	    // do we have a rectangle? Handle this here, so we can use the same
	    // tester for the rectangular case without sacrificing speed
	
	    var isRect = false,
	        rectFirstEdgeTest;
	
	    if(pts.length === 5) {
	        if(pts[0][0] === pts[1][0]) { // vert, horz, vert, horz
	            if(pts[2][0] === pts[3][0] &&
	                    pts[0][1] === pts[3][1] &&
	                    pts[1][1] === pts[2][1]) {
	                isRect = true;
	                rectFirstEdgeTest = function(pt) { return pt[0] === pts[0][0]; };
	            }
	        }
	        else if(pts[0][1] === pts[1][1]) { // horz, vert, horz, vert
	            if(pts[2][1] === pts[3][1] &&
	                    pts[0][0] === pts[3][0] &&
	                    pts[1][0] === pts[2][0]) {
	                isRect = true;
	                rectFirstEdgeTest = function(pt) { return pt[1] === pts[0][1]; };
	            }
	        }
	    }
	
	    function rectContains(pt, omitFirstEdge) {
	        var x = pt[0],
	            y = pt[1];
	
	        if(x < xmin || x > xmax || y < ymin || y > ymax) {
	            // pt is outside the bounding box of polygon
	            return false;
	        }
	        if(omitFirstEdge && rectFirstEdgeTest(pt)) return false;
	
	        return true;
	    }
	
	    function contains(pt, omitFirstEdge) {
	        var x = pt[0],
	            y = pt[1];
	
	        if(x < xmin || x > xmax || y < ymin || y > ymax) {
	            // pt is outside the bounding box of polygon
	            return false;
	        }
	
	        var imax = pts.length,
	            x1 = pts[0][0],
	            y1 = pts[0][1],
	            crossings = 0,
	            i,
	            x0,
	            y0,
	            xmini,
	            ycross;
	
	        for(i = 1; i < imax; i++) {
	            // find all crossings of a vertical line upward from pt with
	            // polygon segments
	            // crossings exactly at xmax don't count, unless the point is
	            // exactly on the segment, then it counts as inside.
	            x0 = x1;
	            y0 = y1;
	            x1 = pts[i][0];
	            y1 = pts[i][1];
	            xmini = Math.min(x0, x1);
	
	            // outside the bounding box of this segment, it's only a crossing
	            // if it's below the box.
	            if(x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {
	                continue;
	            }
	            else if(y < Math.min(y0, y1)) {
	                // don't count the left-most point of the segment as a crossing
	                // because we don't want to double-count adjacent crossings
	                // UNLESS the polygon turns past vertical at exactly this x
	                // Note that this is repeated below, but we can't factor it out
	                // because
	                if(x !== xmini) crossings++;
	            }
	            // inside the bounding box, check the actual line intercept
	            else {
	                // vertical segment - we know already that the point is exactly
	                // on the segment, so mark the crossing as exactly at the point.
	                if(x1 === x0) ycross = y;
	                // any other angle
	                else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);
	
	                // exactly on the edge: counts as inside the polygon, unless it's the
	                // first edge and we're omitting it.
	                if(y === ycross) {
	                    if(i === 1 && omitFirstEdge) return false;
	                    return true;
	                }
	
	                if(y <= ycross && x !== xmini) crossings++;
	            }
	        }
	
	        // if we've gotten this far, odd crossings means inside, even is outside
	        return crossings % 2 === 1;
	    }
	
	    return {
	        xmin: xmin,
	        xmax: xmax,
	        ymin: ymin,
	        ymax: ymax,
	        pts: pts,
	        contains: isRect ? rectContains : contains,
	        isRect: isRect
	    };
	};
	
	/**
	 * Test if a segment of a points array is bent or straight
	 *
	 * @param pts Array of [x, y] pairs
	 * @param start the index of the proposed start of the straight section
	 * @param end the index of the proposed end point
	 * @param tolerance the max distance off the line connecting start and end
	 *      before the line counts as bent
	 * @returns boolean: true means this segment is bent, false means straight
	 */
	var isBent = polygon.isSegmentBent = function isBent(pts, start, end, tolerance) {
	    var startPt = pts[start],
	        segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]],
	        segmentSquared = dot(segment, segment),
	        segmentLen = Math.sqrt(segmentSquared),
	        unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen],
	        i,
	        part,
	        partParallel;
	
	    for(i = start + 1; i < end; i++) {
	        part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
	        partParallel = dot(part, segment);
	
	        if(partParallel < 0 || partParallel > segmentSquared ||
	            Math.abs(dot(part, unitPerp)) > tolerance) return true;
	    }
	    return false;
	};
	
	/**
	 * Make a filtering polygon, to minimize the number of segments
	 *
	 * @param pts Array of [x, y] pairs (must start with at least 1 pair)
	 * @param tolerance the maximum deviation from straight allowed for
	 *      removing points to simplify the polygon
	 *
	 * @returns Object {addPt, raw, filtered}
	 *      addPt is a function(pt: [x, y] pair) to add a raw point and
	 *          continue filtering
	 *      raw is all the input points
	 *      filtered is the resulting filtered Array of [x, y] pairs
	 */
	polygon.filter = function filter(pts, tolerance) {
	    var ptsFiltered = [pts[0]],
	        doneRawIndex = 0,
	        doneFilteredIndex = 0;
	
	    function addPt(pt) {
	        pts.push(pt);
	        var prevFilterLen = ptsFiltered.length,
	            iLast = doneRawIndex;
	        ptsFiltered.splice(doneFilteredIndex + 1);
	
	        for(var i = iLast + 1; i < pts.length; i++) {
	            if(i === pts.length - 1 || isBent(pts, iLast, i + 1, tolerance)) {
	                ptsFiltered.push(pts[i]);
	                if(ptsFiltered.length < prevFilterLen - 2) {
	                    doneRawIndex = i;
	                    doneFilteredIndex = ptsFiltered.length - 1;
	                }
	                iLast = i;
	            }
	        }
	    }
	
	    if(pts.length > 1) {
	        var lastPt = pts.pop();
	        addPt(lastPt);
	    }
	
	    return {
	        addPt: addPt,
	        raw: pts,
	        filtered: ptsFiltered
	    };
	};


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	var Plotly = __webpack_require__(304);
	var d3 = __webpack_require__(310);
	
	var µ = module.exports = {
	    version: '0.2.2',
	    manager: __webpack_require__(394)
	};
	
	var extendDeepAll = Plotly.Lib.extendDeepAll;
	
	µ.Axis = function module() {
	    var config = {
	        data: [],
	        layout: {}
	    }, inputConfig = {}, liveConfig = {};
	    var svg, container, dispatch = d3.dispatch('hover'), radialScale, angularScale;
	    var exports = {};
	    function render(_container) {
	        container = _container || container;
	        var data = config.data;
	        var axisConfig = config.layout;
	        if (typeof container == 'string' || container.nodeName) container = d3.select(container);
	        container.datum(data).each(function(_data, _index) {
	            var dataOriginal = _data.slice();
	            liveConfig = {
	                data: µ.util.cloneJson(dataOriginal),
	                layout: µ.util.cloneJson(axisConfig)
	            };
	            var colorIndex = 0;
	            dataOriginal.forEach(function(d, i) {
	                if (!d.color) {
	                    d.color = axisConfig.defaultColorRange[colorIndex];
	                    colorIndex = (colorIndex + 1) % axisConfig.defaultColorRange.length;
	                }
	                if (!d.strokeColor) {
	                    d.strokeColor = d.geometry === 'LinePlot' ? d.color : d3.rgb(d.color).darker().toString();
	                }
	                liveConfig.data[i].color = d.color;
	                liveConfig.data[i].strokeColor = d.strokeColor;
	                liveConfig.data[i].strokeDash = d.strokeDash;
	                liveConfig.data[i].strokeSize = d.strokeSize;
	            });
	            var data = dataOriginal.filter(function(d, i) {
	                var visible = d.visible;
	                return typeof visible === 'undefined' || visible === true;
	            });
	            var isStacked = false;
	            var dataWithGroupId = data.map(function(d, i) {
	                isStacked = isStacked || typeof d.groupId !== 'undefined';
	                return d;
	            });
	            if (isStacked) {
	                var grouped = d3.nest().key(function(d, i) {
	                    return typeof d.groupId != 'undefined' ? d.groupId : 'unstacked';
	                }).entries(dataWithGroupId);
	                var dataYStack = [];
	                var stacked = grouped.map(function(d, i) {
	                    if (d.key === 'unstacked') return d.values; else {
	                        var prevArray = d.values[0].r.map(function(d, i) {
	                            return 0;
	                        });
	                        d.values.forEach(function(d, i, a) {
	                            d.yStack = [ prevArray ];
	                            dataYStack.push(prevArray);
	                            prevArray = µ.util.sumArrays(d.r, prevArray);
	                        });
	                        return d.values;
	                    }
	                });
	                data = d3.merge(stacked);
	            }
	            data.forEach(function(d, i) {
	                d.t = Array.isArray(d.t[0]) ? d.t : [ d.t ];
	                d.r = Array.isArray(d.r[0]) ? d.r : [ d.r ];
	            });
	            var radius = Math.min(axisConfig.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;
	            radius = Math.max(10, radius);
	            var chartCenter = [ axisConfig.margin.left + radius, axisConfig.margin.top + radius ];
	            var extent;
	            if (isStacked) {
	                var highestStackedValue = d3.max(µ.util.sumArrays(µ.util.arrayLast(data).r[0], µ.util.arrayLast(dataYStack)));
	                extent = [ 0, highestStackedValue ];
	            } else extent = d3.extent(µ.util.flattenArray(data.map(function(d, i) {
	                return d.r;
	            })));
	            if (axisConfig.radialAxis.domain != µ.DATAEXTENT) extent[0] = 0;
	            radialScale = d3.scale.linear().domain(axisConfig.radialAxis.domain != µ.DATAEXTENT && axisConfig.radialAxis.domain ? axisConfig.radialAxis.domain : extent).range([ 0, radius ]);
	            liveConfig.layout.radialAxis.domain = radialScale.domain();
	            var angularDataMerged = µ.util.flattenArray(data.map(function(d, i) {
	                return d.t;
	            }));
	            var isOrdinal = typeof angularDataMerged[0] === 'string';
	            var ticks;
	            if (isOrdinal) {
	                angularDataMerged = µ.util.deduplicate(angularDataMerged);
	                ticks = angularDataMerged.slice();
	                angularDataMerged = d3.range(angularDataMerged.length);
	                data = data.map(function(d, i) {
	                    var result = d;
	                    d.t = [ angularDataMerged ];
	                    if (isStacked) result.yStack = d.yStack;
	                    return result;
	                });
	            }
	            var hasOnlyLineOrDotPlot = data.filter(function(d, i) {
	                return d.geometry === 'LinePlot' || d.geometry === 'DotPlot';
	            }).length === data.length;
	            var needsEndSpacing = axisConfig.needsEndSpacing === null ? isOrdinal || !hasOnlyLineOrDotPlot : axisConfig.needsEndSpacing;
	            var useProvidedDomain = axisConfig.angularAxis.domain && axisConfig.angularAxis.domain != µ.DATAEXTENT && !isOrdinal && axisConfig.angularAxis.domain[0] >= 0;
	            var angularDomain = useProvidedDomain ? axisConfig.angularAxis.domain : d3.extent(angularDataMerged);
	            var angularDomainStep = Math.abs(angularDataMerged[1] - angularDataMerged[0]);
	            if (hasOnlyLineOrDotPlot && !isOrdinal) angularDomainStep = 0;
	            var angularDomainWithPadding = angularDomain.slice();
	            if (needsEndSpacing && isOrdinal) angularDomainWithPadding[1] += angularDomainStep;
	            var tickCount = axisConfig.angularAxis.ticksCount || 4;
	            if (tickCount > 8) tickCount = tickCount / (tickCount / 8) + tickCount % 8;
	            if (axisConfig.angularAxis.ticksStep) {
	                tickCount = (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / tickCount;
	            }
	            var angularTicksStep = axisConfig.angularAxis.ticksStep || (angularDomainWithPadding[1] - angularDomainWithPadding[0]) / (tickCount * (axisConfig.minorTicks + 1));
	            if (ticks) angularTicksStep = Math.max(Math.round(angularTicksStep), 1);
	            if (!angularDomainWithPadding[2]) angularDomainWithPadding[2] = angularTicksStep;
	            var angularAxisRange = d3.range.apply(this, angularDomainWithPadding);
	            angularAxisRange = angularAxisRange.map(function(d, i) {
	                return parseFloat(d.toPrecision(12));
	            });
	            angularScale = d3.scale.linear().domain(angularDomainWithPadding.slice(0, 2)).range(axisConfig.direction === 'clockwise' ? [ 0, 360 ] : [ 360, 0 ]);
	            liveConfig.layout.angularAxis.domain = angularScale.domain();
	            liveConfig.layout.angularAxis.endPadding = needsEndSpacing ? angularDomainStep : 0;
	            svg = d3.select(this).select('svg.chart-root');
	            if (typeof svg === 'undefined' || svg.empty()) {
	                var skeleton = "<svg xmlns='http://www.w3.org/2000/svg' class='chart-root'>' + '<g class='outer-group'>' + '<g class='chart-group'>' + '<circle class='background-circle'></circle>' + '<g class='geometry-group'></g>' + '<g class='radial axis-group'>' + '<circle class='outside-circle'></circle>' + '</g>' + '<g class='angular axis-group'></g>' + '<g class='guides-group'><line></line><circle r='0'></circle></g>' + '</g>' + '<g class='legend-group'></g>' + '<g class='tooltips-group'></g>' + '<g class='title-group'><text></text></g>' + '</g>' + '</svg>";
	                var doc = new DOMParser().parseFromString(skeleton, 'application/xml');
	                var newSvg = this.appendChild(this.ownerDocument.importNode(doc.documentElement, true));
	                svg = d3.select(newSvg);
	            }
	            svg.select('.guides-group').style({
	                'pointer-events': 'none'
	            });
	            svg.select('.angular.axis-group').style({
	                'pointer-events': 'none'
	            });
	            svg.select('.radial.axis-group').style({
	                'pointer-events': 'none'
	            });
	            var chartGroup = svg.select('.chart-group');
	            var lineStyle = {
	                fill: 'none',
	                stroke: axisConfig.tickColor
	            };
	            var fontStyle = {
	                'font-size': axisConfig.font.size,
	                'font-family': axisConfig.font.family,
	                fill: axisConfig.font.color,
	                'text-shadow': [ '-1px 0px', '1px -1px', '-1px 1px', '1px 1px' ].map(function(d, i) {
	                    return ' ' + d + ' 0 ' + axisConfig.font.outlineColor;
	                }).join(',')
	            };
	            var legendContainer;
	            if (axisConfig.showLegend) {
	                legendContainer = svg.select('.legend-group').attr({
	                    transform: 'translate(' + [ radius, axisConfig.margin.top ] + ')'
	                }).style({
	                    display: 'block'
	                });
	                var elements = data.map(function(d, i) {
	                    var datumClone = µ.util.cloneJson(d);
	                    datumClone.symbol = d.geometry === 'DotPlot' ? d.dotType || 'circle' : d.geometry != 'LinePlot' ? 'square' : 'line';
	                    datumClone.visibleInLegend = typeof d.visibleInLegend === 'undefined' || d.visibleInLegend;
	                    datumClone.color = d.geometry === 'LinePlot' ? d.strokeColor : d.color;
	                    return datumClone;
	                });
	
	                µ.Legend().config({
	                    data: data.map(function(d, i) {
	                        return d.name || 'Element' + i;
	                    }),
	                    legendConfig: extendDeepAll({},
	                        µ.Legend.defaultConfig().legendConfig,
	                        {
	                            container: legendContainer,
	                            elements: elements,
	                            reverseOrder: axisConfig.legend.reverseOrder
	                        }
	                    )
	                })();
	
	                var legendBBox = legendContainer.node().getBBox();
	                radius = Math.min(axisConfig.width - legendBBox.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig.margin.top - axisConfig.margin.bottom) / 2;
	                radius = Math.max(10, radius);
	                chartCenter = [ axisConfig.margin.left + radius, axisConfig.margin.top + radius ];
	                radialScale.range([ 0, radius ]);
	                liveConfig.layout.radialAxis.domain = radialScale.domain();
	                legendContainer.attr('transform', 'translate(' + [ chartCenter[0] + radius, chartCenter[1] - radius ] + ')');
	            } else {
	                legendContainer = svg.select('.legend-group').style({
	                    display: 'none'
	                });
	            }
	            svg.attr({
	                width: axisConfig.width,
	                height: axisConfig.height
	            }).style({
	                opacity: axisConfig.opacity
	            });
	            chartGroup.attr('transform', 'translate(' + chartCenter + ')').style({
	                cursor: 'crosshair'
	            });
	            var centeringOffset = [ (axisConfig.width - (axisConfig.margin.left + axisConfig.margin.right + radius * 2 + (legendBBox ? legendBBox.width : 0))) / 2, (axisConfig.height - (axisConfig.margin.top + axisConfig.margin.bottom + radius * 2)) / 2 ];
	            centeringOffset[0] = Math.max(0, centeringOffset[0]);
	            centeringOffset[1] = Math.max(0, centeringOffset[1]);
	            svg.select('.outer-group').attr('transform', 'translate(' + centeringOffset + ')');
	            if (axisConfig.title) {
	                var title = svg.select('g.title-group text').style(fontStyle).text(axisConfig.title);
	                var titleBBox = title.node().getBBox();
	                title.attr({
	                    x: chartCenter[0] - titleBBox.width / 2,
	                    y: chartCenter[1] - radius - 20
	                });
	            }
	            var radialAxis = svg.select('.radial.axis-group');
	            if (axisConfig.radialAxis.gridLinesVisible) {
	                var gridCircles = radialAxis.selectAll('circle.grid-circle').data(radialScale.ticks(5));
	                gridCircles.enter().append('circle').attr({
	                    'class': 'grid-circle'
	                }).style(lineStyle);
	                gridCircles.attr('r', radialScale);
	                gridCircles.exit().remove();
	            }
	            radialAxis.select('circle.outside-circle').attr({
	                r: radius
	            }).style(lineStyle);
	            var backgroundCircle = svg.select('circle.background-circle').attr({
	                r: radius
	            }).style({
	                fill: axisConfig.backgroundColor,
	                stroke: axisConfig.stroke
	            });
	            function currentAngle(d, i) {
	                return angularScale(d) % 360 + axisConfig.orientation;
	            }
	            if (axisConfig.radialAxis.visible) {
	                var axis = d3.svg.axis().scale(radialScale).ticks(5).tickSize(5);
	                radialAxis.call(axis).attr({
	                    transform: 'rotate(' + axisConfig.radialAxis.orientation + ')'
	                });
	                radialAxis.selectAll('.domain').style(lineStyle);
	                radialAxis.selectAll('g>text').text(function(d, i) {
	                    return this.textContent + axisConfig.radialAxis.ticksSuffix;
	                }).style(fontStyle).style({
	                    'text-anchor': 'start'
	                }).attr({
	                    x: 0,
	                    y: 0,
	                    dx: 0,
	                    dy: 0,
	                    transform: function(d, i) {
	                        if (axisConfig.radialAxis.tickOrientation === 'horizontal') {
	                            return 'rotate(' + -axisConfig.radialAxis.orientation + ') translate(' + [ 0, fontStyle['font-size'] ] + ')';
	                        } else return 'translate(' + [ 0, fontStyle['font-size'] ] + ')';
	                    }
	                });
	                radialAxis.selectAll('g>line').style({
	                    stroke: 'black'
	                });
	            }
	            var angularAxis = svg.select('.angular.axis-group').selectAll('g.angular-tick').data(angularAxisRange);
	            var angularAxisEnter = angularAxis.enter().append('g').classed('angular-tick', true);
	            angularAxis.attr({
	                transform: function(d, i) {
	                    return 'rotate(' + currentAngle(d, i) + ')';
	                }
	            }).style({
	                display: axisConfig.angularAxis.visible ? 'block' : 'none'
	            });
	            angularAxis.exit().remove();
	            angularAxisEnter.append('line').classed('grid-line', true).classed('major', function(d, i) {
	                return i % (axisConfig.minorTicks + 1) == 0;
	            }).classed('minor', function(d, i) {
	                return !(i % (axisConfig.minorTicks + 1) == 0);
	            }).style(lineStyle);
	            angularAxisEnter.selectAll('.minor').style({
	                stroke: axisConfig.minorTickColor
	            });
	            angularAxis.select('line.grid-line').attr({
	                x1: axisConfig.tickLength ? radius - axisConfig.tickLength : 0,
	                x2: radius
	            }).style({
	                display: axisConfig.angularAxis.gridLinesVisible ? 'block' : 'none'
	            });
	            angularAxisEnter.append('text').classed('axis-text', true).style(fontStyle);
	            var ticksText = angularAxis.select('text.axis-text').attr({
	                x: radius + axisConfig.labelOffset,
	                dy: '.35em',
	                transform: function(d, i) {
	                    var angle = currentAngle(d, i);
	                    var rad = radius + axisConfig.labelOffset;
	                    var orient = axisConfig.angularAxis.tickOrientation;
	                    if (orient == 'horizontal') return 'rotate(' + -angle + ' ' + rad + ' 0)'; else if (orient == 'radial') return angle < 270 && angle > 90 ? 'rotate(180 ' + rad + ' 0)' : null; else return 'rotate(' + (angle <= 180 && angle > 0 ? -90 : 90) + ' ' + rad + ' 0)';
	                }
	            }).style({
	                'text-anchor': 'middle',
	                display: axisConfig.angularAxis.labelsVisible ? 'block' : 'none'
	            }).text(function(d, i) {
	                if (i % (axisConfig.minorTicks + 1) != 0) return '';
	                if (ticks) {
	                    return ticks[d] + axisConfig.angularAxis.ticksSuffix;
	                } else return d + axisConfig.angularAxis.ticksSuffix;
	            }).style(fontStyle);
	            if (axisConfig.angularAxis.rewriteTicks) ticksText.text(function(d, i) {
	                if (i % (axisConfig.minorTicks + 1) != 0) return '';
	                return axisConfig.angularAxis.rewriteTicks(this.textContent, i);
	            });
	            var rightmostTickEndX = d3.max(chartGroup.selectAll('.angular-tick text')[0].map(function(d, i) {
	                return d.getCTM().e + d.getBBox().width;
	            }));
	            legendContainer.attr({
	                transform: 'translate(' + [ radius + rightmostTickEndX, axisConfig.margin.top ] + ')'
	            });
	            var hasGeometry = svg.select('g.geometry-group').selectAll('g').size() > 0;
	            var geometryContainer = svg.select('g.geometry-group').selectAll('g.geometry').data(data);
	            geometryContainer.enter().append('g').attr({
	                'class': function(d, i) {
	                    return 'geometry geometry' + i;
	                }
	            });
	            geometryContainer.exit().remove();
	            if (data[0] || hasGeometry) {
	                var geometryConfigs = [];
	                data.forEach(function(d, i) {
	                    var geometryConfig = {};
	                    geometryConfig.radialScale = radialScale;
	                    geometryConfig.angularScale = angularScale;
	                    geometryConfig.container = geometryContainer.filter(function(dB, iB) {
	                        return iB == i;
	                    });
	                    geometryConfig.geometry = d.geometry;
	                    geometryConfig.orientation = axisConfig.orientation;
	                    geometryConfig.direction = axisConfig.direction;
	                    geometryConfig.index = i;
	                    geometryConfigs.push({
	                        data: d,
	                        geometryConfig: geometryConfig
	                    });
	                });
	                var geometryConfigsGrouped = d3.nest().key(function(d, i) {
	                    return typeof d.data.groupId != 'undefined' || 'unstacked';
	                }).entries(geometryConfigs);
	                var geometryConfigsGrouped2 = [];
	                geometryConfigsGrouped.forEach(function(d, i) {
	                    if (d.key === 'unstacked') geometryConfigsGrouped2 = geometryConfigsGrouped2.concat(d.values.map(function(d, i) {
	                        return [ d ];
	                    })); else geometryConfigsGrouped2.push(d.values);
	                });
	                geometryConfigsGrouped2.forEach(function(d, i) {
	                    var geometry;
	                    if (Array.isArray(d)) geometry = d[0].geometryConfig.geometry; else geometry = d.geometryConfig.geometry;
	                    var finalGeometryConfig = d.map(function(dB, iB) {
	                        return extendDeepAll(µ[geometry].defaultConfig(), dB);
	                    });
	                    µ[geometry]().config(finalGeometryConfig)();
	                });
	            }
	            var guides = svg.select('.guides-group');
	            var tooltipContainer = svg.select('.tooltips-group');
	            var angularTooltip = µ.tooltipPanel().config({
	                container: tooltipContainer,
	                fontSize: 8
	            })();
	            var radialTooltip = µ.tooltipPanel().config({
	                container: tooltipContainer,
	                fontSize: 8
	            })();
	            var geometryTooltip = µ.tooltipPanel().config({
	                container: tooltipContainer,
	                hasTick: true
	            })();
	            var angularValue, radialValue;
	            if (!isOrdinal) {
	                var angularGuideLine = guides.select('line').attr({
	                    x1: 0,
	                    y1: 0,
	                    y2: 0
	                }).style({
	                    stroke: 'grey',
	                    'pointer-events': 'none'
	                });
	                chartGroup.on('mousemove.angular-guide', function(d, i) {
	                    var mouseAngle = µ.util.getMousePos(backgroundCircle).angle;
	                    angularGuideLine.attr({
	                        x2: -radius,
	                        transform: 'rotate(' + mouseAngle + ')'
	                    }).style({
	                        opacity: .5
	                    });
	                    var angleWithOriginOffset = (mouseAngle + 180 + 360 - axisConfig.orientation) % 360;
	                    angularValue = angularScale.invert(angleWithOriginOffset);
	                    var pos = µ.util.convertToCartesian(radius + 12, mouseAngle + 180);
	                    angularTooltip.text(µ.util.round(angularValue)).move([ pos[0] + chartCenter[0], pos[1] + chartCenter[1] ]);
	                }).on('mouseout.angular-guide', function(d, i) {
	                    guides.select('line').style({
	                        opacity: 0
	                    });
	                });
	            }
	            var angularGuideCircle = guides.select('circle').style({
	                stroke: 'grey',
	                fill: 'none'
	            });
	            chartGroup.on('mousemove.radial-guide', function(d, i) {
	                var r = µ.util.getMousePos(backgroundCircle).radius;
	                angularGuideCircle.attr({
	                    r: r
	                }).style({
	                    opacity: .5
	                });
	                radialValue = radialScale.invert(µ.util.getMousePos(backgroundCircle).radius);
	                var pos = µ.util.convertToCartesian(r, axisConfig.radialAxis.orientation);
	                radialTooltip.text(µ.util.round(radialValue)).move([ pos[0] + chartCenter[0], pos[1] + chartCenter[1] ]);
	            }).on('mouseout.radial-guide', function(d, i) {
	                angularGuideCircle.style({
	                    opacity: 0
	                });
	                geometryTooltip.hide();
	                angularTooltip.hide();
	                radialTooltip.hide();
	            });
	            svg.selectAll('.geometry-group .mark').on('mouseover.tooltip', function(d, i) {
	                var el = d3.select(this);
	                var color = el.style('fill');
	                var newColor = 'black';
	                var opacity = el.style('opacity') || 1;
	                el.attr({
	                    'data-opacity': opacity
	                });
	                if (color != 'none') {
	                    el.attr({
	                        'data-fill': color
	                    });
	                    newColor = d3.hsl(color).darker().toString();
	                    el.style({
	                        fill: newColor,
	                        opacity: 1
	                    });
	                    var textData = {
	                        t: µ.util.round(d[0]),
	                        r: µ.util.round(d[1])
	                    };
	                    if (isOrdinal) textData.t = ticks[d[0]];
	                    var text = 't: ' + textData.t + ', r: ' + textData.r;
	                    var bbox = this.getBoundingClientRect();
	                    var svgBBox = svg.node().getBoundingClientRect();
	                    var pos = [ bbox.left + bbox.width / 2 - centeringOffset[0] - svgBBox.left, bbox.top + bbox.height / 2 - centeringOffset[1] - svgBBox.top ];
	                    geometryTooltip.config({
	                        color: newColor
	                    }).text(text);
	                    geometryTooltip.move(pos);
	                } else {
	                    color = el.style('stroke');
	                    el.attr({
	                        'data-stroke': color
	                    });
	                    newColor = d3.hsl(color).darker().toString();
	                    el.style({
	                        stroke: newColor,
	                        opacity: 1
	                    });
	                }
	            }).on('mousemove.tooltip', function(d, i) {
	                if (d3.event.which != 0) return false;
	                if (d3.select(this).attr('data-fill')) geometryTooltip.show();
	            }).on('mouseout.tooltip', function(d, i) {
	                geometryTooltip.hide();
	                var el = d3.select(this);
	                var fillColor = el.attr('data-fill');
	                if (fillColor) el.style({
	                    fill: fillColor,
	                    opacity: el.attr('data-opacity')
	                }); else el.style({
	                    stroke: el.attr('data-stroke'),
	                    opacity: el.attr('data-opacity')
	                });
	            });
	        });
	        return exports;
	    }
	    exports.render = function(_container) {
	        render(_container);
	        return this;
	    };
	    exports.config = function(_x) {
	        if (!arguments.length) return config;
	        var xClone = µ.util.cloneJson(_x);
	        xClone.data.forEach(function(d, i) {
	            if (!config.data[i]) config.data[i] = {};
	            extendDeepAll(config.data[i], µ.Axis.defaultConfig().data[0]);
	            extendDeepAll(config.data[i], d);
	        });
	        extendDeepAll(config.layout, µ.Axis.defaultConfig().layout);
	        extendDeepAll(config.layout, xClone.layout);
	        return this;
	    };
	    exports.getLiveConfig = function() {
	        return liveConfig;
	    };
	    exports.getinputConfig = function() {
	        return inputConfig;
	    };
	    exports.radialScale = function(_x) {
	        return radialScale;
	    };
	    exports.angularScale = function(_x) {
	        return angularScale;
	    };
	    exports.svg = function() {
	        return svg;
	    };
	    d3.rebind(exports, dispatch, 'on');
	    return exports;
	};
	
	µ.Axis.defaultConfig = function(d, i) {
	    var config = {
	        data: [ {
	            t: [ 1, 2, 3, 4 ],
	            r: [ 10, 11, 12, 13 ],
	            name: 'Line1',
	            geometry: 'LinePlot',
	            color: null,
	            strokeDash: 'solid',
	            strokeColor: null,
	            strokeSize: '1',
	            visibleInLegend: true,
	            opacity: 1
	        } ],
	        layout: {
	            defaultColorRange: d3.scale.category10().range(),
	            title: null,
	            height: 450,
	            width: 500,
	            margin: {
	                top: 40,
	                right: 40,
	                bottom: 40,
	                left: 40
	            },
	            font: {
	                size: 12,
	                color: 'gray',
	                outlineColor: 'white',
	                family: 'Tahoma, sans-serif'
	            },
	            direction: 'clockwise',
	            orientation: 0,
	            labelOffset: 10,
	            radialAxis: {
	                domain: null,
	                orientation: -45,
	                ticksSuffix: '',
	                visible: true,
	                gridLinesVisible: true,
	                tickOrientation: 'horizontal',
	                rewriteTicks: null
	            },
	            angularAxis: {
	                domain: [ 0, 360 ],
	                ticksSuffix: '',
	                visible: true,
	                gridLinesVisible: true,
	                labelsVisible: true,
	                tickOrientation: 'horizontal',
	                rewriteTicks: null,
	                ticksCount: null,
	                ticksStep: null
	            },
	            minorTicks: 0,
	            tickLength: null,
	            tickColor: 'silver',
	            minorTickColor: '#eee',
	            backgroundColor: 'none',
	            needsEndSpacing: null,
	            showLegend: true,
	            legend: {
	                reverseOrder: false
	            },
	            opacity: 1
	        }
	    };
	    return config;
	};
	
	µ.util = {};
	
	µ.DATAEXTENT = 'dataExtent';
	
	µ.AREA = 'AreaChart';
	
	µ.LINE = 'LinePlot';
	
	µ.DOT = 'DotPlot';
	
	µ.BAR = 'BarChart';
	
	µ.util._override = function(_objA, _objB) {
	    for (var x in _objA) if (x in _objB) _objB[x] = _objA[x];
	};
	
	µ.util._extend = function(_objA, _objB) {
	    for (var x in _objA) _objB[x] = _objA[x];
	};
	
	µ.util._rndSnd = function() {
	    return Math.random() * 2 - 1 + (Math.random() * 2 - 1) + (Math.random() * 2 - 1);
	};
	
	µ.util.dataFromEquation2 = function(_equation, _step) {
	    var step = _step || 6;
	    var data = d3.range(0, 360 + step, step).map(function(deg, index) {
	        var theta = deg * Math.PI / 180;
	        var radius = _equation(theta);
	        return [ deg, radius ];
	    });
	    return data;
	};
	
	µ.util.dataFromEquation = function(_equation, _step, _name) {
	    var step = _step || 6;
	    var t = [], r = [];
	    d3.range(0, 360 + step, step).forEach(function(deg, index) {
	        var theta = deg * Math.PI / 180;
	        var radius = _equation(theta);
	        t.push(deg);
	        r.push(radius);
	    });
	    var result = {
	        t: t,
	        r: r
	    };
	    if (_name) result.name = _name;
	    return result;
	};
	
	µ.util.ensureArray = function(_val, _count) {
	    if (typeof _val === 'undefined') return null;
	    var arr = [].concat(_val);
	    return d3.range(_count).map(function(d, i) {
	        return arr[i] || arr[0];
	    });
	};
	
	µ.util.fillArrays = function(_obj, _valueNames, _count) {
	    _valueNames.forEach(function(d, i) {
	        _obj[d] = µ.util.ensureArray(_obj[d], _count);
	    });
	    return _obj;
	};
	
	µ.util.cloneJson = function(json) {
	    return JSON.parse(JSON.stringify(json));
	};
	
	µ.util.validateKeys = function(obj, keys) {
	    if (typeof keys === 'string') keys = keys.split('.');
	    var next = keys.shift();
	    return obj[next] && (!keys.length || objHasKeys(obj[next], keys));
	};
	
	µ.util.sumArrays = function(a, b) {
	    return d3.zip(a, b).map(function(d, i) {
	        return d3.sum(d);
	    });
	};
	
	µ.util.arrayLast = function(a) {
	    return a[a.length - 1];
	};
	
	µ.util.arrayEqual = function(a, b) {
	    var i = Math.max(a.length, b.length, 1);
	    while (i-- >= 0 && a[i] === b[i]) ;
	    return i === -2;
	};
	
	µ.util.flattenArray = function(arr) {
	    var r = [];
	    while (!µ.util.arrayEqual(r, arr)) {
	        r = arr;
	        arr = [].concat.apply([], arr);
	    }
	    return arr;
	};
	
	µ.util.deduplicate = function(arr) {
	    return arr.filter(function(v, i, a) {
	        return a.indexOf(v) == i;
	    });
	};
	
	µ.util.convertToCartesian = function(radius, theta) {
	    var thetaRadians = theta * Math.PI / 180;
	    var x = radius * Math.cos(thetaRadians);
	    var y = radius * Math.sin(thetaRadians);
	    return [ x, y ];
	};
	
	µ.util.round = function(_value, _digits) {
	    var digits = _digits || 2;
	    var mult = Math.pow(10, digits);
	    return Math.round(_value * mult) / mult;
	};
	
	µ.util.getMousePos = function(_referenceElement) {
	    var mousePos = d3.mouse(_referenceElement.node());
	    var mouseX = mousePos[0];
	    var mouseY = mousePos[1];
	    var mouse = {};
	    mouse.x = mouseX;
	    mouse.y = mouseY;
	    mouse.pos = mousePos;
	    mouse.angle = (Math.atan2(mouseY, mouseX) + Math.PI) * 180 / Math.PI;
	    mouse.radius = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
	    return mouse;
	};
	
	µ.util.duplicatesCount = function(arr) {
	    var uniques = {}, val;
	    var dups = {};
	    for (var i = 0, len = arr.length; i < len; i++) {
	        val = arr[i];
	        if (val in uniques) {
	            uniques[val]++;
	            dups[val] = uniques[val];
	        } else {
	            uniques[val] = 1;
	        }
	    }
	    return dups;
	};
	
	µ.util.duplicates = function(arr) {
	    return Object.keys(µ.util.duplicatesCount(arr));
	};
	
	µ.util.translator = function(obj, sourceBranch, targetBranch, reverse) {
	    if (reverse) {
	        var targetBranchCopy = targetBranch.slice();
	        targetBranch = sourceBranch;
	        sourceBranch = targetBranchCopy;
	    }
	    var value = sourceBranch.reduce(function(previousValue, currentValue) {
	        if (typeof previousValue != 'undefined') return previousValue[currentValue];
	    }, obj);
	    if (typeof value === 'undefined') return;
	    sourceBranch.reduce(function(previousValue, currentValue, index) {
	        if (typeof previousValue == 'undefined') return;
	        if (index === sourceBranch.length - 1) delete previousValue[currentValue];
	        return previousValue[currentValue];
	    }, obj);
	    targetBranch.reduce(function(previousValue, currentValue, index) {
	        if (typeof previousValue[currentValue] === 'undefined') previousValue[currentValue] = {};
	        if (index === targetBranch.length - 1) previousValue[currentValue] = value;
	        return previousValue[currentValue];
	    }, obj);
	};
	
	µ.PolyChart = function module() {
	    var config = [ µ.PolyChart.defaultConfig() ];
	    var dispatch = d3.dispatch('hover');
	    var dashArray = {
	        solid: 'none',
	        dash: [ 5, 2 ],
	        dot: [ 2, 5 ]
	    };
	    var colorScale;
	    function exports() {
	        var geometryConfig = config[0].geometryConfig;
	        var container = geometryConfig.container;
	        if (typeof container == 'string') container = d3.select(container);
	        container.datum(config).each(function(_config, _index) {
	            var isStack = !!_config[0].data.yStack;
	            var data = _config.map(function(d, i) {
	                if (isStack) return d3.zip(d.data.t[0], d.data.r[0], d.data.yStack[0]); else return d3.zip(d.data.t[0], d.data.r[0]);
	            });
	            var angularScale = geometryConfig.angularScale;
	            var domainMin = geometryConfig.radialScale.domain()[0];
	            var generator = {};
	            generator.bar = function(d, i, pI) {
	                var dataConfig = _config[pI].data;
	                var h = geometryConfig.radialScale(d[1]) - geometryConfig.radialScale(0);
	                var stackTop = geometryConfig.radialScale(d[2] || 0);
	                var w = dataConfig.barWidth;
	                d3.select(this).attr({
	                    'class': 'mark bar',
	                    d: 'M' + [ [ h + stackTop, -w / 2 ], [ h + stackTop, w / 2 ], [ stackTop, w / 2 ], [ stackTop, -w / 2 ] ].join('L') + 'Z',
	                    transform: function(d, i) {
	                        return 'rotate(' + (geometryConfig.orientation + angularScale(d[0])) + ')';
	                    }
	                });
	            };
	            generator.dot = function(d, i, pI) {
	                var stackedData = d[2] ? [ d[0], d[1] + d[2] ] : d;
	                var symbol = d3.svg.symbol().size(_config[pI].data.dotSize).type(_config[pI].data.dotType)(d, i);
	                d3.select(this).attr({
	                    'class': 'mark dot',
	                    d: symbol,
	                    transform: function(d, i) {
	                        var coord = convertToCartesian(getPolarCoordinates(stackedData));
	                        return 'translate(' + [ coord.x, coord.y ] + ')';
	                    }
	                });
	            };
	            var line = d3.svg.line.radial().interpolate(_config[0].data.lineInterpolation).radius(function(d) {
	                return geometryConfig.radialScale(d[1]);
	            }).angle(function(d) {
	                return geometryConfig.angularScale(d[0]) * Math.PI / 180;
	            });
	            generator.line = function(d, i, pI) {
	                var lineData = d[2] ? data[pI].map(function(d, i) {
	                    return [ d[0], d[1] + d[2] ];
	                }) : data[pI];
	                d3.select(this).each(generator['dot']).style({
	                    opacity: function(dB, iB) {
	                        return +_config[pI].data.dotVisible;
	                    },
	                    fill: markStyle.stroke(d, i, pI)
	                }).attr({
	                    'class': 'mark dot'
	                });
	                if (i > 0) return;
	                var lineSelection = d3.select(this.parentNode).selectAll('path.line').data([ 0 ]);
	                lineSelection.enter().insert('path');
	                lineSelection.attr({
	                    'class': 'line',
	                    d: line(lineData),
	                    transform: function(dB, iB) {
	                        return 'rotate(' + (geometryConfig.orientation + 90) + ')';
	                    },
	                    'pointer-events': 'none'
	                }).style({
	                    fill: function(dB, iB) {
	                        return markStyle.fill(d, i, pI);
	                    },
	                    'fill-opacity': 0,
	                    stroke: function(dB, iB) {
	                        return markStyle.stroke(d, i, pI);
	                    },
	                    'stroke-width': function(dB, iB) {
	                        return markStyle['stroke-width'](d, i, pI);
	                    },
	                    'stroke-dasharray': function(dB, iB) {
	                        return markStyle['stroke-dasharray'](d, i, pI);
	                    },
	                    opacity: function(dB, iB) {
	                        return markStyle.opacity(d, i, pI);
	                    },
	                    display: function(dB, iB) {
	                        return markStyle.display(d, i, pI);
	                    }
	                });
	            };
	            var angularRange = geometryConfig.angularScale.range();
	            var triangleAngle = Math.abs(angularRange[1] - angularRange[0]) / data[0].length * Math.PI / 180;
	            var arc = d3.svg.arc().startAngle(function(d) {
	                return -triangleAngle / 2;
	            }).endAngle(function(d) {
	                return triangleAngle / 2;
	            }).innerRadius(function(d) {
	                return geometryConfig.radialScale(domainMin + (d[2] || 0));
	            }).outerRadius(function(d) {
	                return geometryConfig.radialScale(domainMin + (d[2] || 0)) + geometryConfig.radialScale(d[1]);
	            });
	            generator.arc = function(d, i, pI) {
	                d3.select(this).attr({
	                    'class': 'mark arc',
	                    d: arc,
	                    transform: function(d, i) {
	                        return 'rotate(' + (geometryConfig.orientation + angularScale(d[0]) + 90) + ')';
	                    }
	                });
	            };
	            var markStyle = {
	                fill: function(d, i, pI) {
	                    return _config[pI].data.color;
	                },
	                stroke: function(d, i, pI) {
	                    return _config[pI].data.strokeColor;
	                },
	                'stroke-width': function(d, i, pI) {
	                    return _config[pI].data.strokeSize + 'px';
	                },
	                'stroke-dasharray': function(d, i, pI) {
	                    return dashArray[_config[pI].data.strokeDash];
	                },
	                opacity: function(d, i, pI) {
	                    return _config[pI].data.opacity;
	                },
	                display: function(d, i, pI) {
	                    return typeof _config[pI].data.visible === 'undefined' || _config[pI].data.visible ? 'block' : 'none';
	                }
	            };
	            var geometryLayer = d3.select(this).selectAll('g.layer').data(data);
	            geometryLayer.enter().append('g').attr({
	                'class': 'layer'
	            });
	            var geometry = geometryLayer.selectAll('path.mark').data(function(d, i) {
	                return d;
	            });
	            geometry.enter().append('path').attr({
	                'class': 'mark'
	            });
	            geometry.style(markStyle).each(generator[geometryConfig.geometryType]);
	            geometry.exit().remove();
	            geometryLayer.exit().remove();
	            function getPolarCoordinates(d, i) {
	                var r = geometryConfig.radialScale(d[1]);
	                var t = (geometryConfig.angularScale(d[0]) + geometryConfig.orientation) * Math.PI / 180;
	                return {
	                    r: r,
	                    t: t
	                };
	            }
	            function convertToCartesian(polarCoordinates) {
	                var x = polarCoordinates.r * Math.cos(polarCoordinates.t);
	                var y = polarCoordinates.r * Math.sin(polarCoordinates.t);
	                return {
	                    x: x,
	                    y: y
	                };
	            }
	        });
	    }
	    exports.config = function(_x) {
	        if (!arguments.length) return config;
	        _x.forEach(function(d, i) {
	            if (!config[i]) config[i] = {};
	            extendDeepAll(config[i], µ.PolyChart.defaultConfig());
	            extendDeepAll(config[i], d);
	        });
	        return this;
	    };
	    exports.getColorScale = function() {
	        return colorScale;
	    };
	    d3.rebind(exports, dispatch, 'on');
	    return exports;
	};
	
	µ.PolyChart.defaultConfig = function() {
	    var config = {
	        data: {
	            name: 'geom1',
	            t: [ [ 1, 2, 3, 4 ] ],
	            r: [ [ 1, 2, 3, 4 ] ],
	            dotType: 'circle',
	            dotSize: 64,
	            dotVisible: false,
	            barWidth: 20,
	            color: '#ffa500',
	            strokeSize: 1,
	            strokeColor: 'silver',
	            strokeDash: 'solid',
	            opacity: 1,
	            index: 0,
	            visible: true,
	            visibleInLegend: true
	        },
	        geometryConfig: {
	            geometry: 'LinePlot',
	            geometryType: 'arc',
	            direction: 'clockwise',
	            orientation: 0,
	            container: 'body',
	            radialScale: null,
	            angularScale: null,
	            colorScale: d3.scale.category20()
	        }
	    };
	    return config;
	};
	
	µ.BarChart = function module() {
	    return µ.PolyChart();
	};
	
	µ.BarChart.defaultConfig = function() {
	    var config = {
	        geometryConfig: {
	            geometryType: 'bar'
	        }
	    };
	    return config;
	};
	
	µ.AreaChart = function module() {
	    return µ.PolyChart();
	};
	
	µ.AreaChart.defaultConfig = function() {
	    var config = {
	        geometryConfig: {
	            geometryType: 'arc'
	        }
	    };
	    return config;
	};
	
	µ.DotPlot = function module() {
	    return µ.PolyChart();
	};
	
	µ.DotPlot.defaultConfig = function() {
	    var config = {
	        geometryConfig: {
	            geometryType: 'dot',
	            dotType: 'circle'
	        }
	    };
	    return config;
	};
	
	µ.LinePlot = function module() {
	    return µ.PolyChart();
	};
	
	µ.LinePlot.defaultConfig = function() {
	    var config = {
	        geometryConfig: {
	            geometryType: 'line'
	        }
	    };
	    return config;
	};
	
	µ.Legend = function module() {
	    var config = µ.Legend.defaultConfig();
	    var dispatch = d3.dispatch('hover');
	    function exports() {
	        var legendConfig = config.legendConfig;
	        var flattenData = config.data.map(function(d, i) {
	            return [].concat(d).map(function(dB, iB) {
	                var element = extendDeepAll({}, legendConfig.elements[i]);
	                element.name = dB;
	                element.color = [].concat(legendConfig.elements[i].color)[iB];
	                return element;
	            });
	        });
	        var data = d3.merge(flattenData);
	        data = data.filter(function(d, i) {
	            return legendConfig.elements[i] && (legendConfig.elements[i].visibleInLegend || typeof legendConfig.elements[i].visibleInLegend === 'undefined');
	        });
	        if (legendConfig.reverseOrder) data = data.reverse();
	        var container = legendConfig.container;
	        if (typeof container == 'string' || container.nodeName) container = d3.select(container);
	        var colors = data.map(function(d, i) {
	            return d.color;
	        });
	        var lineHeight = legendConfig.fontSize;
	        var isContinuous = legendConfig.isContinuous == null ? typeof data[0] === 'number' : legendConfig.isContinuous;
	        var height = isContinuous ? legendConfig.height : lineHeight * data.length;
	        var legendContainerGroup = container.classed('legend-group', true);
	        var svg = legendContainerGroup.selectAll('svg').data([ 0 ]);
	        var svgEnter = svg.enter().append('svg').attr({
	            width: 300,
	            height: height + lineHeight,
	            xmlns: 'http://www.w3.org/2000/svg',
	            'xmlns:xlink': 'http://www.w3.org/1999/xlink',
	            version: '1.1'
	        });
	        svgEnter.append('g').classed('legend-axis', true);
	        svgEnter.append('g').classed('legend-marks', true);
	        var dataNumbered = d3.range(data.length);
	        var colorScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered).range(colors);
	        var dataScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered)[isContinuous ? 'range' : 'rangePoints']([ 0, height ]);
	        var shapeGenerator = function(_type, _size) {
	            var squareSize = _size * 3;
	            if (_type === 'line') {
	                return 'M' + [ [ -_size / 2, -_size / 12 ], [ _size / 2, -_size / 12 ], [ _size / 2, _size / 12 ], [ -_size / 2, _size / 12 ] ] + 'Z';
	            } else if (d3.svg.symbolTypes.indexOf(_type) != -1) return d3.svg.symbol().type(_type).size(squareSize)(); else return d3.svg.symbol().type('square').size(squareSize)();
	        };
	        if (isContinuous) {
	            var gradient = svg.select('.legend-marks').append('defs').append('linearGradient').attr({
	                id: 'grad1',
	                x1: '0%',
	                y1: '0%',
	                x2: '0%',
	                y2: '100%'
	            }).selectAll('stop').data(colors);
	            gradient.enter().append('stop');
	            gradient.attr({
	                offset: function(d, i) {
	                    return i / (colors.length - 1) * 100 + '%';
	                }
	            }).style({
	                'stop-color': function(d, i) {
	                    return d;
	                }
	            });
	            svg.append('rect').classed('legend-mark', true).attr({
	                height: legendConfig.height,
	                width: legendConfig.colorBandWidth,
	                fill: 'url(#grad1)'
	            });
	        } else {
	            var legendElement = svg.select('.legend-marks').selectAll('path.legend-mark').data(data);
	            legendElement.enter().append('path').classed('legend-mark', true);
	            legendElement.attr({
	                transform: function(d, i) {
	                    return 'translate(' + [ lineHeight / 2, dataScale(i) + lineHeight / 2 ] + ')';
	                },
	                d: function(d, i) {
	                    var symbolType = d.symbol;
	                    return shapeGenerator(symbolType, lineHeight);
	                },
	                fill: function(d, i) {
	                    return colorScale(i);
	                }
	            });
	            legendElement.exit().remove();
	        }
	        var legendAxis = d3.svg.axis().scale(dataScale).orient('right');
	        var axis = svg.select('g.legend-axis').attr({
	            transform: 'translate(' + [ isContinuous ? legendConfig.colorBandWidth : lineHeight, lineHeight / 2 ] + ')'
	        }).call(legendAxis);
	        axis.selectAll('.domain').style({
	            fill: 'none',
	            stroke: 'none'
	        });
	        axis.selectAll('line').style({
	            fill: 'none',
	            stroke: isContinuous ? legendConfig.textColor : 'none'
	        });
	        axis.selectAll('text').style({
	            fill: legendConfig.textColor,
	            'font-size': legendConfig.fontSize
	        }).text(function(d, i) {
	            return data[i].name;
	        });
	        return exports;
	    }
	    exports.config = function(_x) {
	        if (!arguments.length) return config;
	        extendDeepAll(config, _x);
	        return this;
	    };
	    d3.rebind(exports, dispatch, 'on');
	    return exports;
	};
	
	µ.Legend.defaultConfig = function(d, i) {
	    var config = {
	        data: [ 'a', 'b', 'c' ],
	        legendConfig: {
	            elements: [ {
	                symbol: 'line',
	                color: 'red'
	            }, {
	                symbol: 'square',
	                color: 'yellow'
	            }, {
	                symbol: 'diamond',
	                color: 'limegreen'
	            } ],
	            height: 150,
	            colorBandWidth: 30,
	            fontSize: 12,
	            container: 'body',
	            isContinuous: null,
	            textColor: 'grey',
	            reverseOrder: false
	        }
	    };
	    return config;
	};
	
	µ.tooltipPanel = function() {
	    var tooltipEl, tooltipTextEl, backgroundEl;
	    var config = {
	        container: null,
	        hasTick: false,
	        fontSize: 12,
	        color: 'white',
	        padding: 5
	    };
	    var id = 'tooltip-' + µ.tooltipPanel.uid++;
	    var tickSize = 10;
	    var exports = function() {
	        tooltipEl = config.container.selectAll('g.' + id).data([ 0 ]);
	        var tooltipEnter = tooltipEl.enter().append('g').classed(id, true).style({
	            'pointer-events': 'none',
	            display: 'none'
	        });
	        backgroundEl = tooltipEnter.append('path').style({
	            fill: 'white',
	            'fill-opacity': .9
	        }).attr({
	            d: 'M0 0'
	        });
	        tooltipTextEl = tooltipEnter.append('text').attr({
	            dx: config.padding + tickSize,
	            dy: +config.fontSize * .3
	        });
	        return exports;
	    };
	    exports.text = function(_text) {
	        var l = d3.hsl(config.color).l;
	        var strokeColor = l >= .5 ? '#aaa' : 'white';
	        var fillColor = l >= .5 ? 'black' : 'white';
	        var text = _text || '';
	        tooltipTextEl.style({
	            fill: fillColor,
	            'font-size': config.fontSize + 'px'
	        }).text(text);
	        var padding = config.padding;
	        var bbox = tooltipTextEl.node().getBBox();
	        var boxStyle = {
	            fill: config.color,
	            stroke: strokeColor,
	            'stroke-width': '2px'
	        };
	        var backGroundW = bbox.width + padding * 2 + tickSize;
	        var backGroundH = bbox.height + padding * 2;
	        backgroundEl.attr({
	            d: 'M' + [ [ tickSize, -backGroundH / 2 ], [ tickSize, -backGroundH / 4 ], [ config.hasTick ? 0 : tickSize, 0 ], [ tickSize, backGroundH / 4 ], [ tickSize, backGroundH / 2 ], [ backGroundW, backGroundH / 2 ], [ backGroundW, -backGroundH / 2 ] ].join('L') + 'Z'
	        }).style(boxStyle);
	        tooltipEl.attr({
	            transform: 'translate(' + [ tickSize, -backGroundH / 2 + padding * 2 ] + ')'
	        });
	        tooltipEl.style({
	            display: 'block'
	        });
	        return exports;
	    };
	    exports.move = function(_pos) {
	        if (!tooltipEl) return;
	        tooltipEl.attr({
	            transform: 'translate(' + [ _pos[0], _pos[1] ] + ')'
	        }).style({
	            display: 'block'
	        });
	        return exports;
	    };
	    exports.hide = function() {
	        if (!tooltipEl) return;
	        tooltipEl.style({
	            display: 'none'
	        });
	        return exports;
	    };
	    exports.show = function() {
	        if (!tooltipEl) return;
	        tooltipEl.style({
	            display: 'block'
	        });
	        return exports;
	    };
	    exports.config = function(_x) {
	        extendDeepAll(config, _x);
	        return exports;
	    };
	    return exports;
	};
	
	µ.tooltipPanel.uid = 1;
	
	µ.adapter = {};
	
	µ.adapter.plotly = function module() {
	    var exports = {};
	    exports.convert = function(_inputConfig, reverse) {
	        var outputConfig = {};
	        if (_inputConfig.data) {
	            outputConfig.data = _inputConfig.data.map(function(d, i) {
	                var r = extendDeepAll({}, d);
	                var toTranslate = [
	                    [ r, [ 'marker', 'color' ], [ 'color' ] ],
	                    [ r, [ 'marker', 'opacity' ], [ 'opacity' ] ],
	                    [ r, [ 'marker', 'line', 'color' ], [ 'strokeColor' ] ],
	                    [ r, [ 'marker', 'line', 'dash' ], [ 'strokeDash' ] ],
	                    [ r, [ 'marker', 'line', 'width' ], [ 'strokeSize' ] ],
	                    [ r, [ 'marker', 'symbol' ], [ 'dotType' ] ],
	                    [ r, [ 'marker', 'size' ], [ 'dotSize' ] ],
	                    [ r, [ 'marker', 'barWidth' ], [ 'barWidth' ] ],
	                    [ r, [ 'line', 'interpolation' ], [ 'lineInterpolation' ] ],
	                    [ r, [ 'showlegend' ], [ 'visibleInLegend' ] ]
	                ];
	                toTranslate.forEach(function(d, i) {
	                    µ.util.translator.apply(null, d.concat(reverse));
	                });
	
	                if (!reverse) delete r.marker;
	                if (reverse) delete r.groupId;
	                if (!reverse) {
	                    if (r.type === 'scatter') {
	                        if (r.mode === 'lines') r.geometry = 'LinePlot'; else if (r.mode === 'markers') r.geometry = 'DotPlot'; else if (r.mode === 'lines+markers') {
	                            r.geometry = 'LinePlot';
	                            r.dotVisible = true;
	                        }
	                    } else if (r.type === 'area') r.geometry = 'AreaChart'; else if (r.type === 'bar') r.geometry = 'BarChart';
	                    delete r.mode;
	                    delete r.type;
	                } else {
	                    if (r.geometry === 'LinePlot') {
	                        r.type = 'scatter';
	                        if (r.dotVisible === true) {
	                            delete r.dotVisible;
	                            r.mode = 'lines+markers';
	                        } else r.mode = 'lines';
	                    } else if (r.geometry === 'DotPlot') {
	                        r.type = 'scatter';
	                        r.mode = 'markers';
	                    } else if (r.geometry === 'AreaChart') r.type = 'area'; else if (r.geometry === 'BarChart') r.type = 'bar';
	                    delete r.geometry;
	                }
	                return r;
	            });
	            if (!reverse && _inputConfig.layout && _inputConfig.layout.barmode === 'stack') {
	                var duplicates = µ.util.duplicates(outputConfig.data.map(function(d, i) {
	                    return d.geometry;
	                }));
	                outputConfig.data.forEach(function(d, i) {
	                    var idx = duplicates.indexOf(d.geometry);
	                    if (idx != -1) outputConfig.data[i].groupId = idx;
	                });
	            }
	        }
	        if (_inputConfig.layout) {
	            var r = extendDeepAll({}, _inputConfig.layout);
	            var toTranslate = [
	                [ r, [ 'plot_bgcolor' ], [ 'backgroundColor' ] ],
	                [ r, [ 'showlegend' ], [ 'showLegend' ] ],
	                [ r, [ 'radialaxis' ], [ 'radialAxis' ] ],
	                [ r, [ 'angularaxis' ], [ 'angularAxis' ] ],
	                [ r.angularaxis, [ 'showline' ], [ 'gridLinesVisible' ] ],
	                [ r.angularaxis, [ 'showticklabels' ], [ 'labelsVisible' ] ],
	                [ r.angularaxis, [ 'nticks' ], [ 'ticksCount' ] ],
	                [ r.angularaxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],
	                [ r.angularaxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],
	                [ r.angularaxis, [ 'range' ], [ 'domain' ] ],
	                [ r.angularaxis, [ 'endpadding' ], [ 'endPadding' ] ],
	                [ r.radialaxis, [ 'showline' ], [ 'gridLinesVisible' ] ],
	                [ r.radialaxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],
	                [ r.radialaxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],
	                [ r.radialaxis, [ 'range' ], [ 'domain' ] ],
	                [ r.angularAxis, [ 'showline' ], [ 'gridLinesVisible' ] ],
	                [ r.angularAxis, [ 'showticklabels' ], [ 'labelsVisible' ] ],
	                [ r.angularAxis, [ 'nticks' ], [ 'ticksCount' ] ],
	                [ r.angularAxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],
	                [ r.angularAxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],
	                [ r.angularAxis, [ 'range' ], [ 'domain' ] ],
	                [ r.angularAxis, [ 'endpadding' ], [ 'endPadding' ] ],
	                [ r.radialAxis, [ 'showline' ], [ 'gridLinesVisible' ] ],
	                [ r.radialAxis, [ 'tickorientation' ], [ 'tickOrientation' ] ],
	                [ r.radialAxis, [ 'ticksuffix' ], [ 'ticksSuffix' ] ],
	                [ r.radialAxis, [ 'range' ], [ 'domain' ] ],
	                [ r.font, [ 'outlinecolor' ], [ 'outlineColor' ] ],
	                [ r.legend, [ 'traceorder' ], [ 'reverseOrder' ] ],
	                [ r, [ 'labeloffset' ], [ 'labelOffset' ] ],
	                [ r, [ 'defaultcolorrange' ], [ 'defaultColorRange' ] ]
	            ];
	            toTranslate.forEach(function(d, i) {
	                µ.util.translator.apply(null, d.concat(reverse));
	            });
	
	            if (!reverse) {
	                if (r.angularAxis && typeof r.angularAxis.ticklen !== 'undefined') r.tickLength = r.angularAxis.ticklen;
	                if (r.angularAxis && typeof r.angularAxis.tickcolor !== 'undefined') r.tickColor = r.angularAxis.tickcolor;
	            } else {
	                if (typeof r.tickLength !== 'undefined') {
	                    r.angularaxis.ticklen = r.tickLength;
	                    delete r.tickLength;
	                }
	                if (r.tickColor) {
	                    r.angularaxis.tickcolor = r.tickColor;
	                    delete r.tickColor;
	                }
	            }
	            if (r.legend && typeof r.legend.reverseOrder != 'boolean') {
	                r.legend.reverseOrder = r.legend.reverseOrder != 'normal';
	            }
	            if (r.legend && typeof r.legend.traceorder == 'boolean') {
	                r.legend.traceorder = r.legend.traceorder ? 'reversed' : 'normal';
	                delete r.legend.reverseOrder;
	            }
	            if (r.margin && typeof r.margin.t != 'undefined') {
	                var source = [ 't', 'r', 'b', 'l', 'pad' ];
	                var target = [ 'top', 'right', 'bottom', 'left', 'pad' ];
	                var margin = {};
	                d3.entries(r.margin).forEach(function(dB, iB) {
	                    margin[target[source.indexOf(dB.key)]] = dB.value;
	                });
	                r.margin = margin;
	            }
	            if (reverse) {
	                delete r.needsEndSpacing;
	                delete r.minorTickColor;
	                delete r.minorTicks;
	                delete r.angularaxis.ticksCount;
	                delete r.angularaxis.ticksCount;
	                delete r.angularaxis.ticksStep;
	                delete r.angularaxis.rewriteTicks;
	                delete r.angularaxis.nticks;
	                delete r.radialaxis.ticksCount;
	                delete r.radialaxis.ticksCount;
	                delete r.radialaxis.ticksStep;
	                delete r.radialaxis.rewriteTicks;
	                delete r.radialaxis.nticks;
	            }
	            outputConfig.layout = r;
	        }
	        return outputConfig;
	    };
	    return exports;
	};


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var d3 = __webpack_require__(310);
	var UndoManager = __webpack_require__(395);
	
	var manager = module.exports = {};
	
	var extendDeepAll = Plotly.Lib.extendDeepAll;
	
	manager.framework = function(_gd) {
	    var config, previousConfigClone, plot, convertedInput, container;
	    var undoManager = new UndoManager();
	
	    function exports(_inputConfig, _container) {
	        if(_container) container = _container;
	        d3.select(d3.select(container).node().parentNode).selectAll('.svg-container>*:not(.chart-root)').remove();
	
	        config = (!config) ?
	            _inputConfig :
	            extendDeepAll(config, _inputConfig);
	
	        if(!plot) plot = Plotly.micropolar.Axis();
	        convertedInput = Plotly.micropolar.adapter.plotly().convert(config);
	        plot.config(convertedInput).render(container);
	        _gd.data = config.data;
	        _gd.layout = config.layout;
	        manager.fillLayout(_gd);
	        return config;
	    }
	    exports.isPolar = true;
	    exports.svg = function() { return plot.svg(); };
	    exports.getConfig = function() { return config; };
	    exports.getLiveConfig = function() {
	        return Plotly.micropolar.adapter.plotly().convert(plot.getLiveConfig(), true);
	    };
	    exports.getLiveScales = function() { return {t: plot.angularScale(), r: plot.radialScale()}; };
	    exports.setUndoPoint = function() {
	        var that = this;
	        var configClone = Plotly.micropolar.util.cloneJson(config);
	        (function(_configClone, _previousConfigClone) {
	            undoManager.add({
	                undo: function() {
	                    //console.log('undo', _previousConfigClone);
	                    if(_previousConfigClone) that(_previousConfigClone);
	                },
	                redo: function() {
	                    //console.log('redo', _configClone);
	                    that(_configClone);
	                }
	            });
	        })(configClone, previousConfigClone);
	        previousConfigClone = Plotly.micropolar.util.cloneJson(configClone);
	    };
	    exports.undo = function() { undoManager.undo(); };
	    exports.redo = function() { undoManager.redo(); };
	    return exports;
	};
	
	manager.fillLayout = function(_gd) {
	    var container = d3.select(_gd).selectAll('.plot-container'),
	        paperDiv = container.selectAll('.svg-container'),
	        paper = _gd.framework && _gd.framework.svg && _gd.framework.svg(),
	        dflts = {
	            width: 800,
	            height: 600,
	            paper_bgcolor: Plotly.Color.background,
	            _container: container,
	            _paperdiv: paperDiv,
	            _paper: paper
	        };
	
	    _gd._fullLayout = extendDeepAll(dflts, _gd.layout);
	};


/***/ },
/* 395 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	//Modified from https://github.com/ArthurClemens/Javascript-Undo-Manager
	//Copyright (c) 2010-2013 Arthur Clemens, arthur@visiblearea.com
	module.exports = function UndoManager() {
	    var undoCommands = [],
	        index = -1,
	        isExecuting = false,
	        callback;
	
	    function execute(command, action) {
	        if(!command) return this;
	
	        isExecuting = true;
	        command[action]();
	        isExecuting = false;
	
	        return this;
	    }
	
	    return {
	        add: function(command) {
	            if(isExecuting) return this;
	            undoCommands.splice(index + 1, undoCommands.length - index);
	            undoCommands.push(command);
	            index = undoCommands.length - 1;
	            return this;
	        },
	        setCallback: function(callbackFunc) { callback = callbackFunc; },
	        undo: function() {
	            var command = undoCommands[index];
	            if(!command) return this;
	            execute(command, 'undo');
	            index -= 1;
	            if(callback) callback(command.undo);
	            return this;
	        },
	        redo: function() {
	            var command = undoCommands[index + 1];
	            if(!command) return this;
	            execute(command, 'redo');
	            index += 1;
	            if(callback) callback(command.redo);
	            return this;
	        },
	        clear: function() {
	            undoCommands = [];
	            index = -1;
	        },
	        hasUndo: function() { return index !== -1; },
	        hasRedo: function() { return index < (undoCommands.length - 1); },
	        getCommands: function() { return undoCommands; },
	        getPreviousCommand: function() { return undoCommands[index-1]; },
	        getIndex: function() { return index; }
	    };
	};


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	exports.attributes = __webpack_require__(354);
	
	exports.supplyDefaults = __webpack_require__(345);
	
	exports.draw = __webpack_require__(397);
	
	exports.hasColorbar = __webpack_require__(344);


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var tinycolor = __webpack_require__(315);
	
	var Plotly = __webpack_require__(304);
	var Plots = __webpack_require__(332);
	var Axes = __webpack_require__(338);
	var dragElement = __webpack_require__(385);
	var Lib = __webpack_require__(309);
	var extendFlat = __webpack_require__(324).extendFlat;
	var setCursor = __webpack_require__(390);
	var Drawing = __webpack_require__(340);
	var Color = __webpack_require__(333);
	var Titles = __webpack_require__(339);
	
	var handleAxisDefaults = __webpack_require__(376);
	var handleAxisPositionDefaults = __webpack_require__(381);
	var axisLayoutAttrs = __webpack_require__(348);
	
	var attributes = __webpack_require__(354);
	
	
	module.exports = function draw(gd, id) {
	    // opts: options object, containing everything from attributes
	    // plus a few others that are the equivalent of the colorbar "data"
	    var opts = {};
	    Object.keys(attributes).forEach(function(k) {
	        opts[k] = null;
	    });
	    // fillcolor can be a d3 scale, domain is z values, range is colors
	    // or leave it out for no fill,
	    // or set to a string constant for single-color fill
	    opts.fillcolor = null;
	    // line.color has the same options as fillcolor
	    opts.line = {color: null, width: null, dash: null};
	    // levels of lines to draw.
	    // note that this DOES NOT determine the extent of the bar
	    // that's given by the domain of fillcolor
	    // (or line.color if no fillcolor domain)
	    opts.levels = {start: null, end: null, size: null};
	    // separate fill levels (for example, heatmap coloring of a
	    // contour map) if this is omitted, fillcolors will be
	    // evaluated halfway between levels
	    opts.filllevels = null;
	
	    function component() {
	        var fullLayout = gd._fullLayout,
	            gs = fullLayout._size;
	        if((typeof opts.fillcolor !== 'function') &&
	                (typeof opts.line.color !== 'function')) {
	            fullLayout._infolayer.selectAll('g.'+id).remove();
	            return;
	        }
	        var zrange = d3.extent(((typeof opts.fillcolor === 'function') ?
	                opts.fillcolor : opts.line.color).domain()),
	            linelevels = [],
	            filllevels = [],
	            l,
	            linecolormap = typeof opts.line.color === 'function' ?
	                opts.line.color : function() { return opts.line.color; },
	            fillcolormap = typeof opts.fillcolor === 'function' ?
	                opts.fillcolor : function() { return opts.fillcolor; };
	
	        var l0 = opts.levels.end + opts.levels.size/100,
	            ls = opts.levels.size,
	            zr0 = (1.001 * zrange[0] - 0.001 * zrange[1]),
	            zr1 = (1.001 * zrange[1] - 0.001 * zrange[0]);
	        for(l = opts.levels.start; (l - l0) * ls < 0; l += ls) {
	            if(l > zr0 && l < zr1) linelevels.push(l);
	        }
	
	        if(typeof opts.fillcolor === 'function') {
	            if(opts.filllevels) {
	                l0 = opts.filllevels.end + opts.filllevels.size / 100;
	                ls = opts.filllevels.size;
	                for(l = opts.filllevels.start; (l - l0) * ls < 0; l += ls) {
	                    if(l > zrange[0] && l < zrange[1]) filllevels.push(l);
	                }
	            }
	            else {
	                filllevels = linelevels.map(function(v) {
	                    return v-opts.levels.size / 2;
	                });
	                filllevels.push(filllevels[filllevels.length - 1] +
	                    opts.levels.size);
	            }
	        }
	        else if(opts.fillcolor && typeof opts.fillcolor==='string') {
	            // doesn't matter what this value is, with a single value
	            // we'll make a single fill rect covering the whole bar
	            filllevels = [0];
	        }
	
	        if(opts.levels.size<0) {
	            linelevels.reverse();
	            filllevels.reverse();
	        }
	
	        // now make a Plotly Axes object to scale with and draw ticks
	        // TODO: does not support orientation other than right
	
	        // we calculate pixel sizes based on the specified graph size,
	        // not the actual (in case something pushed the margins around)
	        // which is a little odd but avoids an odd iterative effect
	        // when the colorbar itself is pushing the margins.
	        // but then the fractional size is calculated based on the
	        // actual graph size, so that the axes will size correctly.
	        var originalPlotHeight = fullLayout.height - fullLayout.margin.t - fullLayout.margin.b,
	            originalPlotWidth = fullLayout.width - fullLayout.margin.l - fullLayout.margin.r,
	            thickPx = Math.round(opts.thickness *
	                (opts.thicknessmode==='fraction' ? originalPlotWidth : 1)),
	            thickFrac = thickPx / gs.w,
	            lenPx = Math.round(opts.len *
	                (opts.lenmode==='fraction' ? originalPlotHeight : 1)),
	            lenFrac = lenPx / gs.h,
	            xpadFrac = opts.xpad/gs.w,
	            yExtraPx = (opts.borderwidth + opts.outlinewidth)/2,
	            ypadFrac = opts.ypad / gs.h,
	
	            // x positioning: do it initially just for left anchor,
	            // then fix at the end (since we don't know the width yet)
	            xLeft = Math.round(opts.x*gs.w + opts.xpad),
	            // for dragging... this is getting a little muddled...
	            xLeftFrac = opts.x - thickFrac *
	                ({middle: 0.5, right: 1}[opts.xanchor]||0),
	
	            // y positioning we can do correctly from the start
	            yBottomFrac = opts.y + lenFrac *
	                (({top: -0.5, bottom: 0.5}[opts.yanchor] || 0) - 0.5),
	            yBottomPx = Math.round(gs.h * (1-yBottomFrac)),
	            yTopPx = yBottomPx-lenPx,
	            titleEl,
	            cbAxisIn = {
	                type: 'linear',
	                range: zrange,
	                tickmode: opts.tickmode,
	                nticks: opts.nticks,
	                tick0: opts.tick0,
	                dtick: opts.dtick,
	                tickvals: opts.tickvals,
	                ticktext: opts.ticktext,
	                ticks: opts.ticks,
	                ticklen: opts.ticklen,
	                tickwidth: opts.tickwidth,
	                tickcolor: opts.tickcolor,
	                showticklabels: opts.showticklabels,
	                tickfont: opts.tickfont,
	                tickangle: opts.tickangle,
	                tickformat: opts.tickformat,
	                exponentformat: opts.exponentformat,
	                showexponent: opts.showexponent,
	                showtickprefix: opts.showtickprefix,
	                tickprefix: opts.tickprefix,
	                showticksuffix: opts.showticksuffix,
	                ticksuffix: opts.ticksuffix,
	                title: opts.title,
	                titlefont: opts.titlefont,
	                anchor: 'free',
	                position: 1
	            },
	            cbAxisOut = {},
	            axisOptions = {
	                letter: 'y',
	                font: fullLayout.font,
	                noHover: true
	            };
	
	        // Coerce w.r.t. Axes layoutAttributes:
	        // re-use axes.js logic without updating _fullData
	        function coerce(attr, dflt) {
	            return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
	        }
	
	        // Prepare the Plotly axis object
	        handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
	        handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
	
	        cbAxisOut._id = 'y' + id;
	        cbAxisOut._gd = gd;
	
	        // position can't go in through supplyDefaults
	        // because that restricts it to [0,1]
	        cbAxisOut.position = opts.x + xpadFrac + thickFrac;
	
	        // save for other callers to access this axis
	        component.axis = cbAxisOut;
	
	        if(['top','bottom'].indexOf(opts.titleside)!==-1) {
	            cbAxisOut.titleside = opts.titleside;
	            cbAxisOut.titlex = opts.x + xpadFrac;
	            cbAxisOut.titley = yBottomFrac +
	                (opts.titleside==='top' ? lenFrac-ypadFrac : ypadFrac);
	        }
	
	        if(opts.line.color && opts.tickmode === 'auto') {
	            cbAxisOut.tickmode = 'linear';
	            cbAxisOut.tick0 = opts.levels.start;
	            var dtick = opts.levels.size;
	            // expand if too many contours, so we don't get too many ticks
	            var autoNtick = Lib.constrain(
	                    (yBottomPx-yTopPx)/50, 4, 15) + 1,
	                dtFactor = (zrange[1]-zrange[0]) /
	                    ((opts.nticks||autoNtick)*dtick);
	            if(dtFactor>1) {
	                var dtexp = Math.pow(10,Math.floor(
	                    Math.log(dtFactor)/Math.LN10));
	                dtick *= dtexp * Lib.roundUp(dtFactor/dtexp,[2,5,10]);
	                // if the contours are at round multiples, reset tick0
	                // so they're still at round multiples. Otherwise,
	                // keep the first label on the first contour level
	                if((Math.abs(opts.levels.start)/
	                        opts.levels.size+1e-6)%1 < 2e-6) {
	                    cbAxisOut.tick0 = 0;
	                }
	            }
	            cbAxisOut.dtick = dtick;
	        }
	
	        // set domain after init, because we may want to
	        // allow it outside [0,1]
	        cbAxisOut.domain = [
	            yBottomFrac+ypadFrac,
	            yBottomFrac+lenFrac-ypadFrac
	        ];
	        cbAxisOut.setScale();
	
	        // now draw the elements
	        var container = fullLayout._infolayer.selectAll('g.'+id).data([0]);
	        container.enter().append('g').classed(id,true)
	            .each(function() {
	                var s = d3.select(this);
	                s.append('rect').classed('cbbg',true);
	                s.append('g').classed('cbfills',true);
	                s.append('g').classed('cblines',true);
	                s.append('g').classed('cbaxis',true).classed('crisp',true);
	                s.append('g').classed('cbtitleunshift',true)
	                    .append('g').classed('cbtitle',true);
	                s.append('rect').classed('cboutline',true);
	                s.select('.cbtitle').datum(0);
	            });
	        container.attr('transform','translate('+Math.round(gs.l)+
	            ','+Math.round(gs.t)+')');
	        // TODO: this opposite transform is a hack until we make it
	        // more rational which items get this offset
	        var titleCont = container.select('.cbtitleunshift')
	            .attr('transform', 'translate(-'+
	                Math.round(gs.l) + ',-' +
	                Math.round(gs.t) + ')');
	
	        cbAxisOut._axislayer = container.select('.cbaxis');
	        var titleHeight = 0;
	        if(['top', 'bottom'].indexOf(opts.titleside) !== -1) {
	            // draw the title so we know how much room it needs
	            // when we squish the axis. This one only applies to
	            // top or bottom titles, not right side.
	            var x = gs.l + (opts.x + xpadFrac) * gs.w,
	                fontSize = cbAxisOut.titlefont.size,
	                y;
	
	            if(opts.titleside === 'top') {
	                y = (1 - (yBottomFrac + lenFrac - ypadFrac)) * gs.h +
	                    gs.t + 3 + fontSize * 0.75;
	            }
	            else {
	                y = (1 - (yBottomFrac + ypadFrac)) * gs.h +
	                    gs.t - 3 - fontSize * 0.25;
	            }
	            drawTitle(cbAxisOut._id + 'title', {
	                attributes: {x: x, y: y, 'text-anchor': 'start'}
	            });
	        }
	
	        function drawAxis() {
	            if(['top','bottom'].indexOf(opts.titleside)!==-1) {
	                // squish the axis top to make room for the title
	                var titleGroup = container.select('.cbtitle'),
	                    titleText = titleGroup.select('text'),
	                    titleTrans =
	                        [-opts.outlinewidth/2, opts.outlinewidth/2],
	                    mathJaxNode = titleGroup
	                        .select('.h'+cbAxisOut._id+'title-math-group')
	                        .node(),
	                    lineSize = 15.6;
	                if(titleText.node()) {
	                    lineSize =
	                        parseInt(titleText.style('font-size'), 10) * 1.3;
	                }
	                if(mathJaxNode) {
	                    titleHeight = Drawing.bBox(mathJaxNode).height;
	                    if(titleHeight>lineSize) {
	                        // not entirely sure how mathjax is doing
	                        // vertical alignment, but this seems to work.
	                        titleTrans[1] -= (titleHeight-lineSize)/2;
	                    }
	                }
	                else if(titleText.node() &&
	                        !titleText.classed('js-placeholder')) {
	                    titleHeight = Drawing.bBox(
	                        titleGroup.node()).height;
	                }
	                if(titleHeight) {
	                    // buffer btwn colorbar and title
	                    // TODO: configurable
	                    titleHeight += 5;
	
	                    if(opts.titleside==='top') {
	                        cbAxisOut.domain[1] -= titleHeight/gs.h;
	                        titleTrans[1] *= -1;
	                    }
	                    else {
	                        cbAxisOut.domain[0] += titleHeight/gs.h;
	                        var nlines = Math.max(1,
	                            titleText.selectAll('tspan.line').size());
	                        titleTrans[1] += (1-nlines)*lineSize;
	                    }
	
	                    titleGroup.attr('transform',
	                        'translate('+titleTrans+')');
	
	                    cbAxisOut.setScale();
	                }
	            }
	
	            container.selectAll('.cbfills,.cblines,.cbaxis')
	                .attr('transform','translate(0,'+
	                    Math.round(gs.h*(1-cbAxisOut.domain[1]))+')');
	
	            var fills = container.select('.cbfills')
	                .selectAll('rect.cbfill')
	                    .data(filllevels);
	            fills.enter().append('rect')
	                .classed('cbfill',true)
	                .style('stroke','none');
	            fills.exit().remove();
	            fills.each(function(d,i) {
	                var z = [
	                    (i===0) ? zrange[0] :
	                        (filllevels[i]+filllevels[i-1])/2,
	                    (i===filllevels.length-1) ? zrange[1] :
	                        (filllevels[i]+filllevels[i+1])/2
	                ]
	                .map(cbAxisOut.c2p)
	                .map(Math.round);
	
	                // offset the side adjoining the next rectangle so they
	                // overlap, to prevent antialiasing gaps
	                if(i!==filllevels.length-1) {
	                    z[1] += (z[1]>z[0]) ? 1 : -1;
	                }
	
	
	                // Tinycolor can't handle exponents and
	                // at this scale, removing it makes no difference.
	                var colorString = fillcolormap(d).replace('e-', ''),
	                    opaqueColor = tinycolor(colorString).toHexString();
	
	                // Colorbar cannot currently support opacities so we
	                // use an opaque fill even when alpha channels present
	                d3.select(this).attr({
	                    x: xLeft,
	                    width: Math.max(thickPx,2),
	                    y: d3.min(z),
	                    height: Math.max(d3.max(z)-d3.min(z),2),
	                    fill: opaqueColor
	                });
	            });
	
	            var lines = container.select('.cblines')
	                .selectAll('path.cbline')
	                    .data(opts.line.color && opts.line.width ?
	                        linelevels : []);
	            lines.enter().append('path')
	                .classed('cbline',true);
	            lines.exit().remove();
	            lines.each(function(d) {
	                d3.select(this)
	                    .attr('d','M'+xLeft+',' +
	                        (Math.round(cbAxisOut.c2p(d))+(opts.line.width/2)%1) +
	                        'h'+thickPx)
	                    .call(Drawing.lineGroupStyle,
	                        opts.line.width, linecolormap(d), opts.line.dash);
	            });
	
	            // force full redraw of labels and ticks
	            cbAxisOut._axislayer.selectAll('g.'+cbAxisOut._id+'tick,path')
	                .remove();
	
	            cbAxisOut._pos = xLeft+thickPx +
	                (opts.outlinewidth||0)/2 - (opts.ticks==='outside' ? 1 : 0);
	            cbAxisOut.side = 'right';
	
	            // separate out axis and title drawing,
	            // so we don't need such complicated logic in Titles.draw
	            // if title is on the top or bottom, we've already drawn it
	            // this title call only handles side=right
	            return Lib.syncOrAsync([
	                function() {
	                    return Axes.doTicks(gd, cbAxisOut, true);
	                },
	                function() {
	                    if(['top','bottom'].indexOf(opts.titleside)===-1) {
	                        var fontSize = cbAxisOut.titlefont.size,
	                            y = cbAxisOut._offset + cbAxisOut._length / 2,
	                            x = gs.l + (cbAxisOut.position || 0) * gs.w + ((cbAxisOut.side === 'right') ?
	                                10 + fontSize*((cbAxisOut.showticklabels ? 1 : 0.5)) :
	                                -10 - fontSize*((cbAxisOut.showticklabels ? 0.5 : 0)));
	
	                        // the 'h' + is a hack to get around the fact that
	                        // convertToTspans rotates any 'y...' class by 90 degrees.
	                        // TODO: find a better way to control this.
	                        drawTitle('h' + cbAxisOut._id + 'title', {
	                            avoid: {
	                                selection: d3.select(gd).selectAll('g.' + cbAxisOut._id + 'tick'),
	                                side: opts.titleside,
	                                offsetLeft: gs.l,
	                                offsetTop: gs.t,
	                                maxShift: fullLayout.width
	                            },
	                            attributes: {x: x, y: y, 'text-anchor': 'middle'},
	                            transform: {rotate: '-90', offset: 0}
	                        });
	                    }
	                }]);
	        }
	
	        function drawTitle(titleClass, titleOpts) {
	            var trace = getTrace(),
	                propName;
	            if(Plots.traceIs(trace, 'markerColorscale')) {
	                propName = 'marker.colorbar.title';
	            }
	            else propName = 'colorbar.title';
	
	            var dfltTitleOpts = {
	                propContainer: cbAxisOut,
	                propName: propName,
	                traceIndex: trace.index,
	                dfltName: 'colorscale',
	                containerGroup: container.select('.cbtitle')
	            };
	
	            // this class-to-rotate thing with convertToTspans is
	            // getting hackier and hackier... delete groups with the
	            // wrong class (in case earlier the colorbar was drawn on
	            // a different side, I think?)
	            var otherClass = titleClass.charAt(0) === 'h' ?
	                titleClass.substr(1) : ('h' + titleClass);
	            container.selectAll('.' + otherClass + ',.' + otherClass + '-math-group')
	                .remove();
	
	            Titles.draw(gd, titleClass,
	                extendFlat(dfltTitleOpts, titleOpts || {}));
	        }
	
	        function positionCB() {
	            // wait for the axis & title to finish rendering before
	            // continuing positioning
	            // TODO: why are we redrawing multiple times now with this?
	            // I guess autoMargin doesn't like being post-promise?
	            var innerWidth = thickPx + opts.outlinewidth/2 +
	                    Drawing.bBox(cbAxisOut._axislayer.node()).width;
	            titleEl = titleCont.select('text');
	            if(titleEl.node() && !titleEl.classed('js-placeholder')) {
	                var mathJaxNode = titleCont
	                        .select('.h'+cbAxisOut._id+'title-math-group')
	                        .node(),
	                    titleWidth;
	                if(mathJaxNode &&
	                        ['top','bottom'].indexOf(opts.titleside)!==-1) {
	                    titleWidth = Drawing.bBox(mathJaxNode).width;
	                }
	                else {
	                    // note: the formula below works for all titlesides,
	                    // (except for top/bottom mathjax, above)
	                    // but the weird gs.l is because the titleunshift
	                    // transform gets removed by Drawing.bBox
	                    titleWidth =
	                        Drawing.bBox(titleCont.node()).right -
	                        xLeft - gs.l;
	                }
	                innerWidth = Math.max(innerWidth,titleWidth);
	            }
	
	            var outerwidth = 2*opts.xpad + innerWidth +
	                    opts.borderwidth + opts.outlinewidth/2,
	                outerheight = yBottomPx-yTopPx;
	
	            container.select('.cbbg').attr({
	                x: xLeft-opts.xpad -
	                    (opts.borderwidth + opts.outlinewidth)/2,
	                y: yTopPx - yExtraPx,
	                width: Math.max(outerwidth,2),
	                height: Math.max(outerheight + 2*yExtraPx,2)
	            })
	            .call(Color.fill, opts.bgcolor)
	            .call(Color.stroke, opts.bordercolor)
	            .style({'stroke-width': opts.borderwidth});
	
	            container.selectAll('.cboutline').attr({
	                x: xLeft,
	                y: yTopPx + opts.ypad +
	                    (opts.titleside==='top' ? titleHeight : 0),
	                width: Math.max(thickPx,2),
	                height: Math.max(outerheight - 2*opts.ypad - titleHeight, 2)
	            })
	            .call(Color.stroke, opts.outlinecolor)
	            .style({
	                fill: 'None',
	                'stroke-width': opts.outlinewidth
	            });
	
	            // fix positioning for xanchor!='left'
	            var xoffset = ({center: 0.5, right: 1}[opts.xanchor] || 0) *
	                outerwidth;
	            container.attr('transform',
	                'translate('+(gs.l-xoffset)+','+gs.t+')');
	
	            //auto margin adjustment
	            Plots.autoMargin(gd, id,{
	                x: opts.x,
	                y: opts.y,
	                l: outerwidth * ({right: 1, center: 0.5}[opts.xanchor] || 0),
	                r: outerwidth * ({left: 1, center: 0.5}[opts.xanchor] || 0),
	                t: outerheight * ({bottom: 1, middle: 0.5}[opts.yanchor] || 0),
	                b: outerheight * ({top: 1, middle: 0.5}[opts.yanchor] || 0)
	            });
	        }
	
	        var cbDone = Lib.syncOrAsync([
	            Plots.previousPromises,
	            drawAxis,
	            Plots.previousPromises,
	            positionCB
	        ], gd);
	
	        if(cbDone && cbDone.then) (gd._promises || []).push(cbDone);
	
	        // dragging...
	        if(gd._context.editable) {
	            var t0,
	                xf,
	                yf;
	
	            dragElement.init({
	                element: container.node(),
	                prepFn: function() {
	                    t0 = container.attr('transform');
	                    setCursor(container);
	                },
	                moveFn: function(dx, dy) {
	                    container.attr('transform',
	                        t0+' ' + 'translate('+dx+','+dy+')');
	
	                    xf = dragElement.align(xLeftFrac + (dx/gs.w), thickFrac,
	                        0, 1, opts.xanchor);
	                    yf = dragElement.align(yBottomFrac - (dy/gs.h), lenFrac,
	                        0, 1, opts.yanchor);
	
	                    var csr = dragElement.getCursor(xf, yf,
	                        opts.xanchor, opts.yanchor);
	                    setCursor(container, csr);
	                },
	                doneFn: function(dragged) {
	                    setCursor(container);
	
	                    if(dragged && xf!==undefined && yf!==undefined) {
	                        Plotly.restyle(gd,
	                            {'colorbar.x': xf, 'colorbar.y': yf},
	                            getTrace().index);
	                    }
	                }
	            });
	        }
	        return cbDone;
	    }
	
	    function getTrace() {
	        var idNum = id.substr(2),
	            i,
	            trace;
	        for(i = 0; i < gd._fullData.length; i++) {
	            trace = gd._fullData[i];
	            if(trace.uid === idNum) return trace;
	        }
	    }
	
	    // setter/getters for every item defined in opts
	    Object.keys(opts).forEach(function(name) {
	        component[name] = function(v) {
	            // getter
	            if(!arguments.length) return opts[name];
	
	            // setter - for multi-part properties,
	            // set only the parts that are provided
	            opts[name] = Lib.isPlainObject(opts[name]) ?
	                 Lib.extendFlat(opts[name], v) :
	                 v;
	
	            return component;
	        };
	    });
	
	    // or use .options to set multiple options at once via a dictionary
	    component.options = function(o) {
	        Object.keys(o).forEach(function(name) {
	            // in case something random comes through
	            // that's not an option, ignore it
	            if(typeof component[name]==='function') {
	                component[name](o[name]);
	            }
	        });
	        return component;
	    };
	
	    component._opts = opts;
	
	    return component;
	};


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var errorBars = module.exports = {};
	
	errorBars.attributes = __webpack_require__(399);
	
	errorBars.supplyDefaults = __webpack_require__(400);
	
	errorBars.calc = __webpack_require__(401);
	
	errorBars.calcFromTrace = function(trace, layout) {
	    var x = trace.x || [],
	        y = trace.y,
	        len = x.length || y.length;
	
	    var calcdataMock = new Array(len);
	
	    for(var i = 0; i < len; i++) {
	        calcdataMock[i] = {
	            x: x[i],
	            y: y[i]
	        };
	    }
	
	    calcdataMock[0].trace = trace;
	
	    errorBars.calc({
	        calcdata: [calcdataMock],
	        _fullLayout: layout
	    });
	
	    return calcdataMock;
	};
	
	errorBars.plot = __webpack_require__(403);
	
	errorBars.style = __webpack_require__(404);
	
	errorBars.hoverInfo = function(calcPoint, trace, hoverPoint) {
	    if((trace.error_y || {}).visible) {
	        hoverPoint.yerr = calcPoint.yh - calcPoint.y;
	        if(!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
	    }
	    if((trace.error_x || {}).visible) {
	        hoverPoint.xerr = calcPoint.xh - calcPoint.x;
	        if(!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
	    }
	};


/***/ },
/* 399 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    visible: {
	        valType: 'boolean',
	        role: 'info',
	        description: [
	            'Determines whether or not this set of error bars is visible.'
	        ].join(' ')
	    },
	    type: {
	        valType: 'enumerated',
	        values: ['percent', 'constant', 'sqrt', 'data'],
	        role: 'info',
	        description: [
	            'Determines the rule used to generate the error bars.',
	
	            'If *constant`, the bar lengths are of a constant value.',
	            'Set this constant in `value`.',
	
	            'If *percent*, the bar lengths correspond to a percentage of',
	            'underlying data. Set this percentage in `value`.',
	
	            'If *sqrt*, the bar lengths correspond to the sqaure of the',
	            'underlying data.',
	
	            'If *array*, the bar lengths are set with data set `array`.'
	        ].join(' ')
	    },
	    symmetric: {
	        valType: 'boolean',
	        role: 'info',
	        description: [
	            'Determines whether or not the error bars have the same length',
	            'in both direction',
	            '(top/bottom for vertical bars, left/right for horizontal bars.'
	        ].join(' ')
	    },
	    array: {
	        valType: 'data_array',
	        description: [
	            'Sets the data corresponding the length of each error bar.',
	            'Values are plotted relative to the underlying data.'
	        ].join(' ')
	    },
	    arrayminus: {
	        valType: 'data_array',
	        description: [
	            'Sets the data corresponding the length of each error bar in the',
	            'bottom (left) direction for vertical (horizontal) bars',
	            'Values are plotted relative to the underlying data.'
	        ].join(' ')
	    },
	    value: {
	        valType: 'number',
	        min: 0,
	        dflt: 10,
	        role: 'info',
	        description: [
	            'Sets the value of either the percentage',
	            '(if `type` is set to *percent*) or the constant',
	            '(if `type` is set to *constant*) corresponding to the lengths of',
	            'the error bars.'
	        ].join(' ')
	    },
	    valueminus: {
	        valType: 'number',
	        min: 0,
	        dflt: 10,
	        role: 'info',
	        description: [
	            'Sets the value of either the percentage',
	            '(if `type` is set to *percent*) or the constant',
	            '(if `type` is set to *constant*) corresponding to the lengths of',
	            'the error bars in the',
	            'bottom (left) direction for vertical (horizontal) bars'
	        ].join(' ')
	    },
	    traceref: {
	        valType: 'integer',
	        min: 0,
	        dflt: 0,
	        role: 'info'
	    },
	    tracerefminus: {
	        valType: 'integer',
	        min: 0,
	        dflt: 0,
	        role: 'info'
	    },
	    copy_ystyle: {
	        valType: 'boolean',
	        role: 'style'
	    },
	    copy_zstyle: {
	        valType: 'boolean',
	        role: 'style'
	    },
	    color: {
	        valType: 'color',
	        role: 'style',
	        description: 'Sets the stoke color of the error bars.'
	    },
	    thickness: {
	        valType: 'number',
	        min: 0,
	        dflt: 2,
	        role: 'style',
	        description: 'Sets the thickness (in px) of the error bars.'
	    },
	    width: {
	        valType: 'number',
	        min: 0,
	        role: 'style',
	        description: [
	            'Sets the width (in px) of the cross-bar at both ends',
	            'of the error bars.'
	        ].join(' ')
	    },
	
	    _deprecated: {
	        opacity: {
	            valType: 'number',
	            role: 'style',
	            description: [
	                'Obsolete.',
	                'Use the alpha channel in error bar `color` to set the opacity.'
	            ].join(' ')
	        }
	    }
	};


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Plots = __webpack_require__(332);
	var Lib = __webpack_require__(309);
	
	var attributes = __webpack_require__(399);
	
	
	module.exports = function(traceIn, traceOut, defaultColor, opts) {
	    var objName = 'error_' + opts.axis,
	        containerOut = traceOut[objName] = {},
	        containerIn = traceIn[objName] || {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
	    }
	
	    var hasErrorBars = (
	        containerIn.array !== undefined ||
	        containerIn.value !== undefined ||
	        containerIn.type === 'sqrt'
	    );
	
	    var visible = coerce('visible', hasErrorBars);
	
	    if(visible === false) return;
	
	    var type = coerce('type', 'array' in containerIn ? 'data' : 'percent'),
	        symmetric = true;
	
	    if(type !== 'sqrt') {
	        symmetric = coerce('symmetric',
	            !((type === 'data' ? 'arrayminus' : 'valueminus') in containerIn));
	    }
	
	    if(type === 'data') {
	        var array = coerce('array');
	        if(!array) containerOut.array = [];
	        coerce('traceref');
	        if(!symmetric) {
	            var arrayminus = coerce('arrayminus');
	            if(!arrayminus) containerOut.arrayminus = [];
	            coerce('tracerefminus');
	        }
	    }
	    else if(type==='percent' || type==='constant') {
	        coerce('value');
	        if(!symmetric) coerce('valueminus');
	    }
	
	    var copyAttr = 'copy_'+opts.inherit+'style';
	    if(opts.inherit) {
	        var inheritObj = traceOut['error_' + opts.inherit];
	        if((inheritObj||{}).visible) {
	            coerce(copyAttr, !(containerIn.color ||
	                               isNumeric(containerIn.thickness) ||
	                               isNumeric(containerIn.width)));
	        }
	    }
	    if(!opts.inherit || !containerOut[copyAttr]) {
	        coerce('color', defaultColor);
	        coerce('thickness');
	        coerce('width', Plots.traceIs(traceOut, 'gl3d') ? 0 : 4);
	    }
	};


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Plots = __webpack_require__(332);
	var Axes = __webpack_require__(338);
	
	var makeComputeError = __webpack_require__(402);
	
	
	module.exports = function calc(gd) {
	    var calcdata = gd.calcdata;
	
	    for(var i = 0; i < calcdata.length; i++) {
	        var calcTrace = calcdata[i],
	            trace = calcTrace[0].trace;
	
	        if(!Plots.traceIs(trace, 'errorBarsOK')) continue;
	
	        var xa = Axes.getFromId(gd, trace.xaxis),
	            ya = Axes.getFromId(gd, trace.yaxis);
	
	        calcOneAxis(calcTrace, trace, xa, 'x');
	        calcOneAxis(calcTrace, trace, ya, 'y');
	    }
	};
	
	function calcOneAxis(calcTrace, trace, axis, coord) {
	    var opts = trace['error_' + coord] || {},
	        isVisible = (opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1),
	        vals = [];
	
	    if(!isVisible) return;
	
	    var computeError = makeComputeError(opts);
	
	    for(var i = 0; i < calcTrace.length; i++) {
	        var calcPt = calcTrace[i],
	            calcCoord = calcPt[coord];
	
	        if(!isNumeric(axis.c2l(calcCoord))) continue;
	
	        var errors = computeError(calcCoord, i);
	        if(isNumeric(errors[0]) && isNumeric(errors[1])) {
	            var shoe = calcPt[coord + 's'] = calcCoord - errors[0],
	                hat = calcPt[coord + 'h'] = calcCoord + errors[1];
	            vals.push(shoe, hat);
	        }
	    }
	
	    Axes.expand(axis, vals, {padded: true});
	}


/***/ },
/* 402 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	/**
	 * Error bar computing function generator
	 *
	 * N.B. The generated function does not clean the dataPt entries. Non-numeric
	 * entries result in undefined error magnitudes.
	 *
	 * @param {object} opts error bar attributes
	 *
	 * @return {function} :
	 *      @param {numeric} dataPt data point from where to compute the error magnitude
	 *      @param {number} index index of dataPt in its corresponding data array
	 *      @return {array}
	 *        - error[0] : error magnitude in the negative direction
	 *        - error[1] : " " " " positive "
	 */
	module.exports = function makeComputeError(opts) {
	    var type = opts.type,
	        symmetric = opts.symmetric;
	
	    if(type === 'data') {
	        var array = opts.array,
	            arrayminus = opts.arrayminus;
	
	        if(symmetric || arrayminus === undefined) {
	            return function computeError(dataPt, index) {
	                var val = +(array[index]);
	                return [val, val];
	            };
	        }
	        else {
	            return function computeError(dataPt, index) {
	                return [+arrayminus[index], +array[index]];
	            };
	        }
	    }
	    else {
	        var computeErrorValue = makeComputeErrorValue(type, opts.value),
	            computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);
	
	        if(symmetric || opts.valueminus === undefined) {
	            return function computeError(dataPt) {
	                var val = computeErrorValue(dataPt);
	                return [val, val];
	            };
	        }
	        else {
	            return function computeError(dataPt) {
	                return [
	                    computeErrorValueMinus(dataPt),
	                    computeErrorValue(dataPt)
	                ];
	            };
	        }
	    }
	};
	
	/**
	 * Compute error bar magnitude (for all types except data)
	 *
	 * @param {string} type error bar type
	 * @param {numeric} value error bar value
	 *
	 * @return {function} :
	 *      @param {numeric} dataPt
	 */
	function makeComputeErrorValue(type, value) {
	    if(type === 'percent') {
	        return function(dataPt) {
	            return Math.abs(dataPt * value / 100);
	        };
	    }
	    if(type === 'constant') {
	        return function() {
	            return Math.abs(value);
	        };
	    }
	    if(type === 'sqrt') {
	        return function(dataPt) {
	            return Math.sqrt(Math.abs(dataPt));
	        };
	    }
	}


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	var subTypes = __webpack_require__(360);
	
	
	module.exports = function plot(traces, plotinfo) {
	    var xa = plotinfo.x(),
	        ya = plotinfo.y();
	
	    traces.each(function(d) {
	        var trace = d[0].trace,
	            // || {} is in case the trace (specifically scatterternary)
	            // doesn't support error bars at all, but does go through
	            // the scatter.plot mechanics, which calls ErrorBars.plot
	            // internally
	            xObj = trace.error_x || {},
	            yObj = trace.error_y || {};
	
	        var sparse = (
	            subTypes.hasMarkers(trace) &&
	            trace.marker.maxdisplayed > 0
	        );
	
	        if(!yObj.visible && !xObj.visible) return;
	
	        var errorbars = d3.select(this).selectAll('g.errorbar')
	            .data(Lib.identity);
	
	        errorbars.enter().append('g')
	            .classed('errorbar', true);
	
	        errorbars.each(function(d) {
	            var errorbar = d3.select(this);
	            var coords = errorCoords(d, xa, ya);
	
	            if(sparse && !d.vis) return;
	
	            var path;
	
	            if(yObj.visible && isNumeric(coords.x) &&
	                    isNumeric(coords.yh) &&
	                    isNumeric(coords.ys)) {
	                var yw = yObj.width;
	
	                path = 'M' + (coords.x - yw) + ',' +
	                    coords.yh + 'h' + (2 * yw) + // hat
	                    'm-' + yw + ',0V' + coords.ys; // bar
	
	                if(!coords.noYS) path += 'm-' + yw +',0h' + (2 * yw); // shoe
	
	                errorbar.append('path')
	                    .classed('yerror', true)
	                    .attr('d', path);
	            }
	
	            if(xObj.visible && isNumeric(coords.y) &&
	                    isNumeric(coords.xh) &&
	                    isNumeric(coords.xs)) {
	                var xw = (xObj.copy_ystyle ? yObj : xObj).width;
	
	                path = 'M' + coords.xh + ',' +
	                    (coords.y - xw) + 'v' + (2 * xw) + // hat
	                    'm0,-' + xw + 'H' + coords.xs; // bar
	
	                if(!coords.noXS) path += 'm0,-' + xw + 'v' + (2 * xw); // shoe
	
	                errorbar.append('path')
	                    .classed('xerror', true)
	                    .attr('d', path);
	            }
	        });
	    });
	};
	
	// compute the coordinates of the error-bar objects
	function errorCoords(d, xa, ya) {
	    var out = {
	        x: xa.c2p(d.x),
	        y: ya.c2p(d.y)
	    };
	
	    // calculate the error bar size and hat and shoe locations
	    if(d.yh !== undefined) {
	        out.yh = ya.c2p(d.yh);
	        out.ys = ya.c2p(d.ys);
	
	        // if the shoes go off-scale (ie log scale, error bars past zero)
	        // clip the bar and hide the shoes
	        if(!isNumeric(out.ys)) {
	            out.noYS = true;
	            out.ys = ya.c2p(d.ys, true);
	        }
	    }
	
	    if(d.xh !== undefined) {
	        out.xh = xa.c2p(d.xh);
	        out.xs = xa.c2p(d.xs);
	
	        if(!isNumeric(out.xs)) {
	            out.noXS = true;
	            out.xs = xa.c2p(d.xs, true);
	        }
	    }
	
	    return out;
	}


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Color = __webpack_require__(333);
	
	
	module.exports = function style(traces) {
	    traces.each(function(d) {
	        var trace = d[0].trace,
	            yObj = trace.error_y || {},
	            xObj = trace.error_x || {};
	
	        var s = d3.select(this);
	
	        s.selectAll('path.yerror')
	            .style('stroke-width', yObj.thickness + 'px')
	            .call(Color.stroke, yObj.color);
	
	        if(xObj.copy_ystyle) xObj = yObj;
	
	        s.selectAll('path.xerror')
	            .style('stroke-width', xObj.thickness + 'px')
	            .call(Color.stroke, xObj.color);
	    });
	};


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var Axes = __webpack_require__(338);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var svgTextUtils = __webpack_require__(326);
	var setCursor = __webpack_require__(390);
	var dragElement = __webpack_require__(385);
	
	var annotations = module.exports = {};
	
	annotations.ARROWPATHS = __webpack_require__(406);
	
	annotations.layoutAttributes = __webpack_require__(407);
	
	annotations.supplyLayoutDefaults = function(layoutIn, layoutOut) {
	    var containerIn = layoutIn.annotations || [],
	        containerOut = layoutOut.annotations = [];
	
	    for(var i = 0; i < containerIn.length; i++) {
	        containerOut.push(handleAnnotationDefaults(containerIn[i] || {}, layoutOut));
	    }
	};
	
	function handleAnnotationDefaults(annIn, fullLayout) {
	    var annOut = {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(annIn, annOut, annotations.layoutAttributes, attr, dflt);
	    }
	
	    coerce('opacity');
	    coerce('align');
	    coerce('bgcolor');
	    var borderColor = coerce('bordercolor'),
	        borderOpacity = Color.opacity(borderColor);
	    coerce('borderpad');
	    var borderWidth = coerce('borderwidth');
	    var showArrow = coerce('showarrow');
	    if(showArrow) {
	        coerce('arrowcolor',
	            borderOpacity ? annOut.bordercolor : Color.defaultLine);
	        coerce('arrowhead');
	        coerce('arrowsize');
	        coerce('arrowwidth', ((borderOpacity && borderWidth) || 1) * 2);
	        coerce('ax');
	        coerce('ay');
	
	        // if you have one part of arrow length you should have both
	        Lib.noneOrAll(annIn, annOut, ['ax', 'ay']);
	    }
	    coerce('text', showArrow ? '&nbsp;' : 'new text');
	    coerce('textangle');
	    Lib.coerceFont(coerce, 'font', fullLayout.font);
	
	    // positioning
	    var axLetters = ['x','y'];
	    for(var i = 0; i < 2; i++) {
	        var axLetter = axLetters[i],
	            tdMock = {_fullLayout: fullLayout};
	
	        // xref, yref
	        var axRef = Axes.coerceRef(annIn, annOut, tdMock, axLetter);
	
	        // x, y
	        var defaultPosition = 0.5;
	        if(axRef!=='paper') {
	            var ax = Axes.getFromId(tdMock, axRef);
	            defaultPosition = ax.range[0] + defaultPosition * (ax.range[1] - ax.range[0]);
	
	            // convert date or category strings to numbers
	            if(['date','category'].indexOf(ax.type)!==-1 &&
	                    typeof annIn[axLetter]==='string') {
	                var newval;
	                if(ax.type==='date') {
	                    newval = Lib.dateTime2ms(annIn[axLetter]);
	                    if(newval!==false) annIn[axLetter] = newval;
	                }
	                else if((ax._categories||[]).length) {
	                    newval = ax._categories.indexOf(annIn[axLetter]);
	                    if(newval!==-1) annIn[axLetter] = newval;
	                }
	            }
	        }
	        coerce(axLetter, defaultPosition);
	
	        // xanchor, yanchor
	        if(!showArrow) coerce(axLetter + 'anchor');
	    }
	
	    // if you have one coordinate you should have both
	    Lib.noneOrAll(annIn, annOut, ['x', 'y']);
	
	    return annOut;
	}
	
	annotations.drawAll = function(gd) {
	    var fullLayout = gd._fullLayout;
	    fullLayout._infolayer.selectAll('.annotation').remove();
	    for(var i = 0; i < fullLayout.annotations.length; i++) {
	        annotations.draw(gd, i);
	    }
	    return Plotly.Plots.previousPromises(gd);
	};
	
	annotations.add = function(gd) {
	    var nextAnn = gd._fullLayout.annotations.length;
	    Plotly.relayout(gd, 'annotations['+nextAnn+']', 'add');
	};
	
	// -----------------------------------------------------
	// make or edit an annotation on the graph
	// -----------------------------------------------------
	
	// annotations are stored in gd.layout.annotations, an array of objects
	// index can point to one item in this array,
	//  or non-numeric to simply add a new one
	//  or -1 to modify all existing
	// opt can be the full options object, or one key (to be set to value)
	//  or undefined to simply redraw
	// if opt is blank, val can be 'add' or a full options object to add a new
	//  annotation at that point in the array, or 'remove' to delete this one
	annotations.draw = function(gd, index, opt, value) {
	    var layout = gd.layout,
	        fullLayout = gd._fullLayout,
	        i;
	
	    if(!isNumeric(index) || index===-1) {
	        // no index provided - we're operating on ALL annotations
	        if(!index && Array.isArray(value)) {
	            // a whole annotation array is passed in
	            // (as in, redo of delete all)
	            layout.annotations = value;
	            annotations.supplyLayoutDefaults(layout, fullLayout);
	            annotations.drawAll(gd);
	            return;
	        }
	        else if(value==='remove') {
	            // delete all
	            delete layout.annotations;
	            fullLayout.annotations = [];
	            annotations.drawAll(gd);
	            return;
	        }
	        else if(opt && value!=='add') {
	            // make the same change to all annotations
	            for(i = 0; i < fullLayout.annotations.length; i++) {
	                annotations.draw(gd, i, opt, value);
	            }
	            return;
	        }
	        else {
	            // add a new empty annotation
	            index = fullLayout.annotations.length;
	            fullLayout.annotations.push({});
	        }
	    }
	
	    if(!opt && value) {
	        if(value==='remove') {
	            fullLayout._infolayer.selectAll('.annotation[data-index="'+index+'"]')
	                .remove();
	            fullLayout.annotations.splice(index,1);
	            layout.annotations.splice(index,1);
	            for(i=index; i<fullLayout.annotations.length; i++) {
	                fullLayout._infolayer
	                    .selectAll('.annotation[data-index="'+(i+1)+'"]')
	                    .attr('data-index',String(i));
	
	                // redraw all annotations past the removed one,
	                // so they bind to the right events
	                annotations.draw(gd,i);
	            }
	            return;
	        }
	        else if(value==='add' || Lib.isPlainObject(value)) {
	            fullLayout.annotations.splice(index,0,{});
	
	            var rule = Lib.isPlainObject(value) ?
	                    Lib.extendFlat({}, value) :
	                    {text: 'New text'};
	
	            if(layout.annotations) {
	                layout.annotations.splice(index, 0, rule);
	            } else {
	                layout.annotations = [rule];
	            }
	
	            for(i=fullLayout.annotations.length-1; i>index; i--) {
	                fullLayout._infolayer
	                    .selectAll('.annotation[data-index="'+(i-1)+'"]')
	                    .attr('data-index',String(i));
	                annotations.draw(gd,i);
	            }
	        }
	    }
	
	    // remove the existing annotation if there is one
	    fullLayout._infolayer.selectAll('.annotation[data-index="'+index+'"]').remove();
	
	    // remember a few things about what was already there,
	    var optionsIn = layout.annotations[index],
	        oldPrivate = fullLayout.annotations[index];
	
	    // not sure how we're getting here... but C12 is seeing a bug
	    // where we fail here when they add/remove annotations
	    if(!optionsIn) return;
	
	    var oldRef = {xref: optionsIn.xref, yref: optionsIn.yref};
	
	    // alter the input annotation as requested
	    var optionsEdit = {};
	    if(typeof opt === 'string' && opt) optionsEdit[opt] = value;
	    else if(Lib.isPlainObject(opt)) optionsEdit = opt;
	
	    var optionKeys = Object.keys(optionsEdit);
	    for(i = 0; i < optionKeys.length; i++) {
	        var k = optionKeys[i];
	        Lib.nestedProperty(optionsIn, k).set(optionsEdit[k]);
	    }
	
	    var gs = fullLayout._size;
	
	    var axLetters = ['x', 'y'];
	    for(i = 0; i < 2; i++) {
	        var axLetter = axLetters[i];
	        // if we don't have an explicit position already,
	        // don't set one just because we're changing references
	        // or axis type.
	        // the defaults will be consistent most of the time anyway,
	        // except in log/linear changes
	        if(optionsEdit[axLetter]!==undefined ||
	                optionsIn[axLetter]===undefined) {
	            continue;
	        }
	
	        var axOld = Axes.getFromId(gd, Axes.coerceRef(oldRef, {}, gd, axLetter)),
	            axNew = Axes.getFromId(gd, Axes.coerceRef(optionsIn, {}, gd, axLetter)),
	            position = optionsIn[axLetter],
	            axTypeOld = oldPrivate['_' + axLetter + 'type'];
	
	        if(optionsEdit[axLetter + 'ref']!==undefined) {
	            var autoAnchor = optionsIn[axLetter + 'anchor'] === 'auto',
	                plotSize = (axLetter === 'x' ? gs.w : gs.h),
	                halfSizeFrac = (oldPrivate['_' + axLetter + 'size'] || 0) /
	                    (2 * plotSize);
	            if(axOld && axNew) { // data -> different data
	                // go to the same fraction of the axis length
	                // whether or not these axes share a domain
	
	                // first convert to fraction of the axis
	                position = (position - axOld.range[0]) /
	                    (axOld.range[1] - axOld.range[0]);
	
	                // then convert to new data coordinates at the same fraction
	                position = axNew.range[0] +
	                    position * (axNew.range[1] - axNew.range[0]);
	            }
	            else if(axOld) { // data -> paper
	                // first convert to fraction of the axis
	                position = (position - axOld.range[0]) /
	                    (axOld.range[1] - axOld.range[0]);
	
	                // next scale the axis to the whole plot
	                position = axOld.domain[0] +
	                    position * (axOld.domain[1] - axOld.domain[0]);
	
	                // finally see if we need to adjust auto alignment
	                // because auto always means middle / center alignment for data,
	                // but it changes for page alignment based on the closest side
	                if(autoAnchor) {
	                    var posPlus = position + halfSizeFrac,
	                        posMinus = position - halfSizeFrac;
	                    if(position + posMinus < 2/3) position = posMinus;
	                    else if(position + posPlus > 4/3) position = posPlus;
	                }
	            }
	            else if(axNew) { // paper -> data
	                // first see if we need to adjust auto alignment
	                if(autoAnchor) {
	                    if(position < 1/3) position += halfSizeFrac;
	                    else if(position > 2/3) position -= halfSizeFrac;
	                }
	
	                // next convert to fraction of the axis
	                position = (position - axNew.domain[0]) /
	                    (axNew.domain[1] - axNew.domain[0]);
	
	                // finally convert to data coordinates
	                position = axNew.range[0] +
	                    position * (axNew.range[1] - axNew.range[0]);
	            }
	        }
	
	        if(axNew && axNew===axOld && axTypeOld) {
	            if(axTypeOld==='log' && axNew.type!=='log') {
	                position = Math.pow(10,position);
	            }
	            else if(axTypeOld!=='log' && axNew.type==='log') {
	                position = (position>0) ?
	                    Math.log(position)/Math.LN10 : undefined;
	            }
	        }
	
	        optionsIn[axLetter] = position;
	    }
	
	    var options = handleAnnotationDefaults(optionsIn, fullLayout);
	    fullLayout.annotations[index] = options;
	
	    var xa = Axes.getFromId(gd, options.xref),
	        ya = Axes.getFromId(gd, options.yref),
	        annPosPx = {x: 0, y: 0},
	        textangle = +options.textangle || 0;
	
	    // create the components
	    // made a single group to contain all, so opacity can work right
	    // with border/arrow together this could handle a whole bunch of
	    // cleanup at this point, but works for now
	    var anngroup = fullLayout._infolayer.append('g')
	        .classed('annotation', true)
	        .attr('data-index', String(index))
	        .style('opacity', options.opacity)
	        .on('click', function() {
	            gd._dragging = false;
	            gd.emit('plotly_clickannotation', {
	                index: index,
	                annotation: optionsIn,
	                fullAnnotation: options
	            });
	        });
	
	    // another group for text+background so that they can rotate together
	    var anng = anngroup.append('g')
	        .classed('annotation-text-g', true)
	        .attr('data-index', String(index));
	
	    var ann = anng.append('g');
	
	    var borderwidth = options.borderwidth,
	        borderpad = options.borderpad,
	        borderfull = borderwidth + borderpad;
	
	    var annbg = ann.append('rect')
	        .attr('class','bg')
	        .style('stroke-width', borderwidth+'px')
	        .call(Color.stroke, options.bordercolor)
	        .call(Color.fill, options.bgcolor);
	
	    var font = options.font;
	
	    var anntext = ann.append('text')
	        .classed('annotation', true)
	        .attr('data-unformatted', options.text)
	        .text(options.text);
	
	    function textLayout(s) {
	        s.call(Drawing.font, font)
	        .attr({
	            'text-anchor': {
	                left: 'start',
	                right: 'end'
	            }[options.align] || 'middle'
	        });
	
	        svgTextUtils.convertToTspans(s, drawGraphicalElements);
	        return s;
	    }
	
	    function drawGraphicalElements() {
	
	        // make sure lines are aligned the way they will be
	        // at the end, even if their position changes
	        anntext.selectAll('tspan.line').attr({y: 0, x: 0});
	
	        var mathjaxGroup = ann.select('.annotation-math-group'),
	            hasMathjax = !mathjaxGroup.empty(),
	            anntextBB = Drawing.bBox(
	                (hasMathjax ? mathjaxGroup : anntext).node()),
	            annwidth = anntextBB.width,
	            annheight = anntextBB.height,
	            outerwidth = Math.round(annwidth + 2 * borderfull),
	            outerheight = Math.round(annheight + 2 * borderfull);
	
	
	        // save size in the annotation object for use by autoscale
	        options._w = annwidth;
	        options._h = annheight;
	
	        function shiftFraction(v, anchor) {
	            if(anchor==='auto') {
	                if(v < 1/3) anchor = 'left';
	                else if(v > 2/3) anchor = 'right';
	                else anchor = 'center';
	            }
	            return {
	                center: 0,
	                middle: 0,
	                left: 0.5,
	                bottom: -0.5,
	                right: -0.5,
	                top: 0.5
	            }[anchor];
	        }
	
	        var annotationIsOffscreen = false;
	        ['x', 'y'].forEach(function(axLetter) {
	            var ax = Axes.getFromId(gd,
	                    options[axLetter+'ref']||axLetter),
	                dimAngle = (textangle + (axLetter==='x' ? 0 : 90)) * Math.PI/180,
	                annSize = outerwidth * Math.abs(Math.cos(dimAngle)) +
	                          outerheight * Math.abs(Math.sin(dimAngle)),
	                anchor = options[axLetter + 'anchor'],
	                alignPosition;
	
	            // calculate pixel position
	            if(ax) {
	                // hide the annotation if it's pointing
	                // outside the visible plot (as long as the axis
	                // isn't autoranged - then we need to draw it
	                // anyway to get its bounding box)
	                if(!ax.autorange && ((options[axLetter] - ax.range[0]) *
	                                     (options[axLetter] - ax.range[1]) > 0)) {
	                    annotationIsOffscreen = true;
	                    return;
	                }
	                annPosPx[axLetter] = ax._offset+ax.l2p(options[axLetter]);
	                alignPosition = 0.5;
	            }
	            else {
	                alignPosition = options[axLetter];
	                if(axLetter === 'y') alignPosition = 1 - alignPosition;
	                annPosPx[axLetter] = (axLetter === 'x') ?
	                    (gs.l + gs.w * alignPosition) :
	                    (gs.t + gs.h * alignPosition);
	            }
	
	            var alignShift = 0;
	            if(options.showarrow) {
	                alignShift = options['a' + axLetter];
	            }
	            else {
	                alignShift = annSize * shiftFraction(alignPosition, anchor);
	            }
	            annPosPx[axLetter] += alignShift;
	
	            // save the current axis type for later log/linear changes
	            options['_' + axLetter + 'type'] = ax && ax.type;
	
	            // save the size and shift in this dim for autorange
	            options['_' + axLetter + 'size'] = annSize;
	            options['_' + axLetter + 'shift'] = alignShift;
	        });
	
	        if(annotationIsOffscreen) {
	            ann.remove();
	            return;
	        }
	
	        var arrowX, arrowY;
	
	        // make sure the arrowhead (if there is one)
	        // and the annotation center are visible
	        if(options.showarrow) {
	            arrowX = Lib.constrain(annPosPx.x - options.ax, 1, fullLayout.width - 1);
	            arrowY = Lib.constrain(annPosPx.y - options.ay, 1, fullLayout.height - 1);
	        }
	        annPosPx.x = Lib.constrain(annPosPx.x, 1, fullLayout.width - 1);
	        annPosPx.y = Lib.constrain(annPosPx.y, 1, fullLayout.height - 1);
	
	        var texty = borderfull - anntextBB.top,
	            textx = borderfull - anntextBB.left;
	
	        if(hasMathjax) {
	            mathjaxGroup.select('svg').attr({x: borderfull - 1, y: borderfull});
	        }
	        else {
	            anntext.attr({x: textx, y: texty});
	            anntext.selectAll('tspan.line').attr({y: texty, x: textx});
	        }
	
	        annbg.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,
	            outerwidth-borderwidth, outerheight - borderwidth);
	
	        var annX = Math.round(annPosPx.x - outerwidth / 2),
	            annY = Math.round(annPosPx.y - outerheight / 2);
	        ann.call(Lib.setTranslate, annX, annY);
	
	        var annbase = 'annotations['+index+']';
	
	        // add the arrow
	        // uses options[arrowwidth,arrowcolor,arrowhead] for styling
	        var drawArrow = function(dx, dy) {
	            d3.select(gd)
	                .selectAll('.annotation-arrow-g[data-index="' + index + '"]')
	                .remove();
	            // find where to start the arrow:
	            // at the border of the textbox, if that border is visible,
	            // or at the edge of the lines of text, if the border is hidden
	            // TODO: tspan bounding box fails in chrome
	            // looks like there may be a cross-browser solution, see
	            // http://stackoverflow.com/questions/5364980/
	            //    how-to-get-the-width-of-an-svg-tspan-element
	            var arrowX0 = annPosPx.x + dx,
	                arrowY0 = annPosPx.y + dy,
	
	                // create transform matrix and related functions
	                transform =
	                    Lib.rotationXYMatrix(textangle, arrowX0, arrowY0),
	                applyTransform = Lib.apply2DTransform(transform),
	                applyTransform2 = Lib.apply2DTransform2(transform),
	
	                // calculate and transform bounding box
	                xHalf = annbg.attr('width')/2,
	                yHalf = annbg.attr('height')/2,
	                edges = [
	                    [arrowX0 - xHalf, arrowY0 - yHalf, arrowX0 - xHalf, arrowY0 + yHalf],
	                    [arrowX0 - xHalf, arrowY0 + yHalf, arrowX0 + xHalf, arrowY0 + yHalf],
	                    [arrowX0 + xHalf, arrowY0 + yHalf, arrowX0 + xHalf, arrowY0 - yHalf],
	                    [arrowX0 + xHalf, arrowY0 - yHalf, arrowX0 - xHalf, arrowY0 - yHalf]
	                ].map(applyTransform2);
	
	            // Remove the line if it ends inside the box.  Use ray
	            // casting for rotated boxes: see which edges intersect a
	            // line from the arrowhead to far away and reduce with xor
	            // to get the parity of the number of intersections.
	            if(edges.reduce(function(a, x) {
	                return a ^
	                    !!lineIntersect(arrowX, arrowY, arrowX + 1e6, arrowY + 1e6,
	                            x[0], x[1], x[2], x[3]);
	            }, false)) {
	                // no line or arrow - so quit drawArrow now
	                return;
	            }
	
	            edges.forEach(function(x) {
	                var p = lineIntersect(arrowX0, arrowY0, arrowX, arrowY,
	                            x[0], x[1], x[2], x[3]);
	                if(p) {
	                    arrowX0 = p.x;
	                    arrowY0 = p.y;
	                }
	            });
	
	            var strokewidth = options.arrowwidth,
	                arrowColor = options.arrowcolor;
	
	            var arrowgroup = anngroup.append('g')
	                .style({opacity: Color.opacity(arrowColor)})
	                .classed('annotation-arrow-g', true)
	                .attr('data-index', String(index));
	
	            var arrow = arrowgroup.append('path')
	                .attr('d', 'M'+arrowX0+','+arrowY0+'L'+arrowX+','+arrowY)
	                .style('stroke-width', strokewidth+'px')
	                .call(Color.stroke, Color.rgb(arrowColor));
	
	            annotations.arrowhead(arrow, options.arrowhead, 'end', options.arrowsize);
	
	            var arrowdrag = arrowgroup.append('path')
	                .classed('annotation', true)
	                .classed('anndrag', true)
	                .attr({
	                    'data-index': String(index),
	                    d: 'M3,3H-3V-3H3ZM0,0L' + (arrowX0-arrowX) + ',' + (arrowY0-arrowY),
	                    transform: 'translate('+arrowX+','+arrowY+')'
	                })
	                .style('stroke-width', (strokewidth+6)+'px')
	                .call(Color.stroke, 'rgba(0,0,0,0)')
	                .call(Color.fill, 'rgba(0,0,0,0)');
	
	            if(gd._context.editable) {
	                var update,
	                    annx0,
	                    anny0;
	
	                dragElement.init({
	                    element: arrowdrag.node(),
	                    prepFn: function() {
	                        var pos = Lib.getTranslate(ann);
	
	                        annx0 = pos.x;
	                        anny0 = pos.y;
	                        update = {};
	                        if(xa && xa.autorange) {
	                            update[xa._name+'.autorange'] = true;
	                        }
	                        if(ya && ya.autorange) {
	                            update[ya._name+'.autorange'] = true;
	                        }
	                    },
	                    moveFn: function(dx, dy) {
	                        arrowgroup.attr('transform', 'translate('+dx+','+dy+')');
	
	                        var annxy0 = applyTransform(annx0, anny0),
	                            xcenter = annxy0[0] + dx,
	                            ycenter = annxy0[1] + dy;
	                        ann.call(Lib.setTranslate, xcenter, ycenter);
	
	                        update[annbase+'.x'] = xa ?
	                            (options.x + dx / xa._m) :
	                            ((arrowX + dx - gs.l) / gs.w);
	                        update[annbase+'.y'] = ya ?
	                            (options.y + dy / ya._m) :
	                            (1 - ((arrowY + dy - gs.t) / gs.h));
	
	                        anng.attr({
	                            transform: 'rotate(' + textangle + ',' +
	                                   xcenter + ',' + ycenter + ')'
	                        });
	                    },
	                    doneFn: function(dragged) {
	                        if(dragged) {
	                            Plotly.relayout(gd, update);
	                            var notesBox = document.querySelector('.js-notes-box-panel');
	                            if(notesBox) notesBox.redraw(notesBox.selectedObj);
	                        }
	                    }
	                });
	            }
	        };
	
	        if(options.showarrow) drawArrow(0, 0);
	
	        // create transform matrix and related functions
	        var transform = Lib.rotationXYMatrix(textangle,
	                annPosPx.x, annPosPx.y),
	            applyTransform = Lib.apply2DTransform(transform);
	
	        // user dragging the annotation (text, not arrow)
	        if(gd._context.editable) {
	            var x0,
	                y0,
	                update;
	
	            dragElement.init({
	                element: ann.node(),
	                prepFn: function() {
	                    var pos = Lib.getTranslate(ann);
	
	                    x0 = pos.x;
	                    y0 = pos.y;
	                    update = {};
	                },
	                moveFn: function(dx, dy) {
	                    ann.call(Lib.setTranslate, x0 + dx, y0 + dy);
	                    var csr = 'pointer';
	                    if(options.showarrow) {
	                        update[annbase+'.ax'] = options.ax + dx;
	                        update[annbase+'.ay'] = options.ay + dy;
	                        drawArrow(dx, dy);
	                    }
	                    else {
	                        if(xa) update[annbase + '.x'] = options.x + dx / xa._m;
	                        else {
	                            var widthFraction = options._xsize / gs.w,
	                                xLeft = options.x + options._xshift / gs.w - widthFraction / 2;
	
	                            update[annbase + '.x'] = dragElement.align(xLeft + dx / gs.w,
	                                widthFraction, 0, 1, options.xanchor);
	                        }
	
	                        if(ya) update[annbase + '.y'] = options.y + dy / ya._m;
	                        else {
	                            var heightFraction = options._ysize / gs.h,
	                                yBottom = options.y - options._yshift / gs.h - heightFraction / 2;
	
	                            update[annbase + '.y'] = dragElement.align(yBottom - dy / gs.h,
	                                heightFraction, 0, 1, options.yanchor);
	                        }
	                        if(!xa || !ya) {
	                            csr = dragElement.getCursor(
	                                xa ? 0.5 : update[annbase + '.x'],
	                                ya ? 0.5 : update[annbase + '.y'],
	                                options.xanchor, options.yanchor
	                            );
	                        }
	                    }
	
	                    var xy1 = applyTransform(x0, y0),
	                        x1 = xy1[0] + dx,
	                        y1 = xy1[1] + dy;
	
	                    ann.call(Lib.setTranslate, x0 + dx, y0 + dy);
	
	                    anng.attr({
	                        transform: 'rotate(' + textangle + ',' +
	                               x1 + ',' + y1 + ')'
	                    });
	
	                    setCursor(ann, csr);
	                },
	                doneFn: function(dragged) {
	                    setCursor(ann);
	                    if(dragged) {
	                        Plotly.relayout(gd, update);
	                        var notesBox = document.querySelector('.js-notes-box-panel');
	                        if(notesBox) notesBox.redraw(notesBox.selectedObj);
	                    }
	                }
	            });
	        }
	    }
	
	    if(gd._context.editable) {
	        anntext.call(svgTextUtils.makeEditable, ann)
	            .call(textLayout)
	            .on('edit', function(_text) {
	                options.text = _text;
	                this.attr({'data-unformatted': options.text});
	                this.call(textLayout);
	                var update = {};
	                update['annotations['+index+'].text'] = options.text;
	                if(xa && xa.autorange) {
	                    update[xa._name+'.autorange'] = true;
	                }
	                if(ya && ya.autorange) {
	                    update[ya._name+'.autorange'] = true;
	                }
	                Plotly.relayout(gd,update);
	            });
	    }
	    else anntext.call(textLayout);
	
	    // rotate and position text and background
	    anng.attr({transform: 'rotate(' + textangle + ',' +
	                        annPosPx.x + ',' + annPosPx.y + ')'})
	        .call(Drawing.setPosition, annPosPx.x, annPosPx.y);
	};
	
	// add arrowhead(s) to a path or line d3 element el3
	// style: 1-6, first 5 are pointers, 6 is circle, 7 is square, 8 is none
	// ends is 'start', 'end' (default), 'start+end'
	// mag is magnification vs. default (default 1)
	annotations.arrowhead = function(el3, style, ends, mag) {
	    if(!isNumeric(mag)) mag = 1;
	    var el = el3.node(),
	        headStyle = annotations.ARROWPATHS[style||0];
	    if(!headStyle) return;
	
	    if(typeof ends !== 'string' || !ends) ends = 'end';
	
	    var scale = (Drawing.getPx(el3,'stroke-width') || 1) * mag,
	        stroke = el3.style('stroke') || Color.defaultLine,
	        opacity = el3.style('stroke-opacity') || 1,
	        doStart = ends.indexOf('start') >= 0,
	        doEnd = ends.indexOf('end') >= 0,
	        backOff = headStyle.backoff * scale,
	        start,
	        end,
	        startRot,
	        endRot;
	
	    if(el.nodeName === 'line') {
	        start = {x: +el3.attr('x1'), y: +el3.attr('y1')};
	        end = {x: +el3.attr('x2'), y: +el3.attr('y2')};
	        startRot = Math.atan2(start.y - end.y, start.x - end.x);
	        endRot = startRot + Math.PI;
	        if(backOff) {
	            var backOffX = backOff * Math.cos(startRot),
	                backOffY = backOff * Math.sin(startRot);
	
	            if(doStart) {
	                start.x -= backOffX;
	                start.y -= backOffY;
	                el3.attr({x1: start.x, y1: start.y});
	            }
	            if(doEnd) {
	                end.x += backOffX;
	                end.y += backOffY;
	                el3.attr({x2: end.x, y2: end.y});
	            }
	        }
	    }
	    else if(el.nodeName === 'path') {
	        var pathlen = el.getTotalLength(),
	            // using dash to hide the backOff region of the path.
	            // if we ever allow dash for the arrow we'll have to
	            // do better than this hack... maybe just manually
	            // combine the two
	            dashArray = '';
	
	        if(doStart) {
	            var start0 = el.getPointAtLength(0),
	                dstart = el.getPointAtLength(0.1);
	            startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
	            start = el.getPointAtLength(Math.min(backOff, pathlen));
	            if(backOff) dashArray = '0px,' + backOff + 'px,';
	        }
	
	        if(doEnd) {
	            var end0 = el.getPointAtLength(pathlen),
	                dend = el.getPointAtLength(pathlen - 0.1);
	            endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
	            end = el.getPointAtLength(Math.max(0, pathlen - backOff));
	
	            if(backOff) {
	                var shortening = dashArray ? 2 * backOff : backOff;
	                dashArray += (pathlen - shortening) + 'px,' + pathlen + 'px';
	            }
	        }
	        else if(dashArray) dashArray += pathlen + 'px';
	
	        if(dashArray) el3.style('stroke-dasharray', dashArray);
	    }
	
	    var drawhead = function(p, rot) {
	        if(style>5) rot=0; // don't rotate square or circle
	        d3.select(el.parentElement).append('path')
	            .attr({
	                'class': el3.attr('class'),
	                d: headStyle.path,
	                transform:
	                    'translate(' + p.x + ',' + p.y + ')' +
	                    'rotate(' + (rot * 180 / Math.PI) + ')' +
	                    'scale(' + scale + ')'
	            })
	            .style({
	                fill: stroke,
	                opacity: opacity,
	                'stroke-width': 0
	            });
	    };
	
	    if(doStart) drawhead(start, startRot);
	    if(doEnd) drawhead(end, endRot);
	};
	
	annotations.calcAutorange = function(gd) {
	    var fullLayout = gd._fullLayout,
	        annotationList = fullLayout.annotations;
	
	    if(!annotationList.length || !gd._fullData.length) return;
	
	    var annotationAxes = {};
	    annotationList.forEach(function(ann) {
	        annotationAxes[ann.xref] = true;
	        annotationAxes[ann.yref] = true;
	    });
	
	    var autorangedAnnos = Axes.list(gd).filter(function(ax) {
	        return ax.autorange && annotationAxes[ax._id];
	    });
	    if(!autorangedAnnos.length) return;
	
	    return Lib.syncOrAsync([
	        annotations.drawAll,
	        annAutorange
	    ], gd);
	};
	
	function annAutorange(gd) {
	    var fullLayout = gd._fullLayout;
	
	    // find the bounding boxes for each of these annotations'
	    // relative to their anchor points
	    // use the arrow and the text bg rectangle,
	    // as the whole anno may include hidden text in its bbox
	    fullLayout.annotations.forEach(function(ann) {
	        var xa = Axes.getFromId(gd, ann.xref),
	            ya = Axes.getFromId(gd, ann.yref);
	        if(!(xa || ya)) return;
	
	        var halfWidth = (ann._xsize || 0)/2,
	            xShift = ann._xshift || 0,
	            halfHeight = (ann._ysize || 0)/2,
	            yShift = ann._yshift || 0,
	            leftSize = halfWidth - xShift,
	            rightSize = halfWidth + xShift,
	            topSize = halfHeight - yShift,
	            bottomSize = halfHeight + yShift;
	        if(ann.showarrow) {
	            var headSize = 3 * ann.arrowsize * ann.arrowwidth;
	            leftSize = Math.max(leftSize, headSize);
	            rightSize = Math.max(rightSize, headSize);
	            topSize = Math.max(topSize, headSize);
	            bottomSize = Math.max(bottomSize, headSize);
	        }
	        if(xa && xa.autorange) {
	            Axes.expand(xa, [xa.l2c(ann.x)],{
	                ppadplus: rightSize,
	                ppadminus: leftSize
	            });
	        }
	        if(ya && ya.autorange) {
	            Axes.expand(ya, [ya.l2c(ann.y)], {
	                ppadplus: bottomSize,
	                ppadminus: topSize
	            });
	        }
	    });
	}
	
	// look for intersection of two line segments
	//   (1->2 and 3->4) - returns array [x,y] if they do, null if not
	function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	    var a = x2 - x1,
	        b = x3 - x1,
	        c = x4 - x3,
	        d = y2 - y1,
	        e = y3 - y1,
	        f = y4 - y3,
	        det = a * f - c * d;
	    // parallel lines? intersection is undefined
	    // ignore the case where they are colinear
	    if(det === 0) return null;
	    var t = (b * f - c * e) / det,
	        u = (b * d - a * e) / det;
	    // segments do not intersect?
	    if(u<0 || u>1 || t<0 || t>1) return null;
	
	    return {x: x1 + a * t, y: y1 + d * t};
	}


/***/ },
/* 406 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	/**
	 * centerx is a center of scaling tuned for maximum scalability of
	 * the arrowhead ie throughout mag=0.3..3 the head is joined smoothly
	 * to the line, but the endpoint moves.
	 * backoff is the distance to move the arrowhead, and the end of the
	 * line, in order to end at the right place
	 *
	 * TODO: option to have the pointed-to  point a little in front of the
	 * end of the line, as people tend to want a bit of a gap there...
	 */
	
	module.exports = [
	    // no arrow
	    '',
	    // wide with flat back
	    {
	        path: 'M-2.4,-3V3L0.6,0Z',
	        backoff: 0.6
	    },
	    // narrower with flat back
	    {
	        path: 'M-3.7,-2.5V2.5L1.3,0Z',
	        backoff: 1.3
	    },
	    // barbed
	    {
	        path: 'M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z',
	        backoff: 1.55
	    },
	    // wide line-drawn
	    {
	        path: 'M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z',
	        backoff: 1.6
	    },
	    // narrower line-drawn
	    {
	        path: 'M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z',
	        backoff: 2
	    },
	    // circle
	    {
	        path: 'M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z',
	        backoff: 0
	    },
	    // square
	    {
	        path: 'M2,2V-2H-2V2Z',
	        backoff: 0
	    }
	];


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var ARROWPATHS = __webpack_require__(406);
	var fontAttrs = __webpack_require__(336);
	var cartesianConstants = __webpack_require__(352);
	var extendFlat = __webpack_require__(324).extendFlat;
	
	
	module.exports = {
	    _isLinkedToArray: true,
	
	    text: {
	        valType: 'string',
	        role: 'info',
	        description: [
	            'Sets the text associated with this annotation.',
	            'Plotly uses a subset of HTML tags to do things like',
	            'newline (<br>), bold (<b></b>), italics (<i></i>),',
	            'hyperlinks (<a href=\'...\'></a>). Tags <em>, <sup>, <sub>',
	            '<span> are also supported.'
	        ].join(' ')
	    },
	    textangle: {
	        valType: 'angle',
	        dflt: 0,
	        role: 'style',
	        description: [
	            'Sets the angle at which the `text` is drawn',
	            'with respect to the horizontal.'
	        ].join(' ')
	    },
	    font: extendFlat({}, fontAttrs, {
	        description: 'Sets the annotation text font.'
	    }),
	    opacity: {
	        valType: 'number',
	        min: 0,
	        max: 1,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the opacity of the annotation (text + arrow).'
	    },
	    align: {
	        valType: 'enumerated',
	        values: ['left', 'center', 'right'],
	        dflt: 'center',
	        role: 'style',
	        description: [
	            'Sets the vertical alignment of the `text` with',
	            'respect to the set `x` and `y` position.',
	            'Has only an effect if `text` spans more two or more lines',
	            '(i.e. `text` contains one or more <br> HTML tags).'
	        ].join(' ')
	    },
	    bgcolor: {
	        valType: 'color',
	        dflt: 'rgba(0,0,0,0)',
	        role: 'style',
	        description: 'Sets the background color of the annotation.'
	    },
	    bordercolor: {
	        valType: 'color',
	        dflt: 'rgba(0,0,0,0)',
	        role: 'style',
	        description: [
	            'Sets the color of the border enclosing the annotation `text`.'
	        ].join(' ')
	    },
	    borderpad: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: [
	            'Sets the padding (in px) between the `text`',
	            'and the enclosing border.'
	        ].join(' ')
	    },
	    borderwidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 1,
	        role: 'style',
	        description: [
	            'Sets the width (in px) of the border enclosing',
	            'the annotation `text`.'
	        ].join(' ')
	    },
	    // arrow
	    showarrow: {
	        valType: 'boolean',
	        dflt: true,
	        role: 'style',
	        description: [
	            'Determines whether or not the annotation is drawn with an arrow.',
	            'If *true*, `text` is placed near the arrow\'s tail.',
	            'If *false*, `text` lines up with the `x` and `y` provided.'
	        ].join(' ')
	    },
	    arrowcolor: {
	        valType: 'color',
	        role: 'style',
	        description: 'Sets the color of the annotation arrow.'
	    },
	    arrowhead: {
	        valType: 'integer',
	        min: 0,
	        max: ARROWPATHS.length,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the annotation arrow head style.'
	    },
	    arrowsize: {
	        valType: 'number',
	        min: 0.3,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the size (in px) of annotation arrow head.'
	    },
	    arrowwidth: {
	        valType: 'number',
	        min: 0.1,
	        role: 'style',
	        description: 'Sets the width (in px) of annotation arrow.'
	    },
	    ax: {
	        valType: 'number',
	        dflt: -10,
	        role: 'info',
	        description: [
	            'Sets the x component of the arrow tail about the arrow head.',
	            'A positive (negative) component corresponds to an arrow pointing',
	            'from right to left (left to right)'
	        ].join(' ')
	    },
	    ay: {
	        valType: 'number',
	        dflt: -30,
	        role: 'info',
	        description: [
	            'Sets the y component of the arrow tail about the arrow head.',
	            'A positive (negative) component corresponds to an arrow pointing',
	            'from bottom to top (top to bottom)'
	        ].join(' ')
	    },
	    // positioning
	    xref: {
	        valType: 'enumerated',
	        values: [
	            'paper',
	            cartesianConstants.idRegex.x.toString()
	        ],
	        role: 'info',
	        description: [
	            'Sets the annotation\'s x coordinate axis.',
	            'If set to an x axis id (e.g. *x* or *x2*), the `x` position',
	            'refers to an x coordinate',
	            'If set to *paper*, the `x` position refers to the distance from',
	            'the left side of the plotting area in normalized coordinates',
	            'where 0 (1) corresponds to the left (right) side.'
	        ].join(' ')
	    },
	    x: {
	        valType: 'number',
	        role: 'info',
	        description: [
	            'Sets the annotation\'s x position.',
	            'Note that dates and categories are converted to numbers.'
	        ].join(' ')
	    },
	    xanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'left', 'center', 'right'],
	        dflt: 'auto',
	        role: 'info',
	        description: [
	            'Sets the annotation\'s horizontal position anchor',
	            'This anchor binds the `x` position to the *left*, *center*',
	            'or *right* of the annotation.',
	            'For example, if `x` is set to 1, `xref` to *paper* and',
	            '`xanchor` to *right* then the right-most portion of the',
	            'annotation lines up with the right-most edge of the',
	            'plotting area.',
	            'If *auto*, the anchor is equivalent to *center* for',
	            'data-referenced annotations',
	            'whereas for paper-referenced, the anchor picked corresponds',
	            'to the closest side.'
	        ].join(' ')
	    },
	    yref: {
	        valType: 'enumerated',
	        values: [
	            'paper',
	            cartesianConstants.idRegex.y.toString()
	        ],
	        role: 'info',
	        description: [
	            'Sets the annotation\'s y coordinate axis.',
	            'If set to an y axis id (e.g. *y* or *y2*), the `y` position',
	            'refers to an y coordinate',
	            'If set to *paper*, the `y` position refers to the distance from',
	            'the bottom of the plotting area in normalized coordinates',
	            'where 0 (1) corresponds to the bottom (top).'
	        ].join(' ')
	    },
	    y: {
	        valType: 'number',
	        role: 'info',
	        description: [
	            'Sets the annotation\'s y position.',
	            'Note that dates and categories are converted to numbers.'
	        ].join(' ')
	    },
	    yanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'top', 'middle', 'bottom'],
	        dflt: 'auto',
	        role: 'info',
	        description: [
	            'Sets the annotation\'s vertical position anchor',
	            'This anchor binds the `y` position to the *top*, *middle*',
	            'or *bottom* of the annotation.',
	            'For example, if `y` is set to 1, `yref` to *paper* and',
	            '`yanchor` to *top* then the top-most portion of the',
	            'annotation lines up with the top-most edge of the',
	            'plotting area.',
	            'If *auto*, the anchor is equivalent to *middle* for',
	            'data-referenced annotations',
	            'whereas for paper-referenced, the anchor picked corresponds',
	            'to the closest side.'
	        ].join(' ')
	    },
	
	    _deprecated: {
	        ref: {
	            valType: 'string',
	            role: 'info',
	            description: [
	                'Obsolete. Set `xref` and `yref` separately instead.'
	            ].join(' ')
	        }
	    }
	};


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var Axes = __webpack_require__(338);
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	
	
	var shapes = module.exports = {};
	
	shapes.layoutAttributes = __webpack_require__(409);
	
	shapes.supplyLayoutDefaults = function(layoutIn, layoutOut) {
	    var containerIn = layoutIn.shapes || [],
	        containerOut = layoutOut.shapes = [];
	
	    for(var i = 0; i < containerIn.length; i++) {
	        containerOut.push(handleShapeDefaults(containerIn[i] || {}, layoutOut));
	    }
	};
	
	function handleShapeDefaults(shapeIn, fullLayout) {
	    var shapeOut = {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(shapeIn, shapeOut, shapes.layoutAttributes, attr, dflt);
	    }
	
	    coerce('layer');
	    coerce('opacity');
	    coerce('fillcolor');
	    coerce('line.color');
	    coerce('line.width');
	    coerce('line.dash');
	    var dfltType = shapeIn.path ? 'path' : 'rect',
	        shapeType = coerce('type', dfltType);
	
	    // positioning
	    var axLetters = ['x','y'];
	    for(var i = 0; i < 2; i++) {
	        var axLetter = axLetters[i],
	            tdMock = {_fullLayout: fullLayout};
	
	        // xref, yref
	        var axRef = Axes.coerceRef(shapeIn, shapeOut, tdMock, axLetter);
	
	        if(shapeType !== 'path') {
	            var dflt0 = 0.25,
	                dflt1 = 0.75;
	            if(axRef !== 'paper') {
	                var ax = Axes.getFromId(tdMock, axRef),
	                    convertFn = linearToData(ax);
	                dflt0 = convertFn(ax.range[0] + dflt0 * (ax.range[1] - ax.range[0]));
	                dflt1 = convertFn(ax.range[0] + dflt1 * (ax.range[1] - ax.range[0]));
	            }
	            // x0, x1 (and y0, y1)
	            coerce(axLetter + '0', dflt0);
	            coerce(axLetter + '1', dflt1);
	        }
	    }
	
	    if(shapeType === 'path') {
	        coerce('path');
	    } else {
	        Lib.noneOrAll(shapeIn, shapeOut, ['x0', 'x1', 'y0', 'y1']);
	    }
	
	    return shapeOut;
	}
	
	// special position conversion functions... category axis positions can't be
	// specified by their data values, because they don't make a continuous mapping.
	// so these have to be specified in terms of the category serial numbers,
	// but can take fractional values. Other axis types we specify position based on
	// the actual data values.
	// TODO: this should really be part of axes, but for now it's only used here.
	// eventually annotations and axis ranges will use this too.
	// what should we do, invent a new letter for "data except if it's category"?
	function dataToLinear(ax) { return ax.type === 'category' ? ax.c2l : ax.d2l; }
	
	function linearToData(ax) { return ax.type === 'category' ? ax.l2c : ax.l2d; }
	
	shapes.drawAll = function(gd) {
	    var fullLayout = gd._fullLayout;
	
	    // Remove previous shapes before drawing new in shapes in fullLayout.shapes
	    fullLayout._shapeUpperLayer.selectAll('path').remove();
	    fullLayout._shapeLowerLayer.selectAll('path').remove();
	    fullLayout._shapeSubplotLayer.selectAll('path').remove();
	
	    for(var i = 0; i < fullLayout.shapes.length; i++) {
	        shapes.draw(gd, i);
	    }
	    // may need to resurrect this if we put text (LaTeX) in shapes
	    // return Plotly.Plots.previousPromises(gd);
	};
	
	shapes.add = function(gd) {
	    var nextShape = gd._fullLayout.shapes.length;
	    Plotly.relayout(gd, 'shapes['+nextShape+']', 'add');
	};
	
	// -----------------------------------------------------
	// make or edit an annotation on the graph
	// -----------------------------------------------------
	
	// shapes are stored in gd.layout.shapes, an array of objects
	// index can point to one item in this array,
	//  or non-numeric to simply add a new one
	//  or -1 to modify all existing
	// opt can be the full options object, or one key (to be set to value)
	//  or undefined to simply redraw
	// if opt is blank, val can be 'add' or a full options object to add a new
	//  annotation at that point in the array, or 'remove' to delete this one
	shapes.draw = function(gd, index, opt, value) {
	    if(!isNumeric(index) || index === -1) {
	        // no index provided - we're operating on ALL shapes
	        if(!index && Array.isArray(value)) {
	            replaceAllShapes(gd, value);
	            return;
	        }
	        else if(value === 'remove') {
	            deleteAllShapes(gd);
	            return;
	        }
	        else if(opt && value !== 'add') {
	            updateAllShapes(gd, opt, value);
	            return;
	        }
	        else {
	            // add a new empty annotation
	            index = gd._fullLayout.shapes.length;
	            gd._fullLayout.shapes.push({});
	        }
	    }
	
	    if(!opt && value) {
	        if(value === 'remove') {
	            deleteShape(gd, index);
	            return;
	        }
	        else if(value === 'add' || Lib.isPlainObject(value)) {
	            insertShape(gd, index, value);
	        }
	    }
	
	    updateShape(gd, index, opt, value);
	};
	
	function replaceAllShapes(gd, newShapes) {
	    gd.layout.shapes = newShapes;
	    shapes.supplyLayoutDefaults(gd.layout, gd._fullLayout);
	    shapes.drawAll(gd);
	}
	
	function deleteAllShapes(gd) {
	    delete gd.layout.shapes;
	    gd._fullLayout.shapes = [];
	    shapes.drawAll(gd);
	}
	
	function updateAllShapes(gd, opt, value) {
	    for(var i = 0; i < gd._fullLayout.shapes.length; i++) {
	        shapes.draw(gd, i, opt, value);
	    }
	}
	
	function deleteShape(gd, index) {
	    getShapeLayer(gd, index)
	        .selectAll('[data-index="' + index + '"]')
	        .remove();
	
	    gd._fullLayout.shapes.splice(index, 1);
	
	    gd.layout.shapes.splice(index, 1);
	
	    for(var i = index; i < gd._fullLayout.shapes.length; i++) {
	        // redraw all shapes past the removed one,
	        // so they bind to the right events
	        getShapeLayer(gd, i)
	            .selectAll('[data-index="' + (i + 1) + '"]')
	            .attr('data-index', i);
	        shapes.draw(gd, i);
	    }
	}
	
	function insertShape(gd, index, newShape) {
	    gd._fullLayout.shapes.splice(index, 0, {});
	
	    var rule = Lib.isPlainObject(newShape) ?
	        Lib.extendFlat({}, newShape) :
	        {text: 'New text'};
	
	    if(gd.layout.shapes) {
	        gd.layout.shapes.splice(index, 0, rule);
	    } else {
	        gd.layout.shapes = [rule];
	    }
	
	    // there is no need to call shapes.draw(gd, index),
	    // because updateShape() is called from within shapes.draw()
	
	    for(var i = gd._fullLayout.shapes.length - 1; i > index; i--) {
	        getShapeLayer(gd, i)
	            .selectAll('[data-index="' + (i - 1) + '"]')
	            .attr('data-index', i);
	        shapes.draw(gd, i);
	    }
	}
	
	function updateShape(gd, index, opt, value) {
	    var i, n;
	
	    // remove the existing shape if there is one
	    getShapeLayer(gd, index)
	        .selectAll('[data-index="' + index + '"]')
	        .remove();
	
	    // remember a few things about what was already there,
	    var optionsIn = gd.layout.shapes[index];
	
	    // (from annos...) not sure how we're getting here... but C12 is seeing a bug
	    // where we fail here when they add/remove annotations
	    // TODO: clean this up and remove it.
	    if(!optionsIn) return;
	
	    var oldRef = {xref: optionsIn.xref, yref: optionsIn.yref};
	
	    // alter the input shape as requested
	    var optionsEdit = {};
	    if(typeof opt === 'string' && opt) optionsEdit[opt] = value;
	    else if(Lib.isPlainObject(opt)) optionsEdit = opt;
	
	    var optionKeys = Object.keys(optionsEdit);
	    for(i = 0; i < optionKeys.length; i++) {
	        var k = optionKeys[i];
	        Lib.nestedProperty(optionsIn, k).set(optionsEdit[k]);
	    }
	
	    var posAttrs = ['x0', 'x1', 'y0', 'y1'];
	    for(i = 0; i < 4; i++) {
	        var posAttr = posAttrs[i];
	        // if we don't have an explicit position already,
	        // don't set one just because we're changing references
	        // or axis type.
	        // the defaults will be consistent most of the time anyway,
	        // except in log/linear changes
	        if(optionsEdit[posAttr]!==undefined ||
	                optionsIn[posAttr]===undefined) {
	            continue;
	        }
	
	        var axLetter = posAttr.charAt(0),
	            axOld = Axes.getFromId(gd,
	                Axes.coerceRef(oldRef, {}, gd, axLetter)),
	            axNew = Axes.getFromId(gd,
	                Axes.coerceRef(optionsIn, {}, gd, axLetter)),
	            position = optionsIn[posAttr],
	            linearizedPosition;
	
	        if(optionsEdit[axLetter + 'ref']!==undefined) {
	            // first convert to fraction of the axis
	            if(axOld) {
	                linearizedPosition = dataToLinear(axOld)(position);
	                position = (linearizedPosition - axOld.range[0]) /
	                    (axOld.range[1] - axOld.range[0]);
	            } else {
	                position = (position - axNew.domain[0]) /
	                    (axNew.domain[1] - axNew.domain[0]);
	            }
	
	            if(axNew) {
	                // then convert to new data coordinates at the same fraction
	                linearizedPosition = axNew.range[0] + position *
	                    (axNew.range[1] - axNew.range[0]);
	                position = linearToData(axNew)(linearizedPosition);
	            } else {
	                // or scale to the whole plot
	                position = axOld.domain[0] +
	                    position * (axOld.domain[1] - axOld.domain[0]);
	            }
	        }
	
	        optionsIn[posAttr] = position;
	    }
	
	    var options = handleShapeDefaults(optionsIn, gd._fullLayout);
	    gd._fullLayout.shapes[index] = options;
	
	    var attrs = {
	            'data-index': index,
	            'fill-rule': 'evenodd',
	            d: shapePath(gd, options)
	        },
	        clipAxes;
	
	    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';
	
	    if(options.layer !== 'below') {
	        clipAxes = (options.xref + options.yref).replace(/paper/g, '');
	        drawShape(gd._fullLayout._shapeUpperLayer);
	    }
	    else if(options.xref === 'paper' && options.yref === 'paper') {
	        clipAxes = '';
	        drawShape(gd._fullLayout._shapeLowerLayer);
	    }
	    else {
	        var plots = gd._fullLayout._plots || {},
	            subplots = Object.keys(plots),
	            plotinfo;
	
	        for(i = 0, n = subplots.length; i < n; i++) {
	            plotinfo = plots[subplots[i]];
	            clipAxes = subplots[i];
	
	            if(isShapeInSubplot(gd, options, plotinfo.id)) {
	                drawShape(plotinfo.shapelayer);
	            }
	        }
	    }
	
	    function drawShape(shapeLayer) {
	        var path = shapeLayer.append('path')
	            .attr(attrs)
	            .style('opacity', options.opacity)
	            .call(Color.stroke, lineColor)
	            .call(Color.fill, options.fillcolor)
	            .call(Drawing.dashLine, options.line.dash, options.line.width);
	
	        if(clipAxes) {
	            path.call(Drawing.setClipUrl,
	                'clip' + gd._fullLayout._uid + clipAxes);
	        }
	    }
	}
	
	function getShapeLayer(gd, index) {
	    var shape = gd._fullLayout.shapes[index],
	        shapeLayer = gd._fullLayout._shapeUpperLayer;
	
	    if(!shape) {
	        console.log('getShapeLayer: undefined shape: index', index);
	    }
	    else if(shape.layer === 'below') {
	        shapeLayer = (shape.xref === 'paper' && shape.yref === 'paper') ?
	            gd._fullLayout._shapeLowerLayer :
	            gd._fullLayout._shapeSubplotLayer;
	    }
	
	    return shapeLayer;
	}
	
	function isShapeInSubplot(gd, shape, subplot) {
	    var xa = Plotly.Axes.getFromId(gd, subplot, 'x')._id,
	        ya = Plotly.Axes.getFromId(gd, subplot, 'y')._id;
	    return shape.layer === 'below' && (xa === shape.xref || ya === shape.yref);
	}
	
	function decodeDate(convertToPx) {
	    return function(v) { return convertToPx(v.replace('_', ' ')); };
	}
	
	function shapePath(gd, options) {
	    var type = options.type,
	        xa = Axes.getFromId(gd, options.xref),
	        ya = Axes.getFromId(gd, options.yref),
	        gs = gd._fullLayout._size,
	        x2l,
	        x2p,
	        y2l,
	        y2p;
	
	    if(xa) {
	        x2l = dataToLinear(xa);
	        x2p = function(v) { return xa._offset + xa.l2p(x2l(v, true)); };
	    }
	    else {
	        x2p = function(v) { return gs.l + gs.w * v; };
	    }
	
	    if(ya) {
	        y2l = dataToLinear(ya);
	        y2p = function(v) { return ya._offset + ya.l2p(y2l(v, true)); };
	    }
	    else {
	        y2p = function(v) { return gs.t + gs.h * (1 - v); };
	    }
	
	    if(type==='path') {
	        if(xa && xa.type==='date') x2p = decodeDate(x2p);
	        if(ya && ya.type==='date') y2p = decodeDate(y2p);
	        return shapes.convertPath(options.path, x2p, y2p);
	    }
	
	    var x0 = x2p(options.x0),
	        x1 = x2p(options.x1),
	        y0 = y2p(options.y0),
	        y1 = y2p(options.y1);
	
	    if(type==='line') return 'M'+x0+','+y0+'L'+x1+','+y1;
	    if(type==='rect') return 'M'+x0+','+y0+'H'+x1+'V'+y1+'H'+x0+'Z';
	    // circle
	    var cx = (x0 + x1) / 2,
	        cy = (y0 + y1) / 2,
	        rx = Math.abs(cx - x0),
	        ry = Math.abs(cy - y0),
	        rArc = 'A' + rx + ',' + ry,
	        rightPt = (cx + rx) + ',' + cy,
	        topPt = cx + ',' + (cy - ry);
	    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +
	        rArc + ' 0 0,1 ' + rightPt + 'Z';
	}
	
	var segmentRE = /[MLHVQCTSZ][^MLHVQCTSZ]*/g,
	    paramRE = /[^\s,]+/g,
	
	    // which numbers in each path segment are x (or y) values
	    // drawn is which param is a drawn point, as opposed to a
	    // control point (which doesn't count toward autorange.
	    // TODO: this means curved paths could extend beyond the
	    // autorange bounds. This is a bit tricky to get right
	    // unless we revert to bounding boxes, but perhaps there's
	    // a calculation we could do...)
	    paramIsX = {
	        M: {0: true, drawn: 0},
	        L: {0: true, drawn: 0},
	        H: {0: true, drawn: 0},
	        V: {},
	        Q: {0: true, 2: true, drawn: 2},
	        C: {0: true, 2: true, 4: true, drawn: 4},
	        T: {0: true, drawn: 0},
	        S: {0: true, 2: true, drawn: 2},
	        // A: {0: true, 5: true},
	        Z: {}
	    },
	
	    paramIsY = {
	        M: {1: true, drawn: 1},
	        L: {1: true, drawn: 1},
	        H: {},
	        V: {0: true, drawn: 0},
	        Q: {1: true, 3: true, drawn: 3},
	        C: {1: true, 3: true, 5: true, drawn: 5},
	        T: {1: true, drawn: 1},
	        S: {1: true, 3: true, drawn: 5},
	        // A: {1: true, 6: true},
	        Z: {}
	    },
	    numParams = {
	        M: 2,
	        L: 2,
	        H: 1,
	        V: 1,
	        Q: 4,
	        C: 6,
	        T: 2,
	        S: 4,
	        // A: 7,
	        Z: 0
	    };
	
	shapes.convertPath = function(pathIn, x2p, y2p) {
	    // convert an SVG path string from data units to pixels
	    return pathIn.replace(segmentRE, function(segment) {
	        var paramNumber = 0,
	            segmentType = segment.charAt(0),
	            xParams = paramIsX[segmentType],
	            yParams = paramIsY[segmentType],
	            nParams = numParams[segmentType];
	
	        var paramString = segment.substr(1).replace(paramRE, function(param) {
	            if(xParams[paramNumber]) param = x2p(param);
	            else if(yParams[paramNumber]) param = y2p(param);
	            paramNumber++;
	
	            if(paramNumber > nParams) param = 'X';
	            return param;
	        });
	
	        if(paramNumber > nParams) {
	            paramString = paramString.replace(/[\s,]*X.*/, '');
	            console.log('ignoring extra params in segment ' + segment);
	        }
	
	        return segmentType + paramString;
	    });
	};
	
	shapes.calcAutorange = function(gd) {
	    var fullLayout = gd._fullLayout,
	        shapeList = fullLayout.shapes,
	        i,
	        shape,
	        ppad,
	        ax,
	        bounds;
	
	    if(!shapeList.length || !gd._fullData.length) return;
	
	    for(i = 0; i < shapeList.length; i++) {
	        shape = shapeList[i];
	        ppad = shape.line.width / 2;
	        if(shape.xref !== 'paper') {
	            ax = Axes.getFromId(gd, shape.xref);
	            bounds = shapeBounds(ax, shape.x0, shape.x1, shape.path, paramIsX);
	            if(bounds) Axes.expand(ax, bounds, {ppad: ppad});
	        }
	        if(shape.yref !== 'paper') {
	            ax = Axes.getFromId(gd, shape.yref);
	            bounds = shapeBounds(ax, shape.y0, shape.y1, shape.path, paramIsY);
	            if(bounds) Axes.expand(ax, bounds, {ppad: ppad});
	        }
	    }
	};
	
	function shapeBounds(ax, v0, v1, path, paramsToUse) {
	    var convertVal = (ax.type==='category') ? Number : ax.d2c;
	
	    if(v0 !== undefined) return [convertVal(v0), convertVal(v1)];
	    if(!path) return;
	
	    var min = Infinity,
	        max = -Infinity,
	        segments = path.match(segmentRE),
	        i,
	        segment,
	        drawnParam,
	        params,
	        val;
	
	    if(ax.type==='date') convertVal = decodeDate(convertVal);
	
	    for(i = 0; i < segments.length; i++) {
	        segment = segments[i];
	        drawnParam = paramsToUse[segment.charAt(0)].drawn;
	        if(drawnParam === undefined) continue;
	
	        params = segments[i].substr(1).match(paramRE);
	        if(!params || params.length < drawnParam) continue;
	
	        val = convertVal(params[drawnParam]);
	        if(val < min) min = val;
	        if(val > max) max = val;
	    }
	    if(max >= min) return [min, max];
	}


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var annAttrs = __webpack_require__(407);
	var scatterAttrs = __webpack_require__(410);
	var extendFlat = __webpack_require__(324).extendFlat;
	
	var scatterLineAttrs = scatterAttrs.line;
	
	module.exports = {
	    _isLinkedToArray: true,
	
	    type: {
	        valType: 'enumerated',
	        values: ['circle', 'rect', 'path', 'line'],
	        role: 'info',
	        description: [
	            'Specifies the shape type to be drawn.',
	
	            'If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`)',
	
	            'If *circle*, a circle is drawn from',
	            '((`x0`+`x1`)/2, (`y0`+`y1`)/2))',
	            'with radius',
	            '(|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|)',
	
	            'If *rect*, a rectangle is drawn linking',
	            '(`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`), (`x0`,`y0`)',
	
	            'If *path*, draw a custom SVG path using `path`.'
	        ].join(' ')
	    },
	
	    layer: {
	        valType: 'enumerated',
	        values: ['below', 'above'],
	        dflt: 'above',
	        role: 'info',
	        description: 'Specifies whether shapes are drawn below or above traces.'
	    },
	
	    xref: extendFlat({}, annAttrs.xref, {
	        description: [
	            'Sets the shape\'s x coordinate axis.',
	            'If set to an x axis id (e.g. *x* or *x2*), the `x` position',
	            'refers to an x coordinate',
	            'If set to *paper*, the `x` position refers to the distance from',
	            'the left side of the plotting area in normalized coordinates',
	            'where *0* (*1*) corresponds to the left (right) side.',
	            'If the axis `type` is *log*, then you must take the',
	            'log of your desired range.',
	            'If the axis `type` is *date*, then you must convert',
	            'the date to unix time in milliseconds.'
	        ].join(' ')
	    }),
	    x0: {
	        valType: 'any',
	        role: 'info',
	        description: [
	            'Sets the shape\'s starting x position.',
	            'See `type` for more info.'
	        ].join(' ')
	    },
	    x1: {
	        valType: 'any',
	        role: 'info',
	        description: [
	            'Sets the shape\'s end x position.',
	            'See `type` for more info.'
	        ].join(' ')
	    },
	
	    yref: extendFlat({}, annAttrs.yref, {
	        description: [
	            'Sets the annotation\'s y coordinate axis.',
	            'If set to an y axis id (e.g. *y* or *y2*), the `y` position',
	            'refers to an y coordinate',
	            'If set to *paper*, the `y` position refers to the distance from',
	            'the bottom of the plotting area in normalized coordinates',
	            'where *0* (*1*) corresponds to the bottom (top).'
	        ].join(' ')
	    }),
	    y0: {
	        valType: 'any',
	        role: 'info',
	        description: [
	            'Sets the shape\'s starting y position.',
	            'See `type` for more info.'
	        ].join(' ')
	    },
	    y1: {
	        valType: 'any',
	        role: 'info',
	        description: [
	            'Sets the shape\'s end y position.',
	            'See `type` for more info.'
	        ].join(' ')
	    },
	
	    path: {
	        valType: 'string',
	        role: 'info',
	        description: [
	            'For `type` *path* - a valid SVG path but with the pixel values',
	            'replaced by data values. There are a few restrictions / quirks',
	            'only absolute instructions, not relative. So the allowed segments',
	            'are: M, L, H, V, Q, C, T, S, and Z',
	            'arcs (A) are not allowed because radius rx and ry are relative.',
	
	            'In the future we could consider supporting relative commands,',
	            'but we would have to decide on how to handle date and log axes.',
	            'Note that even as is, Q and C Bezier paths that are smooth on',
	            'linear axes may not be smooth on log, and vice versa.',
	            'no chained "polybezier" commands - specify the segment type for',
	            'each one.',
	
	            'On category axes, values are numbers scaled to the serial numbers',
	            'of categories because using the categories themselves there would',
	            'be no way to describe fractional positions',
	            'On data axes: because space and T are both normal components of path',
	            'strings, we can\'t use either to separate date from time parts.',
	            'Therefore we\'ll use underscore for this purpose:',
	            '2015-02-21_13:45:56.789'
	        ].join(' ')
	    },
	
	    opacity: {
	        valType: 'number',
	        min: 0,
	        max: 1,
	        dflt: 1,
	        role: 'info',
	        description: 'Sets the opacity of the shape.'
	    },
	    line: {
	        color: scatterLineAttrs.color,
	        width: scatterLineAttrs.width,
	        dash: scatterLineAttrs.dash,
	        role: 'info'
	    },
	    fillcolor: {
	        valType: 'color',
	        dflt: 'rgba(0,0,0,0)',
	        role: 'info',
	        description: [
	            'Sets the color filling the shape\'s interior.'
	        ].join(' ')
	    }
	};


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Drawing = __webpack_require__(340);
	
	var constants = __webpack_require__(411);
	
	
	module.exports = {
	    x: {
	        valType: 'data_array',
	        description: 'Sets the x coordinates.'
	    },
	    x0: {
	        valType: 'any',
	        dflt: 0,
	        role: 'info',
	        description: [
	            'Alternate to `x`.',
	            'Builds a linear space of x coordinates.',
	            'Use with `dx`',
	            'where `x0` is the starting coordinate and `dx` the step.'
	        ].join(' ')
	    },
	    dx: {
	        valType: 'number',
	        dflt: 1,
	        role: 'info',
	        description: [
	            'Sets the x coordinate step.',
	            'See `x0` for more info.'
	        ].join(' ')
	    },
	    y: {
	        valType: 'data_array',
	        description: 'Sets the y coordinates.'
	    },
	    y0: {
	        valType: 'any',
	        dflt: 0,
	        role: 'info',
	        description: [
	            'Alternate to `y`.',
	            'Builds a linear space of y coordinates.',
	            'Use with `dy`',
	            'where `y0` is the starting coordinate and `dy` the step.'
	        ].join(' ')
	    },
	    dy: {
	        valType: 'number',
	        dflt: 1,
	        role: 'info',
	        description: [
	            'Sets the y coordinate step.',
	            'See `y0` for more info.'
	        ].join(' ')
	    },
	    text: {
	        valType: 'string',
	        role: 'info',
	        dflt: '',
	        arrayOk: true,
	        description: [
	            'Sets text elements associated with each (x,y) pair.',
	            'If a single string, the same string appears over',
	            'all the data points.',
	            'If an array of string, the items are mapped in order to the',
	            'this trace\'s (x,y) coordinates.'
	        ].join(' ')
	    },
	    mode: {
	        valType: 'flaglist',
	        flags: ['lines', 'markers', 'text'],
	        extras: ['none'],
	        role: 'info',
	        description: [
	            'Determines the drawing mode for this scatter trace.',
	            'If the provided `mode` includes *text* then the `text` elements',
	            'appear at the coordinates. Otherwise, the `text` elements',
	            'appear on hover.',
	            'If there are less than ' + constants.PTS_LINESONLY + ' points,',
	            'then the default is *lines+markers*. Otherwise, *lines*.'
	        ].join(' ')
	    },
	    line: {
	        color: {
	            valType: 'color',
	            role: 'style',
	            description: 'Sets the line color.'
	        },
	        width: {
	            valType: 'number',
	            min: 0,
	            dflt: 2,
	            role: 'style',
	            description: 'Sets the line width (in px).'
	        },
	        shape: {
	            valType: 'enumerated',
	            values: ['linear', 'spline', 'hv', 'vh', 'hvh', 'vhv'],
	            dflt: 'linear',
	            role: 'style',
	            description: [
	                'Determines the line shape.',
	                'With *spline* the lines are drawn using spline interpolation.',
	                'The other available values correspond to step-wise line shapes.'
	            ].join(' ')
	        },
	        smoothing: {
	            valType: 'number',
	            min: 0,
	            max: 1.3,
	            dflt: 1,
	            role: 'style',
	            description: [
	                'Has an effect only if `shape` is set to *spline*',
	                'Sets the amount of smoothing.',
	                '*0* corresponds to no smoothing (equivalent to a *linear* shape).'
	            ].join(' ')
	        },
	        dash: {
	            valType: 'string',
	            // string type usually doesn't take values... this one should really be
	            // a special type or at least a special coercion function, from the GUI
	            // you only get these values but elsewhere the user can supply a list of
	            // dash lengths in px, and it will be honored
	            values: ['solid', 'dot', 'dash', 'longdash', 'dashdot', 'longdashdot'],
	            dflt: 'solid',
	            role: 'style',
	            description: [
	                'Sets the style of the lines. Set to a dash string type',
	                'or a dash length in px.'
	            ].join(' ')
	        }
	    },
	    connectgaps: {
	        valType: 'boolean',
	        dflt: false,
	        role: 'info',
	        description: [
	            'Determines whether or not gaps',
	            '(i.e. {nan} or missing values)',
	            'in the provided data arrays are connected.'
	        ].join(' ')
	    },
	    fill: {
	        valType: 'enumerated',
	        values: ['none', 'tozeroy', 'tozerox', 'tonexty', 'tonextx', 'toself', 'tonext'],
	        dflt: 'none',
	        role: 'style',
	        description: [
	            'Sets the area to fill with a solid color.',
	            'Use with `fillcolor` if not *none*.',
	            '*tozerox* and *tozeroy* fill to x=0 and y=0 respectively.',
	            '*tonextx* and *tonexty* fill between the endpoints of this',
	            'trace and the endpoints of the trace before it, connecting those',
	            'endpoints with straight lines (to make a stacked area graph);',
	            'if there is no trace before it, they behave like *tozerox* and',
	            '*tozeroy*.',
	            '*toself* connects the endpoints of the trace (or each segment',
	            'of the trace if it has gaps) into a closed shape.',
	            '*tonext* fills the space between two traces if one completely',
	            'encloses the other (eg consecutive contour lines), and behaves like',
	            '*toself* if there is no trace before it. *tonext* should not be',
	            'used if one trace does not enclose the other.'
	        ].join(' ')
	    },
	    fillcolor: {
	        valType: 'color',
	        role: 'style',
	        description: [
	            'Sets the fill color.',
	            'Defaults to a half-transparent variant of the line color,',
	            'marker color, or marker line color, whichever is available.'
	        ].join(' ')
	    },
	    marker: {
	        symbol: {
	            valType: 'enumerated',
	            values: Drawing.symbolList,
	            dflt: 'circle',
	            arrayOk: true,
	            role: 'style',
	            description: [
	                'Sets the marker symbol type.',
	                'Adding 100 is equivalent to appending *-open* to a symbol name.',
	                'Adding 200 is equivalent to appending *-dot* to a symbol name.',
	                'Adding 300 is equivalent to appending *-open-dot*',
	                'or *dot-open* to a symbol name.'
	            ].join(' ')
	        },
	        opacity: {
	            valType: 'number',
	            min: 0,
	            max: 1,
	            arrayOk: true,
	            role: 'style',
	            description: 'Sets the marker opacity.'
	        },
	        size: {
	            valType: 'number',
	            min: 0,
	            dflt: 6,
	            arrayOk: true,
	            role: 'style',
	            description: 'Sets the marker size (in px).'
	        },
	        color: {
	            valType: 'color',
	            arrayOk: true,
	            role: 'style',
	            description: [
	                'Sets the marker color. It accepts either a specific color',
	                'or an array of values that are mapped to the colorscale',
	                'relative to the max and min values of the array or relative to',
	                '`cmin` and `cmax` if set.'
	            ].join(' ')
	        },
	        maxdisplayed: {
	            valType: 'number',
	            min: 0,
	            dflt: 0,
	            role: 'style',
	            description: [
	                'Sets a maximum number of points to be drawn on the graph.',
	                '*0* corresponds to no limit.'
	            ].join(' ')
	        },
	        sizeref: {
	            valType: 'number',
	            dflt: 1,
	            role: 'style',
	            description: [
	                'Has an effect only if `marker.size` is set to a numerical array.',
	                'Sets the scale factor used to determine the rendered size of',
	                'marker points. Use with `sizemin` and `sizemode`.'
	            ].join(' ')
	        },
	        sizemin: {
	            valType: 'number',
	            min: 0,
	            dflt: 0,
	            role: 'style',
	            description: [
	                'Has an effect only if `marker.size` is set to a numerical array.',
	                'Sets the minimum size (in px) of the rendered marker points.'
	            ].join(' ')
	        },
	        sizemode: {
	            valType: 'enumerated',
	            values: ['diameter', 'area'],
	            dflt: 'diameter',
	            role: 'info',
	            description: [
	                'Has an effect only if `marker.size` is set to a numerical array.',
	                'Sets the rule for which the data in `size` is converted',
	                'to pixels.'
	            ].join(' ')
	        },
	        colorscale: {
	            valType: 'colorscale',
	            role: 'style',
	            description: [
	                'Sets the colorscale and only has an effect',
	                'if `marker.color` is set to a numerical array.',
	                'The colorscale must be an array containing',
	                'arrays mapping a normalized value to an',
	                'rgb, rgba, hex, hsl, hsv, or named color string.',
	                'At minimum, a mapping for the lowest (0) and highest (1)',
	                'values are required. For example,',
	                '`[[0, \'rgb(0,0,255)\', [1, \'rgb(255,0,0)\']]`.',
	                'To control the bounds of the colorscale in color space,',
	                'use `marker.cmin` and `marker.cmax`.'
	            ].join(' ')
	        },
	        cauto: {
	            valType: 'boolean',
	            dflt: true,
	            role: 'style',
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Determines the whether or not the color domain is computed',
	                'automatically.'
	            ].join(' ')
	        },
	        cmax: {
	            valType: 'number',
	            dflt: null,
	            role: 'info',
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Sets the upper bound of the color domain.',
	                'Value should be associated to the `marker.color` array index,',
	                'and if set, `marker.cmin` must be set as well.'
	            ].join(' ')
	        },
	        cmin: {
	            valType: 'number',
	            dflt: null,
	            role: 'info',
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Sets the lower bound of the color domain.',
	                'Value should be associated to the `marker.color` array index,',
	                'and if set, `marker.cmax` must be set as well.'
	            ].join(' ')
	        },
	        autocolorscale: {
	            valType: 'boolean',
	            dflt: true,
	            role: 'style',
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Determines whether or not the colorscale is picked using',
	                'values inside `marker.color`.'
	            ].join(' ')
	        },
	        reversescale: {
	            valType: 'boolean',
	            role: 'style',
	            dflt: false,
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Reverses the colorscale.'
	            ].join(' ')
	        },
	        showscale: {
	            valType: 'boolean',
	            role: 'info',
	            dflt: false,
	            description: [
	                'Has an effect only if `marker.color` is set to a numerical array.',
	                'Determines whether or not a colorbar is displayed.'
	            ].join(' ')
	        },
	        line: {
	            color: {
	                valType: 'color',
	                arrayOk: true,
	                role: 'style',
	                description: [
	                    'Sets the marker outline color. It accepts either a specific color',
	                    'or an array of values that are mapped to the colorscale',
	                    'relative to the max and min values of the array or relative to',
	                    '`cmin` and `cmax` if set.'
	                ].join(' ')
	            },
	            width: {
	                valType: 'number',
	                min: 0,
	                arrayOk: true,
	                role: 'style',
	                description: 'Sets the width (in px) of the lines bounding the marker points.'
	            },
	            colorscale: {
	                valType: 'colorscale',
	                role: 'style',
	                description: [
	                    'Sets the colorscale and only has an effect',
	                    'if `marker.line.color` is set to a numerical array.',
	                    'The colorscale must be an array containing',
	                    'arrays mapping a normalized value to an',
	                    'rgb, rgba, hex, hsl, hsv, or named color string.',
	                    'At minimum, a mapping for the lowest (0) and highest (1)',
	                    'values are required. For example,',
	                    '`[[0, \'rgb(0,0,255)\', [1, \'rgb(255,0,0)\']]`.',
	                    'To control the bounds of the colorscale in color space,',
	                    'use `marker.line.cmin` and `marker.line.cmax`.'
	                ].join(' ')
	            },
	            cauto: {
	                valType: 'boolean',
	                dflt: true,
	                role: 'style',
	                description: [
	                    'Has an effect only if `marker.line.color` is set to a numerical array.',
	                    'Determines the whether or not the color domain is computed',
	                    'with respect to the input data.'
	                ].join(' ')
	            },
	            cmax: {
	                valType: 'number',
	                dflt: null,
	                role: 'info',
	                description: [
	                    'Has an effect only if `marker.line.color` is set to a numerical array.',
	                    'Sets the upper bound of the color domain.',
	                    'Value should be associated to the `marker.line.color` array index,',
	                    'and if set, `marker.line.cmin` must be set as well.'
	                ].join(' ')
	            },
	            cmin: {
	                valType: 'number',
	                dflt: null,
	                role: 'info',
	                description: [
	                    'Has an effect only if `marker.line.color` is set to a numerical array.',
	                    'Sets the lower bound of the color domain.',
	                    'Value should be associated to the `marker.line.color` array index,',
	                    'and if set, `marker.line.cmax` must be set as well.'
	                ].join(' ')
	            },
	            autocolorscale: {
	                valType: 'boolean',
	                dflt: true,
	                role: 'style',
	                description: [
	                    'Has an effect only if `marker.line.color` is set to a numerical array.',
	                    'Determines whether or not the colorscale is picked using',
	                    'the sign of values inside `marker.line.color`.'
	                ].join(' ')
	            },
	            reversescale: {
	                valType: 'boolean',
	                dflt: false,
	                role: 'style',
	                description: [
	                    'Has an effect only if `marker.line.color` is set to a numerical array.',
	                    'Reverses the colorscale.'
	                ].join(' ')
	            }
	        }
	    },
	    textposition: {
	        valType: 'enumerated',
	        values: [
	            'top left', 'top center', 'top right',
	            'middle left', 'middle center', 'middle right',
	            'bottom left', 'bottom center', 'bottom right'
	        ],
	        dflt: 'middle center',
	        arrayOk: true,
	        role: 'style',
	        description: [
	            'Sets the positions of the `text` elements',
	            'with respects to the (x,y) coordinates.'
	        ].join(' ')
	    },
	    textfont: {
	        family: {
	            valType: 'string',
	            role: 'style',
	            noBlank: true,
	            strict: true,
	            arrayOk: true
	        },
	        size: {
	            valType: 'number',
	            role: 'style',
	            min: 1,
	            arrayOk: true
	        },
	        color: {
	            valType: 'color',
	            role: 'style',
	            arrayOk: true
	        },
	        description: 'Sets the text font.'
	    },
	    r: {
	        valType: 'data_array',
	        description: [
	            'For polar chart only.',
	            'Sets the radial coordinates.'
	        ].join('')
	    },
	    t: {
	        valType: 'data_array',
	        description: [
	            'For polar chart only.',
	            'Sets the angular coordinates.'
	        ].join('')
	    },
	    _nestedModules: {  // nested module coupling
	        'error_y': 'ErrorBars',
	        'error_x': 'ErrorBars',
	        'marker.colorbar': 'Colorbar'
	    }
	};


/***/ },
/* 411 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	module.exports = {
	    PTS_LINESONLY: 20
	};


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	var legend = module.exports = {};
	
	legend.layoutAttributes = __webpack_require__(413);
	
	legend.supplyLayoutDefaults = __webpack_require__(414);
	
	legend.draw = __webpack_require__(416);
	
	legend.style = __webpack_require__(419);


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var fontAttrs = __webpack_require__(336);
	var colorAttrs = __webpack_require__(334);
	var extendFlat = __webpack_require__(324).extendFlat;
	
	
	module.exports = {
	    bgcolor: {
	        valType: 'color',
	        role: 'style',
	        description: 'Sets the legend background color.'
	    },
	    bordercolor: {
	        valType: 'color',
	        dflt: colorAttrs.defaultLine,
	        role: 'style',
	        description: 'Sets the color of the border enclosing the legend.'
	    },
	    borderwidth: {
	        valType: 'number',
	        min: 0,
	        dflt: 0,
	        role: 'style',
	        description: 'Sets the width (in px) of the border enclosing the legend.'
	    },
	    font: extendFlat({}, fontAttrs, {
	        description: 'Sets the font used to text the legend items.'
	    }),
	    orientation: {
	        valType: 'enumerated',
	        values: ['v', 'h'],
	        dflt: 'v',
	        role: 'info',
	        description: 'Sets the orientation of the legend.'
	    },
	    traceorder: {
	        valType: 'flaglist',
	        flags: ['reversed', 'grouped'],
	        extras: ['normal'],
	        role: 'style',
	        description: [
	            'Determines the order at which the legend items are displayed.',
	
	            'If *normal*, the items are displayed top-to-bottom in the same',
	            'order as the input data.',
	
	            'If *reversed*, the items are displayed in the opposite order',
	            'as *normal*.',
	
	            'If *grouped*, the items are displayed in groups',
	            '(when a trace `legendgroup` is provided).',
	
	            'if *grouped+reversed*, the items are displayed in the opposite order',
	            'as *grouped*.'
	        ].join(' ')
	    },
	    tracegroupgap: {
	        valType: 'number',
	        min: 0,
	        dflt: 10,
	        role: 'style',
	        description: [
	            'Sets the amount of vertical space (in px) between legend groups.'
	        ].join(' ')
	    },
	    x: {
	        valType: 'number',
	        min: -2,
	        max: 3,
	        dflt: 1.02,
	        role: 'style',
	        description: 'Sets the x position (in normalized coordinates) of the legend.'
	    },
	    xanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'left', 'center', 'right'],
	        dflt: 'left',
	        role: 'info',
	        description: [
	            'Sets the legend\'s horizontal position anchor.',
	            'This anchor binds the `x` position to the *left*, *center*',
	            'or *right* of the legend.'
	        ].join(' ')
	    },
	    y: {
	        valType: 'number',
	        min: -2,
	        max: 3,
	        dflt: 1,
	        role: 'style',
	        description: 'Sets the y position (in normalized coordinates) of the legend.'
	    },
	    yanchor: {
	        valType: 'enumerated',
	        values: ['auto', 'top', 'middle', 'bottom'],
	        dflt: 'auto',
	        role: 'info',
	        description: [
	            'Sets the legend\'s vertical position anchor',
	            'This anchor binds the `y` position to the *top*, *middle*',
	            'or *bottom* of the legend.'
	        ].join(' ')
	    }
	};


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	
	var attributes = __webpack_require__(413);
	var helpers = __webpack_require__(415);
	
	
	module.exports = function legendDefaults(layoutIn, layoutOut, fullData) {
	    var containerIn = layoutIn.legend || {},
	        containerOut = layoutOut.legend = {};
	
	    var visibleTraces = 0,
	        defaultOrder = 'normal',
	        defaultX,
	        defaultY,
	        defaultXAnchor,
	        defaultYAnchor;
	
	    for(var i = 0; i < fullData.length; i++) {
	        var trace = fullData[i];
	
	        if(helpers.legendGetsTrace(trace)) {
	            visibleTraces++;
	            // always show the legend by default if there's a pie
	            if(Plots.traceIs(trace, 'pie')) visibleTraces++;
	        }
	
	        if((Plots.traceIs(trace, 'bar') && layoutOut.barmode==='stack') ||
	                ['tonextx','tonexty'].indexOf(trace.fill)!==-1) {
	            defaultOrder = helpers.isGrouped({traceorder: defaultOrder}) ?
	                'grouped+reversed' : 'reversed';
	        }
	
	        if(trace.legendgroup !== undefined && trace.legendgroup !== '') {
	            defaultOrder = helpers.isReversed({traceorder: defaultOrder}) ?
	                'reversed+grouped' : 'grouped';
	        }
	    }
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
	    }
	
	    var showLegend = Lib.coerce(layoutIn, layoutOut,
	        Plots.layoutAttributes, 'showlegend', visibleTraces > 1);
	
	    if(showLegend === false) return;
	
	    coerce('bgcolor', layoutOut.paper_bgcolor);
	    coerce('bordercolor');
	    coerce('borderwidth');
	    Lib.coerceFont(coerce, 'font', layoutOut.font);
	
	    coerce('orientation');
	    if(containerOut.orientation === 'h') {
	        var xaxis = layoutIn.xaxis;
	        if(xaxis && xaxis.rangeslider && xaxis.rangeslider.visible) {
	            defaultX = 0;
	            defaultXAnchor = 'left';
	            defaultY = 1.1;
	            defaultYAnchor = 'bottom';
	        }
	        else {
	            defaultX = 0;
	            defaultXAnchor = 'left';
	            defaultY = -0.1;
	            defaultYAnchor = 'top';
	        }
	    }
	
	    coerce('traceorder', defaultOrder);
	    if(helpers.isGrouped(layoutOut.legend)) coerce('tracegroupgap');
	
	    coerce('x', defaultX);
	    coerce('xanchor', defaultXAnchor);
	    coerce('y', defaultY);
	    coerce('yanchor', defaultYAnchor);
	    Lib.noneOrAll(containerIn, containerOut, ['x', 'y']);
	};


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plots = __webpack_require__(332);
	
	
	exports.legendGetsTrace = function legendGetsTrace(trace) {
	    return trace.visible && Plots.traceIs(trace, 'showLegend');
	};
	
	exports.isGrouped = function isGrouped(legendLayout) {
	    return (legendLayout.traceorder || '').indexOf('grouped') !== -1;
	};
	
	exports.isVertical = function isVertical(legendLayout) {
	    return legendLayout.orientation !== 'h';
	};
	
	exports.isReversed = function isReversed(legendLayout) {
	    return (legendLayout.traceorder || '').indexOf('reversed') !== -1;
	};


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	var dragElement = __webpack_require__(385);
	var Drawing = __webpack_require__(340);
	var Color = __webpack_require__(333);
	
	var constants = __webpack_require__(417);
	var getLegendData = __webpack_require__(418);
	var style = __webpack_require__(419);
	var helpers = __webpack_require__(415);
	var anchorUtils = __webpack_require__(374);
	
	
	module.exports = function draw(gd) {
	    var fullLayout = gd._fullLayout;
	    var clipId = 'legend' + fullLayout._uid;
	
	    if(!fullLayout._infolayer || !gd.calcdata) return;
	
	    var opts = fullLayout.legend,
	        legendData = fullLayout.showlegend && getLegendData(gd.calcdata, opts),
	        hiddenSlices = fullLayout.hiddenlabels || [];
	
	    if(!fullLayout.showlegend || !legendData.length) {
	        fullLayout._infolayer.selectAll('.legend').remove();
	        fullLayout._topdefs.select('#' + clipId).remove();
	
	        Plots.autoMargin(gd, 'legend');
	        return;
	    }
	
	    if(typeof gd.firstRender === 'undefined') gd.firstRender = true;
	    else if(gd.firstRender) gd.firstRender = false;
	
	    var legend = fullLayout._infolayer.selectAll('g.legend')
	        .data([0]);
	
	    legend.enter().append('g')
	        .attr({
	            'class': 'legend',
	            'pointer-events': 'all'
	        });
	
	    var clipPath = fullLayout._topdefs.selectAll('#' + clipId)
	        .data([0]);
	
	    clipPath.enter().append('clipPath')
	        .attr('id', clipId)
	        .append('rect');
	
	    var bg = legend.selectAll('rect.bg')
	        .data([0]);
	
	    bg.enter().append('rect')
	        .attr({
	            'class': 'bg',
	            'shape-rendering': 'crispEdges'
	        })
	        .call(Color.stroke, opts.bordercolor)
	        .call(Color.fill, opts.bgcolor)
	        .style('stroke-width', opts.borderwidth + 'px');
	
	    var scrollBox = legend.selectAll('g.scrollbox')
	        .data([0]);
	
	    scrollBox.enter().append('g')
	        .attr('class', 'scrollbox');
	
	    var scrollBar = legend.selectAll('rect.scrollbar')
	        .data([0]);
	
	    scrollBar.enter().append('rect')
	        .attr({
	            'class': 'scrollbar',
	            'rx': 20,
	            'ry': 2,
	            'width': 0,
	            'height': 0
	        })
	        .call(Color.fill, '#808BA4');
	
	    var groups = scrollBox.selectAll('g.groups')
	        .data(legendData);
	
	    groups.enter().append('g')
	        .attr('class', 'groups');
	
	    groups.exit().remove();
	
	    var traces = groups.selectAll('g.traces')
	        .data(Lib.identity);
	
	    traces.enter().append('g').attr('class', 'traces');
	    traces.exit().remove();
	
	    traces.call(style)
	        .style('opacity', function(d) {
	            var trace = d[0].trace;
	            if(Plots.traceIs(trace, 'pie')) {
	                return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;
	            } else {
	                return trace.visible === 'legendonly' ? 0.5 : 1;
	            }
	        })
	        .each(function() {
	            d3.select(this)
	                .call(drawTexts, gd)
	                .call(setupTraceToggle, gd);
	        });
	
	    if(gd.firstRender) {
	        computeLegendDimensions(gd, groups, traces);
	        expandMargin(gd);
	    }
	
	    // Position and size the legend
	    var lxMin = 0,
	        lxMax = fullLayout.width,
	        lyMin = 0,
	        lyMax = fullLayout.height;
	
	    computeLegendDimensions(gd, groups, traces);
	
	    if(opts.height > lyMax) {
	        // If the legend doesn't fit in the plot area,
	        // do not expand the vertical margins.
	        expandHorizontalMargin(gd);
	    } else {
	        expandMargin(gd);
	    }
	
	    // Scroll section must be executed after repositionLegend.
	    // It requires the legend width, height, x and y to position the scrollbox
	    // and these values are mutated in repositionLegend.
	    var gs = fullLayout._size,
	        lx = gs.l + gs.w * opts.x,
	        ly = gs.t + gs.h * (1-opts.y);
	
	    if(anchorUtils.isRightAnchor(opts)) {
	        lx -= opts.width;
	    }
	    else if(anchorUtils.isCenterAnchor(opts)) {
	        lx -= opts.width / 2;
	    }
	
	    if(anchorUtils.isBottomAnchor(opts)) {
	        ly -= opts.height;
	    }
	    else if(anchorUtils.isMiddleAnchor(opts)) {
	        ly -= opts.height / 2;
	    }
	
	    // Make sure the legend left and right sides are visible
	    var legendWidth = opts.width,
	        legendWidthMax = gs.w;
	
	    if(legendWidth > legendWidthMax) {
	        lx = gs.l;
	        legendWidth = legendWidthMax;
	    }
	    else {
	        if(lx + legendWidth > lxMax) lx = lxMax - legendWidth;
	        if(lx < lxMin) lx = lxMin;
	        legendWidth = Math.min(lxMax - lx, opts.width);
	    }
	
	    // Make sure the legend top and bottom are visible
	    // (legends with a scroll bar are not allowed to stretch beyond the extended
	    // margins)
	    var legendHeight = opts.height,
	        legendHeightMax = gs.h;
	
	    if(legendHeight > legendHeightMax) {
	        ly = gs.t;
	        legendHeight = legendHeightMax;
	    }
	    else {
	        if(ly + legendHeight > lyMax) ly = lyMax - legendHeight;
	        if(ly < lyMin) ly = lyMin;
	        legendHeight = Math.min(lyMax - ly, opts.height);
	    }
	
	    // Set size and position of all the elements that make up a legend:
	    // legend, background and border, scroll box and scroll bar
	    Lib.setTranslate(legend, lx, ly);
	
	    bg.attr({
	        width: legendWidth - opts.borderwidth,
	        height: legendHeight - opts.borderwidth,
	        x: opts.borderwidth / 2,
	        y: opts.borderwidth / 2
	    });
	
	    var scrollPosition = scrollBox.attr('data-scroll') || 0;
	
	    Lib.setTranslate(scrollBox, 0, scrollPosition);
	
	    clipPath.select('rect').attr({
	        width: legendWidth - 2 * opts.borderwidth,
	        height: legendHeight - 2 * opts.borderwidth,
	        x: opts.borderwidth - scrollPosition,
	        y: opts.borderwidth
	    });
	
	    scrollBox.call(Drawing.setClipUrl, clipId);
	
	    // If scrollbar should be shown.
	    if(opts.height - legendHeight > 0 && !gd._context.staticPlot) {
	
	        // increase the background and clip-path width
	        // by the scrollbar width and margin
	        bg.attr({
	            width: legendWidth -
	                2 * opts.borderwidth +
	                constants.scrollBarWidth +
	                constants.scrollBarMargin
	        });
	
	        clipPath.select('rect').attr({
	            width: legendWidth -
	                2 * opts.borderwidth +
	                constants.scrollBarWidth +
	                constants.scrollBarMargin
	        });
	
	        if(gd.firstRender) {
	            // Move scrollbar to starting position
	            scrollHandler(constants.scrollBarMargin, 0);
	        }
	
	        var scrollBarYMax = legendHeight -
	                constants.scrollBarHeight -
	                2 * constants.scrollBarMargin,
	            scrollBoxYMax = opts.height - legendHeight,
	            scrollBarY = constants.scrollBarMargin,
	            scrollBoxY = 0;
	
	        scrollHandler(scrollBarY, scrollBoxY);
	
	        legend.on('wheel',null);
	        legend.on('wheel', function() {
	            scrollBoxY = Lib.constrain(
	                scrollBox.attr('data-scroll') -
	                    d3.event.deltaY / scrollBarYMax * scrollBoxYMax,
	                -scrollBoxYMax, 0);
	            scrollBarY = constants.scrollBarMargin -
	                scrollBoxY / scrollBoxYMax * scrollBarYMax;
	            scrollHandler(scrollBarY, scrollBoxY);
	            d3.event.preventDefault();
	        });
	
	        scrollBar.on('.drag',null);
	        scrollBox.on('.drag',null);
	        var drag = d3.behavior.drag().on('drag', function() {
	            scrollBarY = Lib.constrain(
	                d3.event.y - constants.scrollBarHeight / 2,
	                constants.scrollBarMargin,
	                constants.scrollBarMargin + scrollBarYMax);
	            scrollBoxY = - (scrollBarY - constants.scrollBarMargin) /
	                scrollBarYMax * scrollBoxYMax;
	            scrollHandler(scrollBarY, scrollBoxY);
	        });
	
	        scrollBar.call(drag);
	        scrollBox.call(drag);
	
	    }
	
	
	    function scrollHandler(scrollBarY, scrollBoxY) {
	        scrollBox
	            .attr('data-scroll', scrollBoxY)
	            .call(Lib.setTranslate, 0, scrollBoxY);
	
	        scrollBar.call(
	            Drawing.setRect,
	            legendWidth,
	            scrollBarY,
	            constants.scrollBarWidth,
	            constants.scrollBarHeight
	        );
	        clipPath.select('rect').attr({
	            y: opts.borderwidth - scrollBoxY
	        });
	    }
	
	    if(gd._context.editable) {
	        var xf, yf, x0, y0;
	
	        legend.classed('cursor-move', true);
	
	        dragElement.init({
	            element: legend.node(),
	            prepFn: function() {
	                var transform = Lib.getTranslate(legend);
	
	                x0 = transform.x;
	                y0 = transform.y;
	            },
	            moveFn: function(dx, dy) {
	                var newX = x0 + dx,
	                    newY = y0 + dy;
	
	                Lib.setTranslate(legend, newX, newY);
	
	                xf = dragElement.align(newX, 0, gs.l, gs.l+gs.w, opts.xanchor);
	                yf = dragElement.align(newY, 0, gs.t+gs.h, gs.t, opts.yanchor);
	            },
	            doneFn: function(dragged) {
	                if(dragged && xf !== undefined && yf !== undefined) {
	                    Plotly.relayout(gd, {'legend.x': xf, 'legend.y': yf});
	                }
	            }
	        });
	    }
	};
	
	function drawTexts(g, gd) {
	    var legendItem = g.data()[0][0],
	        fullLayout = gd._fullLayout,
	        trace = legendItem.trace,
	        isPie = Plots.traceIs(trace, 'pie'),
	        traceIndex = trace.index,
	        name = isPie ? legendItem.label : trace.name;
	
	    var text = g.selectAll('text.legendtext')
	        .data([0]);
	    text.enter().append('text').classed('legendtext', true);
	    text.attr({
	        x: 40,
	        y: 0,
	        'data-unformatted': name
	    })
	    .style('text-anchor', 'start')
	    .classed('user-select-none', true)
	    .call(Drawing.font, fullLayout.legend.font)
	    .text(name);
	
	    function textLayout(s) {
	        Plotly.util.convertToTspans(s, function() {
	            s.selectAll('tspan.line').attr({x: s.attr('x')});
	            g.call(computeTextDimensions, gd);
	        });
	    }
	
	    if(gd._context.editable && !isPie) {
	        text.call(Plotly.util.makeEditable)
	            .call(textLayout)
	            .on('edit', function(text) {
	                this.attr({'data-unformatted': text});
	                this.text(text)
	                    .call(textLayout);
	                if(!this.text()) text = ' \u0020\u0020 ';
	                Plotly.restyle(gd, 'name', text, traceIndex);
	            });
	    }
	    else text.call(textLayout);
	}
	
	function setupTraceToggle(g, gd) {
	    var hiddenSlices = gd._fullLayout.hiddenlabels ?
	        gd._fullLayout.hiddenlabels.slice() :
	        [];
	
	    var traceToggle = g.selectAll('rect')
	        .data([0]);
	
	    traceToggle.enter().append('rect')
	        .classed('legendtoggle', true)
	        .style('cursor', 'pointer')
	        .attr('pointer-events', 'all')
	        .call(Color.fill, 'rgba(0,0,0,0)');
	
	    traceToggle.on('click', function() {
	        if(gd._dragged) return;
	
	        var legendItem = g.data()[0][0],
	            fullData = gd._fullData,
	            trace = legendItem.trace,
	            legendgroup = trace.legendgroup,
	            traceIndicesInGroup = [],
	            tracei,
	            newVisible;
	
	        if(Plots.traceIs(trace, 'pie')) {
	            var thisLabel = legendItem.label,
	                thisLabelIndex = hiddenSlices.indexOf(thisLabel);
	
	            if(thisLabelIndex === -1) hiddenSlices.push(thisLabel);
	            else hiddenSlices.splice(thisLabelIndex, 1);
	
	            Plotly.relayout(gd, 'hiddenlabels', hiddenSlices);
	        } else {
	            if(legendgroup === '') {
	                traceIndicesInGroup = [trace.index];
	            } else {
	                for(var i = 0; i < fullData.length; i++) {
	                    tracei = fullData[i];
	                    if(tracei.legendgroup === legendgroup) {
	                        traceIndicesInGroup.push(tracei.index);
	                    }
	                }
	            }
	
	            newVisible = trace.visible === true ? 'legendonly' : true;
	            Plotly.restyle(gd, 'visible', newVisible, traceIndicesInGroup);
	        }
	    });
	}
	
	function computeTextDimensions(g, gd) {
	    var legendItem = g.data()[0][0],
	        bg = g.selectAll('.legendtoggle'),
	        mathjaxGroup = g.select('g[class*=math-group]'),
	        opts = gd._fullLayout.legend,
	        lineHeight = opts.font.size * 1.3,
	        height,
	        width;
	
	    if(!legendItem.trace.showlegend) {
	        g.remove();
	        return;
	    }
	
	    if(mathjaxGroup.node()) {
	        var mathjaxBB = Drawing.bBox(mathjaxGroup.node());
	
	        height = mathjaxBB.height;
	        width = mathjaxBB.width;
	
	        Lib.setTranslate(mathjaxGroup, 0, (height / 4));
	    }
	    else {
	        var text = g.selectAll('.legendtext'),
	            textSpans = g.selectAll('.legendtext>tspan'),
	            textLines = textSpans[0].length || 1;
	
	        height = lineHeight * textLines;
	        width = text.node() && Drawing.bBox(text.node()).width;
	
	        // approximation to height offset to center the font
	        // to avoid getBoundingClientRect
	        var textY = lineHeight * (0.3 + (1 - textLines) / 2);
	        text.attr('y', textY);
	        textSpans.attr('y', textY);
	    }
	
	    height = Math.max(height, 16) + 3;
	
	    bg.attr({x: 0, y: -height / 2, height: height});
	
	    legendItem.height = height;
	    legendItem.width = width;
	}
	
	function computeLegendDimensions(gd, groups, traces) {
	    var fullLayout = gd._fullLayout,
	        opts = fullLayout.legend,
	        borderwidth = opts.borderwidth,
	        isGrouped = helpers.isGrouped(opts);
	
	    if(helpers.isVertical(opts)) {
	        if(isGrouped) {
	            groups.each(function(d, i) {
	                Lib.setTranslate(this, 0, i * opts.tracegroupgap);
	            });
	        }
	
	        opts.width = 0;
	        opts.height = 0;
	
	        traces.each(function(d) {
	            var legendItem = d[0],
	                textHeight = legendItem.height,
	                textWidth = legendItem.width;
	
	            Lib.setTranslate(this,
	                borderwidth,
	                (5 + borderwidth + opts.height + textHeight / 2));
	
	            opts.height += textHeight;
	            opts.width = Math.max(opts.width, textWidth);
	        });
	
	        opts.width += 45 + borderwidth * 2;
	        opts.height += 10 + borderwidth * 2;
	
	        if(isGrouped) {
	            opts.height += (opts._lgroupsLength-1) * opts.tracegroupgap;
	        }
	
	        traces.selectAll('.legendtoggle')
	            .attr('width', (gd._context.editable ? 0 : opts.width) + 40);
	
	        // make sure we're only getting full pixels
	        opts.width = Math.ceil(opts.width);
	        opts.height = Math.ceil(opts.height);
	    }
	    else if(isGrouped) {
	        opts.width = 0;
	        opts.height = 0;
	
	        var groupXOffsets = [opts.width],
	            groupData = groups.data();
	
	        for(var i = 0, n = groupData.length; i < n; i++) {
	            var textWidths = groupData[i].map(function(legendItemArray) {
	                return legendItemArray[0].width;
	            });
	
	            var groupWidth = 40 + Math.max.apply(null, textWidths);
	
	            opts.width += opts.tracegroupgap + groupWidth;
	
	            groupXOffsets.push(opts.width);
	        }
	
	        groups.each(function(d, i) {
	            Lib.setTranslate(this, groupXOffsets[i], 0);
	        });
	
	        groups.each(function() {
	            var group = d3.select(this),
	                groupTraces = group.selectAll('g.traces'),
	                groupHeight = 0;
	
	            groupTraces.each(function(d) {
	                var legendItem = d[0],
	                    textHeight = legendItem.height;
	
	                Lib.setTranslate(this,
	                    0,
	                    (5 + borderwidth + groupHeight + textHeight / 2));
	
	                groupHeight += textHeight;
	            });
	
	            opts.height = Math.max(opts.height, groupHeight);
	        });
	
	        opts.height += 10 + borderwidth * 2;
	        opts.width += borderwidth * 2;
	
	        // make sure we're only getting full pixels
	        opts.width = Math.ceil(opts.width);
	        opts.height = Math.ceil(opts.height);
	
	        traces.selectAll('.legendtoggle')
	            .attr('width', (gd._context.editable ? 0 : opts.width));
	    }
	    else {
	        opts.width = 0;
	        opts.height = 0;
	
	        traces.each(function(d) {
	            var legendItem = d[0],
	                traceWidth = 40 + legendItem.width,
	                traceGap = opts.tracegroupgap || 5;
	
	            Lib.setTranslate(this,
	                (borderwidth + opts.width),
	                (5 + borderwidth + legendItem.height / 2));
	
	            opts.width += traceGap + traceWidth;
	            opts.height = Math.max(opts.height, legendItem.height);
	        });
	
	        opts.width += borderwidth * 2;
	        opts.height += 10 + borderwidth * 2;
	
	        // make sure we're only getting full pixels
	        opts.width = Math.ceil(opts.width);
	        opts.height = Math.ceil(opts.height);
	
	        traces.selectAll('.legendtoggle')
	            .attr('width', (gd._context.editable ? 0 : opts.width));
	    }
	}
	
	function expandMargin(gd) {
	    var fullLayout = gd._fullLayout,
	        opts = fullLayout.legend;
	
	    var xanchor = 'left';
	    if(anchorUtils.isRightAnchor(opts)) {
	        xanchor = 'right';
	    }
	    else if(anchorUtils.isCenterAnchor(opts)) {
	        xanchor = 'center';
	    }
	
	    var yanchor = 'top';
	    if(anchorUtils.isBottomAnchor(opts)) {
	        yanchor = 'bottom';
	    }
	    else if(anchorUtils.isMiddleAnchor(opts)) {
	        yanchor = 'middle';
	    }
	
	    // lastly check if the margin auto-expand has changed
	    Plots.autoMargin(gd, 'legend', {
	        x: opts.x,
	        y: opts.y,
	        l: opts.width * ({right: 1, center: 0.5}[xanchor] || 0),
	        r: opts.width * ({left: 1, center: 0.5}[xanchor] || 0),
	        b: opts.height * ({top: 1, middle: 0.5}[yanchor] || 0),
	        t: opts.height * ({bottom: 1, middle: 0.5}[yanchor] || 0)
	    });
	}
	
	function expandHorizontalMargin(gd) {
	    var fullLayout = gd._fullLayout,
	        opts = fullLayout.legend;
	
	    var xanchor = 'left';
	    if(anchorUtils.isRightAnchor(opts)) {
	        xanchor = 'right';
	    }
	    else if(anchorUtils.isCenterAnchor(opts)) {
	        xanchor = 'center';
	    }
	
	    // lastly check if the margin auto-expand has changed
	    Plots.autoMargin(gd, 'legend', {
	        x: opts.x,
	        y: 0.5,
	        l: opts.width * ({right: 1, center: 0.5}[xanchor] || 0),
	        r: opts.width * ({left: 1, center: 0.5}[xanchor] || 0),
	        b: 0,
	        t: 0
	    });
	}


/***/ },
/* 417 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	module.exports = {
	    scrollBarWidth: 4,
	    scrollBarHeight: 20,
	    scrollBarColor: '#808BA4',
	    scrollBarMargin: 4
	};


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plots = __webpack_require__(332);
	
	var helpers = __webpack_require__(415);
	
	
	module.exports = function getLegendData(calcdata, opts) {
	    var lgroupToTraces = {},
	        lgroups = [],
	        hasOneNonBlankGroup = false,
	        slicesShown = {},
	        lgroupi = 0;
	
	    var i, j;
	
	    function addOneItem(legendGroup, legendItem) {
	        // each '' legend group is treated as a separate group
	        if(legendGroup === '' || !helpers.isGrouped(opts)) {
	            var uniqueGroup = '~~i' + lgroupi; // TODO: check this against fullData legendgroups?
	
	            lgroups.push(uniqueGroup);
	            lgroupToTraces[uniqueGroup] = [[legendItem]];
	            lgroupi++;
	        }
	        else if(lgroups.indexOf(legendGroup) === -1) {
	            lgroups.push(legendGroup);
	            hasOneNonBlankGroup = true;
	            lgroupToTraces[legendGroup] = [[legendItem]];
	        }
	        else lgroupToTraces[legendGroup].push([legendItem]);
	    }
	
	    // build an { legendgroup: [cd0, cd0], ... } object
	    for(i = 0; i < calcdata.length; i++) {
	        var cd = calcdata[i],
	            cd0 = cd[0],
	            trace = cd0.trace,
	            lgroup = trace.legendgroup;
	
	        if(!helpers.legendGetsTrace(trace) || !trace.showlegend) continue;
	
	        if(Plots.traceIs(trace, 'pie')) {
	            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};
	
	            for(j = 0; j < cd.length; j++) {
	                var labelj = cd[j].label;
	
	                if(!slicesShown[lgroup][labelj]) {
	                    addOneItem(lgroup, {
	                        label: labelj,
	                        color: cd[j].color,
	                        i: cd[j].i,
	                        trace: trace
	                    });
	
	                    slicesShown[lgroup][labelj] = true;
	                }
	            }
	        }
	
	        else addOneItem(lgroup, cd0);
	    }
	
	    // won't draw a legend in this case
	    if(!lgroups.length) return [];
	
	    // rearrange lgroupToTraces into a d3-friendly array of arrays
	    var lgroupsLength = lgroups.length,
	        ltraces,
	        legendData;
	
	    if(hasOneNonBlankGroup && helpers.isGrouped(opts)) {
	        legendData = new Array(lgroupsLength);
	
	        for(i = 0; i < lgroupsLength; i++) {
	            ltraces = lgroupToTraces[lgroups[i]];
	            legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;
	        }
	    }
	    else {
	        // collapse all groups into one if all groups are blank
	        legendData = [new Array(lgroupsLength)];
	
	        for(i = 0; i < lgroupsLength; i++) {
	            ltraces = lgroupToTraces[lgroups[i]][0];
	            legendData[0][helpers.isReversed(opts) ? lgroupsLength-i-1 : i] = ltraces;
	        }
	        lgroupsLength = 1;
	    }
	
	    // needed in repositionLegend
	    opts._lgroupsLength = lgroupsLength;
	    return legendData;
	};


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	var Drawing = __webpack_require__(340);
	var Color = __webpack_require__(333);
	
	var subTypes = __webpack_require__(360);
	var stylePie = __webpack_require__(420);
	
	
	module.exports = function style(s) {
	    s.each(function(d) {
	        var traceGroup = d3.select(this);
	
	        var fill = traceGroup
	            .selectAll('g.legendfill')
	                .data([d]);
	        fill.enter().append('g')
	            .classed('legendfill', true);
	
	        var line = traceGroup
	            .selectAll('g.legendlines')
	                .data([d]);
	        line.enter().append('g')
	            .classed('legendlines', true);
	
	        var symbol = traceGroup
	            .selectAll('g.legendsymbols')
	                .data([d]);
	        symbol.enter().append('g')
	            .classed('legendsymbols', true);
	        symbol.style('opacity', d[0].trace.opacity);
	
	        symbol.selectAll('g.legendpoints')
	            .data([d])
	          .enter().append('g')
	            .classed('legendpoints', true);
	    })
	    .each(styleBars)
	    .each(styleBoxes)
	    .each(stylePies)
	    .each(styleLines)
	    .each(stylePoints);
	};
	
	function styleLines(d) {
	    var trace = d[0].trace,
	        showFill = trace.visible && trace.fill && trace.fill!=='none',
	        showLine = subTypes.hasLines(trace);
	
	    var fill = d3.select(this).select('.legendfill').selectAll('path')
	        .data(showFill ? [d] : []);
	    fill.enter().append('path').classed('js-fill', true);
	    fill.exit().remove();
	    fill.attr('d', 'M5,0h30v6h-30z')
	        .call(Drawing.fillGroupStyle);
	
	    var line = d3.select(this).select('.legendlines').selectAll('path')
	        .data(showLine ? [d] : []);
	    line.enter().append('path').classed('js-line', true)
	        .attr('d', 'M5,0h30');
	    line.exit().remove();
	    line.call(Drawing.lineGroupStyle);
	}
	
	function stylePoints(d) {
	    var d0 = d[0],
	        trace = d0.trace,
	        showMarkers = subTypes.hasMarkers(trace),
	        showText = subTypes.hasText(trace),
	        showLines = subTypes.hasLines(trace);
	
	    var dMod, tMod;
	
	    // 'scatter3d' and 'scattergeo' don't use gd.calcdata yet;
	    // use d0.trace to infer arrayOk attributes
	
	    function boundVal(attrIn, arrayToValFn, bounds) {
	        var valIn = Lib.nestedProperty(trace, attrIn).get(),
	            valToBound = (Array.isArray(valIn) && arrayToValFn) ?
	                arrayToValFn(valIn) : valIn;
	
	        if(bounds) {
	            if(valToBound < bounds[0]) return bounds[0];
	            else if(valToBound > bounds[1]) return bounds[1];
	        }
	        return valToBound;
	    }
	
	    function pickFirst(array) { return array[0]; }
	
	    // constrain text, markers, etc so they'll fit on the legend
	    if(showMarkers || showText || showLines) {
	        var dEdit = {},
	            tEdit = {};
	
	        if(showMarkers) {
	            dEdit.mc = boundVal('marker.color', pickFirst);
	            dEdit.mo = boundVal('marker.opacity', Lib.mean, [0.2, 1]);
	            dEdit.ms = boundVal('marker.size', Lib.mean, [2, 16]);
	            dEdit.mlc = boundVal('marker.line.color', pickFirst);
	            dEdit.mlw = boundVal('marker.line.width', Lib.mean, [0, 5]);
	            tEdit.marker = {
	                sizeref: 1,
	                sizemin: 1,
	                sizemode: 'diameter'
	            };
	        }
	
	        if(showLines) {
	            tEdit.line = {
	                width: boundVal('line.width', pickFirst, [0, 10])
	            };
	        }
	
	        if(showText) {
	            dEdit.tx = 'Aa';
	            dEdit.tp = boundVal('textposition', pickFirst);
	            dEdit.ts = 10;
	            dEdit.tc = boundVal('textfont.color', pickFirst);
	            dEdit.tf = boundVal('textfont.family', pickFirst);
	        }
	
	        dMod = [Lib.minExtend(d0, dEdit)];
	        tMod = Lib.minExtend(trace, tEdit);
	    }
	
	    var ptgroup = d3.select(this).select('g.legendpoints');
	
	    var pts = ptgroup.selectAll('path.scatterpts')
	        .data(showMarkers ? dMod : []);
	    pts.enter().append('path').classed('scatterpts', true)
	        .attr('transform', 'translate(20,0)');
	    pts.exit().remove();
	    pts.call(Drawing.pointStyle, tMod);
	
	    // 'mrc' is set in pointStyle and used in textPointStyle:
	    // constrain it here
	    if(showMarkers) dMod[0].mrc = 3;
	
	    var txt = ptgroup.selectAll('g.pointtext')
	        .data(showText ? dMod : []);
	    txt.enter()
	        .append('g').classed('pointtext',true)
	            .append('text').attr('transform', 'translate(20,0)');
	    txt.exit().remove();
	    txt.selectAll('text').call(Drawing.textPointStyle, tMod);
	}
	
	function styleBars(d) {
	    var trace = d[0].trace,
	        marker = trace.marker || {},
	        markerLine = marker.line || {},
	        barpath = d3.select(this).select('g.legendpoints')
	            .selectAll('path.legendbar')
	            .data(Plots.traceIs(trace, 'bar') ? [d] : []);
	    barpath.enter().append('path').classed('legendbar', true)
	        .attr('d','M6,6H-6V-6H6Z')
	        .attr('transform', 'translate(20,0)');
	    barpath.exit().remove();
	    barpath.each(function(d) {
	        var w = (d.mlw + 1 || markerLine.width + 1) - 1,
	            p = d3.select(this);
	
	        p.style('stroke-width',w+'px')
	            .call(Color.fill, d.mc || marker.color);
	
	        if(w) {
	            p.call(Color.stroke, d.mlc || markerLine.color);
	        }
	    });
	}
	
	function styleBoxes(d) {
	    var trace = d[0].trace,
	        pts = d3.select(this).select('g.legendpoints')
	            .selectAll('path.legendbox')
	            .data(Plots.traceIs(trace, 'box') && trace.visible ? [d] : []);
	    pts.enter().append('path').classed('legendbox', true)
	        // if we want the median bar, prepend M6,0H-6
	        .attr('d', 'M6,6H-6V-6H6Z')
	        .attr('transform', 'translate(20,0)');
	    pts.exit().remove();
	    pts.each(function(d) {
	        var w = (d.lw + 1 || trace.line.width + 1) - 1,
	            p = d3.select(this);
	
	        p.style('stroke-width', w+'px')
	            .call(Color.fill, d.fc || trace.fillcolor);
	
	        if(w) {
	            p.call(Color.stroke, d.lc || trace.line.color);
	        }
	    });
	}
	
	function stylePies(d) {
	    var trace = d[0].trace,
	        pts = d3.select(this).select('g.legendpoints')
	            .selectAll('path.legendpie')
	            .data(Plots.traceIs(trace, 'pie') && trace.visible ? [d] : []);
	    pts.enter().append('path').classed('legendpie', true)
	        .attr('d', 'M6,6H-6V-6H6Z')
	        .attr('transform', 'translate(20,0)');
	    pts.exit().remove();
	
	    if(pts.size()) pts.call(stylePie, d[0], trace);
	}


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Color = __webpack_require__(333);
	
	module.exports = function styleOne(s, pt, trace) {
	    var lineColor = trace.marker.line.color;
	    if(Array.isArray(lineColor)) lineColor = lineColor[pt.i] || Color.defaultLine;
	
	    var lineWidth = trace.marker.line.width || 0;
	    if(Array.isArray(lineWidth)) lineWidth = lineWidth[pt.i] || 0;
	
	    s.style({
	        'stroke-width': lineWidth,
	        fill: pt.color
	    })
	    .call(Color.stroke, lineColor);
	};


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	var draw = __webpack_require__(422);
	var supplyLayoutDefaults = __webpack_require__(423);
	var attributes = __webpack_require__(424);
	
	
	module.exports = {
	    draw: draw,
	    layoutAttributes: attributes,
	    supplyLayoutDefaults: supplyLayoutDefaults
	};


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var Drawing = __webpack_require__(340);
	var Axes = __webpack_require__(338);
	
	module.exports = function draw(gd) {
	
	    var fullLayout = gd._fullLayout,
	        imageDataAbove = [],
	        imageDataSubplot = [],
	        imageDataBelow = [];
	
	    if(!fullLayout.images) return;
	
	
	    // Sort into top, subplot, and bottom layers
	    for(var i = 0; i < fullLayout.images.length; i++) {
	        var img = fullLayout.images[i];
	
	        if(img.layer === 'below' && img.xref !== 'paper' && img.yref !== 'paper') {
	            imageDataSubplot.push(img);
	        } else if(img.layer === 'above') {
	            imageDataAbove.push(img);
	        } else {
	            imageDataBelow.push(img);
	        }
	    }
	
	
	    var anchors = {
	        x: {
	            left: { sizing: 'xMin', offset: 0 },
	            center: { sizing: 'xMid', offset: -1 / 2 },
	            right: { sizing: 'xMax', offset: -1 }
	        },
	        y: {
	            top: { sizing: 'YMin', offset: 0 },
	            middle: { sizing: 'YMid', offset: -1 / 2 },
	            bottom: { sizing: 'YMax', offset: -1 }
	        }
	    };
	
	
	    // Images must be converted to dataURL's for exporting.
	    function setImage(d) {
	
	        var thisImage = d3.select(this);
	
	        var imagePromise = new Promise(function(resolve) {
	
	            var img = new Image();
	
	            // If not set, a `tainted canvas` error is thrown
	            img.setAttribute('crossOrigin', 'anonymous');
	            img.onerror = errorHandler;
	            img.onload = function() {
	
	                var canvas = document.createElement('canvas');
	                canvas.width = this.width;
	                canvas.height = this.height;
	
	                var ctx = canvas.getContext('2d');
	                ctx.drawImage(this, 0, 0);
	
	                var dataURL = canvas.toDataURL('image/png');
	
	                thisImage.attr('xlink:href', dataURL);
	            };
	
	
	            thisImage.on('error', errorHandler);
	            thisImage.on('load', resolve);
	
	            img.src = d.source;
	
	            function errorHandler() {
	                thisImage.remove();
	                resolve();
	            }
	        });
	
	        gd._promises.push(imagePromise);
	    }
	
	    function applyAttributes(d) {
	
	        var thisImage = d3.select(this);
	
	        // Axes if specified
	        var xref = Axes.getFromId(gd, d.xref),
	            yref = Axes.getFromId(gd, d.yref);
	
	        var size = fullLayout._size,
	            width = xref ? Math.abs(xref.l2p(d.sizex) - xref.l2p(0)) : d.sizex * size.w,
	            height = yref ? Math.abs(yref.l2p(d.sizey) - yref.l2p(0)) : d.sizey * size.h;
	
	        // Offsets for anchor positioning
	        var xOffset = width * anchors.x[d.xanchor].offset + size.l,
	            yOffset = height * anchors.y[d.yanchor].offset + size.t;
	
	        var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;
	
	        // Final positions
	        var xPos = (xref ? xref.l2p(d.x) : d.x * size.w) + xOffset,
	            yPos = (yref ? yref.l2p(d.y) : size.h - d.y * size.h) + yOffset;
	
	
	        // Construct the proper aspectRatio attribute
	        switch(d.sizing) {
	            case 'fill':
	                sizing += ' slice';
	                break;
	
	            case 'stretch':
	                sizing = 'none';
	                break;
	        }
	
	        thisImage.attr({
	            x: xPos,
	            y: yPos,
	            width: width,
	            height: height,
	            preserveAspectRatio: sizing,
	            opacity: d.opacity
	        });
	
	
	        // Set proper clipping on images
	        var xId = xref ? xref._id : '',
	            yId = yref ? yref._id : '',
	            clipAxes = xId + yId;
	
	        thisImage.call(Drawing.setClipUrl, 'clip' + fullLayout._uid + clipAxes);
	    }
	
	
	    // Required for updating images
	    function keyFunction(d) {
	        return d.source;
	    }
	
	
	    var imagesBelow = fullLayout._imageLowerLayer.selectAll('image')
	            .data(imageDataBelow, keyFunction),
	        imagesSubplot = fullLayout._imageSubplotLayer.selectAll('image')
	            .data(imageDataSubplot, keyFunction),
	        imagesAbove = fullLayout._imageUpperLayer.selectAll('image')
	            .data(imageDataAbove, keyFunction);
	
	    imagesBelow.enter().append('image').each(setImage);
	    imagesSubplot.enter().append('image').each(setImage);
	    imagesAbove.enter().append('image').each(setImage);
	
	    imagesBelow.exit().remove();
	    imagesSubplot.exit().remove();
	    imagesAbove.exit().remove();
	
	    imagesBelow.each(applyAttributes);
	    imagesSubplot.each(applyAttributes);
	    imagesAbove.each(applyAttributes);
	};


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Axes = __webpack_require__(338);
	var Lib = __webpack_require__(309);
	var attributes = __webpack_require__(424);
	
	
	module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
	
	    if(!layoutIn.images || !Array.isArray(layoutIn.images)) return;
	
	
	    var containerIn = layoutIn.images,
	        containerOut = layoutOut.images = [];
	
	
	    for(var i = 0; i < containerIn.length; i++) {
	        var image = containerIn[i];
	
	        if(!image.source) continue;
	
	        var defaulted = imageDefaults(containerIn[i] || {}, containerOut[i] || {}, layoutOut);
	        containerOut.push(defaulted);
	    }
	};
	
	
	function imageDefaults(imageIn, imageOut, fullLayout) {
	
	    imageOut = imageOut || {};
	
	    function coerce(attr, dflt) {
	        return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
	    }
	
	    coerce('source');
	    coerce('layer');
	    coerce('x');
	    coerce('y');
	    coerce('xanchor');
	    coerce('yanchor');
	    coerce('sizex');
	    coerce('sizey');
	    coerce('sizing');
	    coerce('opacity');
	
	    for(var i = 0; i < 2; i++) {
	        var tdMock = { _fullLayout: fullLayout },
	            axLetter = ['x', 'y'][i];
	
	        // 'paper' is the fallback axref
	        Axes.coerceRef(imageIn, imageOut, tdMock, axLetter, 'paper');
	    }
	
	    return imageOut;
	}


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var cartesianConstants = __webpack_require__(352);
	
	
	module.exports = {
	    _isLinkedToArray: true,
	
	    source: {
	        valType: 'string',
	        role: 'info',
	        description: [
	            'Specifies the URL of the image to be used.',
	            'The URL must be accessible from the domain where the',
	            'plot code is run, and can be either relative or absolute.'
	
	        ].join(' ')
	    },
	
	    layer: {
	        valType: 'enumerated',
	        values: ['below', 'above'],
	        dflt: 'above',
	        role: 'info',
	        description: [
	            'Specifies whether images are drawn below or above traces.',
	            'When `xref` and `yref` are both set to `paper`,',
	            'image is drawn below the entire plot area.'
	        ].join(' ')
	    },
	
	    sizex: {
	        valType: 'number',
	        role: 'info',
	        dflt: 0,
	        description: [
	            'Sets the image container size horizontally.',
	            'The image will be sized based on the `position` value.',
	            'When `xref` is set to `paper`, units are sized relative',
	            'to the plot width.'
	        ].join(' ')
	    },
	
	    sizey: {
	        valType: 'number',
	        role: 'info',
	        dflt: 0,
	        description: [
	            'Sets the image container size vertically.',
	            'The image will be sized based on the `position` value.',
	            'When `yref` is set to `paper`, units are sized relative',
	            'to the plot height.'
	        ].join(' ')
	    },
	
	    sizing: {
	        valType: 'enumerated',
	        values: ['fill', 'contain', 'stretch'],
	        dflt: 'contain',
	        role: 'info',
	        description: [
	            'Specifies which dimension of the image to constrain.'
	        ].join(' ')
	    },
	
	    opacity: {
	        valType: 'number',
	        role: 'info',
	        min: 0,
	        max: 1,
	        dflt: 1,
	        description: 'Sets the opacity of the image.'
	    },
	
	    x: {
	        valType: 'number',
	        role: 'info',
	        dflt: 0,
	        description: [
	            'Sets the image\'s x position.',
	            'When `xref` is set to `paper`, units are sized relative',
	            'to the plot height.',
	            'See `xref` for more info'
	        ].join(' ')
	    },
	
	    y: {
	        valType: 'number',
	        role: 'info',
	        dflt: 0,
	        description: [
	            'Sets the image\'s y position.',
	            'When `yref` is set to `paper`, units are sized relative',
	            'to the plot height.',
	            'See `yref` for more info'
	        ].join(' ')
	    },
	
	    xanchor: {
	        valType: 'enumerated',
	        values: ['left', 'center', 'right'],
	        dflt: 'left',
	        role: 'info',
	        description: 'Sets the anchor for the x position'
	    },
	
	    yanchor: {
	        valType: 'enumerated',
	        values: ['top', 'middle', 'bottom'],
	        dflt: 'top',
	        role: 'info',
	        description: 'Sets the anchor for the y position.'
	    },
	
	    xref: {
	        valType: 'enumerated',
	        values: [
	            'paper',
	            cartesianConstants.idRegex.x.toString()
	        ],
	        dflt: 'paper',
	        role: 'info',
	        description: [
	            'Sets the images\'s x coordinate axis.',
	            'If set to a x axis id (e.g. *x* or *x2*), the `x` position',
	            'refers to an x data coordinate',
	            'If set to *paper*, the `x` position refers to the distance from',
	            'the left of plot in normalized coordinates',
	            'where *0* (*1*) corresponds to the left (right).'
	        ].join(' ')
	    },
	
	    yref: {
	        valType: 'enumerated',
	        values: [
	            'paper',
	            cartesianConstants.idRegex.y.toString()
	        ],
	        dflt: 'paper',
	        role: 'info',
	        description: [
	            'Sets the images\'s y coordinate axis.',
	            'If set to a y axis id (e.g. *y* or *y2*), the `y` position',
	            'refers to a y data coordinate.',
	            'If set to *paper*, the `y` position refers to the distance from',
	            'the bottom of the plot in normalized coordinates',
	            'where *0* (*1*) corresponds to the bottom (top).'
	        ].join(' ')
	    }
	};


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Lib = __webpack_require__(309);
	var Icons = __webpack_require__(426);
	
	
	/**
	 * UI controller for interactive plots
	 * @Class
	 * @Param {object} opts
	 * @Param {object} opts.buttons    nested arrays of grouped buttons config objects
	 * @Param {object} opts.container  container div to append modeBar
	 * @Param {object} opts.graphInfo  primary plot object containing data and layout
	 */
	function ModeBar(opts) {
	    this.container = opts.container;
	    this.element = document.createElement('div');
	
	    this.update(opts.graphInfo, opts.buttons);
	
	    this.container.appendChild(this.element);
	}
	
	var proto = ModeBar.prototype;
	
	/**
	 * Update modeBar (buttons and logo)
	 *
	 * @param {object} graphInfo  primary plot object containing data and layout
	 * @param {array of arrays} buttons nested arrays of grouped buttons to initialize
	 *
	 */
	proto.update = function(graphInfo, buttons) {
	    this.graphInfo = graphInfo;
	
	    var context = this.graphInfo._context;
	
	    if(context.displayModeBar === 'hover') {
	        this.element.className = 'modebar modebar--hover';
	    }
	    else this.element.className = 'modebar';
	
	    // if buttons or logo have changed, redraw modebar interior
	    var needsNewButtons = !this.hasButtons(buttons),
	        needsNewLogo = (this.hasLogo !== context.displaylogo);
	
	    if(needsNewButtons || needsNewLogo) {
	        this.removeAllButtons();
	
	        this.updateButtons(buttons);
	
	        if(context.displaylogo) {
	            this.element.appendChild(this.getLogo());
	            this.hasLogo = true;
	        }
	    }
	
	    this.updateActiveButton();
	};
	
	proto.updateButtons = function(buttons) {
	    var _this = this;
	
	    this.buttons = buttons;
	    this.buttonElements = [];
	    this.buttonsNames = [];
	
	    this.buttons.forEach(function(buttonGroup) {
	        var group = _this.createGroup();
	
	        buttonGroup.forEach(function(buttonConfig) {
	            var buttonName = buttonConfig.name;
	            if(!buttonName) {
	                throw new Error('must provide button \'name\' in button config');
	            }
	            if(_this.buttonsNames.indexOf(buttonName) !== -1) {
	                throw new Error('button name \'' + buttonName + '\' is taken');
	            }
	            _this.buttonsNames.push(buttonName);
	
	            var button = _this.createButton(buttonConfig);
	            _this.buttonElements.push(button);
	            group.appendChild(button);
	        });
	
	        _this.element.appendChild(group);
	    });
	};
	
	/**
	 * Empty div for containing a group of buttons
	 * @Return {HTMLelement}
	 */
	proto.createGroup = function() {
	    var group = document.createElement('div');
	    group.className = 'modebar-group';
	
	    return group;
	};
	
	/**
	 * Create a new button div and set constant and configurable attributes
	 * @Param {object} config (see ./buttons.js for more info)
	 * @Return {HTMLelement}
	 */
	proto.createButton = function(config) {
	    var _this = this,
	        button = document.createElement('a');
	
	    button.setAttribute('rel', 'tooltip');
	    button.className = 'modebar-btn';
	
	    var title = config.title;
	    if(title === undefined) title = config.name;
	    if(title || title === 0) button.setAttribute('data-title', title);
	
	    if(config.attr !== undefined) button.setAttribute('data-attr', config.attr);
	
	    var val = config.val;
	    if(val !== undefined) {
	        if(typeof val === 'function') val = val(this.graphInfo);
	        button.setAttribute('data-val', val);
	    }
	
	    var click = config.click;
	    if(typeof click !== 'function') {
	        throw new Error('must provide button \'click\' function in button config');
	    }
	    else {
	        button.addEventListener('click', function(ev) {
	            config.click(_this.graphInfo, ev);
	
	            // only needed for 'hoverClosestGeo' which does not call relayout
	            _this.updateActiveButton(ev.currentTarget);
	        });
	    }
	
	    button.setAttribute('data-toggle', config.toggle || false);
	    if(config.toggle) button.classList.add('active');
	
	    button.appendChild(this.createIcon(config.icon || Icons.question));
	    button.setAttribute('data-gravity', config.gravity || 'n');
	
	    return button;
	};
	
	/**
	 * Add an icon to a button
	 * @Param {object} thisIcon
	 * @Param {number} thisIcon.width
	 * @Param {string} thisIcon.path
	 * @Return {HTMLelement}
	 */
	proto.createIcon = function(thisIcon) {
	    var iconHeight = thisIcon.ascent - thisIcon.descent,
	        svgNS = 'http://www.w3.org/2000/svg',
	        icon = document.createElementNS(svgNS, 'svg'),
	        path = document.createElementNS(svgNS, 'path');
	
	    icon.setAttribute('height', '1em');
	    icon.setAttribute('width', (thisIcon.width / iconHeight) + 'em');
	    icon.setAttribute('viewBox', [0, 0, thisIcon.width, iconHeight].join(' '));
	
	    path.setAttribute('d', thisIcon.path);
	    path.setAttribute('transform', 'matrix(1 0 0 -1 0 ' + thisIcon.ascent + ')');
	    icon.appendChild(path);
	
	    return icon;
	};
	
	/**
	 * Updates active button with attribute specified in layout
	 * @Param {object} graphInfo plot object containing data and layout
	 * @Return {HTMLelement}
	 */
	proto.updateActiveButton = function(buttonClicked) {
	    var fullLayout = this.graphInfo._fullLayout,
	        dataAttrClicked = (buttonClicked !== undefined) ?
	            buttonClicked.getAttribute('data-attr') :
	            null;
	
	    this.buttonElements.forEach(function(button) {
	        var thisval = button.getAttribute('data-val') || true,
	            dataAttr = button.getAttribute('data-attr'),
	            isToggleButton = (button.getAttribute('data-toggle') === 'true'),
	            button3 = d3.select(button);
	
	        // Use 'data-toggle' and 'buttonClicked' to toggle buttons
	        // that have no one-to-one equivalent in fullLayout
	        if(isToggleButton) {
	            if(dataAttr === dataAttrClicked) {
	                button3.classed('active', !button3.classed('active'));
	            }
	        }
	        else {
	            var val = (dataAttr === null) ?
	                dataAttr :
	                Lib.nestedProperty(fullLayout, dataAttr).get();
	
	            button3.classed('active', val === thisval);
	        }
	
	    });
	};
	
	/**
	 * Check if modeBar is configured as button configuration argument
	 *
	 * @Param {object} buttons 2d array of grouped button config objects
	 * @Return {boolean}
	 */
	proto.hasButtons = function(buttons) {
	    var currentButtons = this.buttons;
	
	    if(!currentButtons) return false;
	
	    if(buttons.length !== currentButtons.length) return false;
	
	    for(var i = 0; i < buttons.length; ++i) {
	        if(buttons[i].length !== currentButtons[i].length) return false;
	        for(var j = 0; j < buttons[i].length; j++) {
	            if(buttons[i][j].name !== currentButtons[i][j].name) return false;
	        }
	    }
	
	    return true;
	};
	
	/**
	 * @return {HTMLDivElement} The logo image wrapped in a group
	 */
	proto.getLogo = function() {
	    var group = this.createGroup(),
	        a = document.createElement('a');
	
	    a.href = 'https://plot.ly/';
	    a.target = '_blank';
	    a.setAttribute('data-title', 'Produced with Plotly');
	    a.className = 'modebar-btn plotlyjsicon modebar-btn--logo';
	
	    a.appendChild(this.createIcon(Icons.plotlylogo));
	
	    group.appendChild(a);
	    return group;
	};
	
	proto.removeAllButtons = function() {
	    while(this.element.firstChild) {
	        this.element.removeChild(this.element.firstChild);
	    }
	
	    this.hasLogo = false;
	};
	
	proto.destroy = function() {
	    Lib.removeElement(this.container.querySelector('.modebar'));
	};
	
	function createModeBar(gd, buttons) {
	    var fullLayout = gd._fullLayout;
	
	    var modeBar = new ModeBar({
	        graphInfo: gd,
	        container: fullLayout._paperdiv.node(),
	        buttons: buttons
	    });
	
	    if(fullLayout._privateplot) {
	        d3.select(modeBar.element).append('span')
	            .classed('badge-private float--left', true)
	            .text('PRIVATE');
	    }
	
	    return modeBar;
	}
	
	module.exports = createModeBar;


/***/ },
/* 426 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    'undo': {
	        'width': 857.1,
	        'path': 'm857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'home': {
	        'width': 928.6,
	        'path': 'm786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'camera-retro': {
	        'width': 1000,
	        'path': 'm518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'zoombox': {
	        'width': 1000,
	        'path': 'm1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'pan': {
	        'width': 1000,
	        'path': 'm1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'zoom_plus': {
	        'width': 1000,
	        'path': 'm1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'zoom_minus': {
	        'width': 1000,
	        'path': 'm0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'autoscale': {
	        'width': 1000,
	        'path': 'm250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'tooltip_basic': {
	        'width': 1500,
	        'path': 'm375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'tooltip_compare': {
	        'width': 1125,
	        'path': 'm187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'plotlylogo': {
	        'width': 1542,
	        'path': 'm0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'z-axis': {
	        'width': 1000,
	        'path': 'm833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z',
	        'ascent': 850,
	        'descent': -150
	    },
	    '3d_rotate': {
	        'width': 1000,
	        'path': 'm922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'camera': {
	        'width': 1000,
	        'path': 'm500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'movie': {
	        'width': 1000,
	        'path': 'm938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'question': {
	        'width': 857.1,
	        'path': 'm500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'disk': {
	        'width': 857.1,
	        'path': 'm214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'lasso': {
	        'width': 1031,
	        'path': 'm1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z',
	        'ascent': 850,
	        'descent': -150
	    },
	    'selectbox': {
	        'width': 1000,
	        'path': 'm0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z',
	        'ascent': 850,
	        'descent': -150
	    }
	};


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Scatter = {};
	
	var subtypes = __webpack_require__(360);
	Scatter.hasLines = subtypes.hasLines;
	Scatter.hasMarkers = subtypes.hasMarkers;
	Scatter.hasText = subtypes.hasText;
	Scatter.isBubble = subtypes.isBubble;
	
	// traces with < this many points are by default shown
	// with points and lines, > just get lines
	Scatter.attributes = __webpack_require__(410);
	Scatter.supplyDefaults = __webpack_require__(428);
	Scatter.cleanData = __webpack_require__(435);
	Scatter.calc = __webpack_require__(436);
	Scatter.arraysToCalcdata = __webpack_require__(438);
	Scatter.plot = __webpack_require__(439);
	Scatter.colorbar = __webpack_require__(441);
	Scatter.style = __webpack_require__(442);
	Scatter.hoverPoints = __webpack_require__(443);
	Scatter.selectPoints = __webpack_require__(445);
	
	Scatter.moduleType = 'trace';
	Scatter.name = 'scatter';
	Scatter.basePlotModule = __webpack_require__(446);
	Scatter.categories = ['cartesian', 'symbols', 'markerColorscale', 'errorBarsOK', 'showLegend'];
	Scatter.meta = {
	    description: [
	        'The scatter trace type encompasses line charts, scatter charts, text charts, and bubble charts.',
	        'The data visualized as scatter point or lines is set in `x` and `y`.',
	        'Text (appearing either on the chart or on hover only) is via `text`.',
	        'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',
	        'to numerical arrays.'
	    ].join(' ')
	};
	
	module.exports = Scatter;


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	var attributes = __webpack_require__(410);
	var constants = __webpack_require__(411);
	var subTypes = __webpack_require__(360);
	var handleXYDefaults = __webpack_require__(429);
	var handleMarkerDefaults = __webpack_require__(430);
	var handleLineDefaults = __webpack_require__(431);
	var handleLineShapeDefaults = __webpack_require__(432);
	var handleTextDefaults = __webpack_require__(433);
	var handleFillColorDefaults = __webpack_require__(434);
	var errorBarsSupplyDefaults = __webpack_require__(400);
	
	
	module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
	    function coerce(attr, dflt) {
	        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
	    }
	
	    var len = handleXYDefaults(traceIn, traceOut, coerce),
	        // TODO: default mode by orphan points...
	        defaultMode = len < constants.PTS_LINESONLY ? 'lines+markers' : 'lines';
	    if(!len) {
	        traceOut.visible = false;
	        return;
	    }
	
	    coerce('text');
	    coerce('mode', defaultMode);
	
	    if(subTypes.hasLines(traceOut)) {
	        handleLineDefaults(traceIn, traceOut, defaultColor, coerce);
	        handleLineShapeDefaults(traceIn, traceOut, coerce);
	        coerce('connectgaps');
	    }
	
	    if(subTypes.hasMarkers(traceOut)) {
	        handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce);
	    }
	
	    if(subTypes.hasText(traceOut)) {
	        handleTextDefaults(traceIn, traceOut, layout, coerce);
	    }
	
	    if(subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
	        coerce('marker.maxdisplayed');
	    }
	
	    coerce('fill');
	    if(traceOut.fill !== 'none') {
	        handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);
	        if(!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
	    }
	
	    errorBarsSupplyDefaults(traceIn, traceOut, defaultColor, {axis: 'y'});
	    errorBarsSupplyDefaults(traceIn, traceOut, defaultColor, {axis: 'x', inherit: 'y'});
	};


/***/ },
/* 429 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	module.exports = function handleXYDefaults(traceIn, traceOut, coerce) {
	    var len,
	        x = coerce('x'),
	        y = coerce('y');
	
	    if(x) {
	        if(y) {
	            len = Math.min(x.length, y.length);
	            // TODO: not sure we should do this here... but I think
	            // the way it works in calc is wrong, because it'll delete data
	            // which could be a problem eg in streaming / editing if x and y
	            // come in at different times
	            // so we need to revisit calc before taking this out
	            if(len < x.length) traceOut.x = x.slice(0, len);
	            if(len < y.length) traceOut.y = y.slice(0, len);
	        }
	        else {
	            len = x.length;
	            coerce('y0');
	            coerce('dy');
	        }
	    }
	    else {
	        if(!y) return 0;
	
	        len = traceOut.y.length;
	        coerce('x0');
	        coerce('dx');
	    }
	    return len;
	};


/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Color = __webpack_require__(333);
	var hasColorscale = __webpack_require__(358);
	var colorscaleDefaults = __webpack_require__(343);
	
	var subTypes = __webpack_require__(360);
	
	
	// common to 'scatter', 'scatter3d', 'scattergeo' and 'scattergl'
	module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce) {
	    var isBubble = subTypes.isBubble(traceIn),
	        lineColor = (traceIn.line || {}).color,
	        defaultMLC;
	
	    if(lineColor) defaultColor = lineColor;
	
	    coerce('marker.symbol');
	    coerce('marker.opacity', isBubble ? 0.7 : 1);
	    coerce('marker.size');
	
	    coerce('marker.color', defaultColor);
	    if(hasColorscale(traceIn, 'marker')) {
	        colorscaleDefaults(
	            traceIn, traceOut, layout, coerce, {prefix: 'marker.', cLetter: 'c'}
	        );
	    }
	
	    // if there's a line with a different color than the marker, use
	    // that line color as the default marker line color
	    // mostly this is for transparent markers to behave nicely
	    if(lineColor && (traceOut.marker.color !== lineColor)) {
	        defaultMLC = lineColor;
	    }
	    else if(isBubble) defaultMLC = Color.background;
	    else defaultMLC = Color.defaultLine;
	
	    coerce('marker.line.color', defaultMLC);
	    if(hasColorscale(traceIn, 'marker.line')) {
	        colorscaleDefaults(
	            traceIn, traceOut, layout, coerce, {prefix: 'marker.line.', cLetter: 'c'}
	        );
	    }
	
	    coerce('marker.line.width', isBubble ? 1 : 0);
	
	    if(isBubble) {
	        coerce('marker.sizeref');
	        coerce('marker.sizemin');
	        coerce('marker.sizemode');
	    }
	};


/***/ },
/* 431 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	// common to 'scatter', 'scatter3d', 'scattergeo' and 'scattergl'
	module.exports = function lineDefaults(traceIn, traceOut, defaultColor, coerce) {
	    var markerColor = (traceIn.marker || {}).color;
	
	    // don't try to inherit a color array
	    coerce('line.color', (Array.isArray(markerColor) ? false : markerColor) ||
	                         defaultColor);
	    coerce('line.width');
	    coerce('line.dash');
	};


/***/ },
/* 432 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	// common to 'scatter' and 'scatterternary'
	module.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {
	    var shape = coerce('line.shape');
	    if(shape === 'spline') coerce('line.smoothing');
	};


/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	
	// common to 'scatter', 'scatter3d' and 'scattergeo'
	module.exports = function(traceIn, traceOut, layout, coerce) {
	    coerce('textposition');
	    Lib.coerceFont(coerce, 'textfont', layout.font);
	};


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Color = __webpack_require__(333);
	
	
	// common to 'scatter' and 'scattergl'
	module.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce) {
	    var inheritColorFromMarker = false;
	
	    if(traceOut.marker) {
	        // don't try to inherit a color array
	        var markerColor = traceOut.marker.color,
	            markerLineColor = (traceOut.marker.line || {}).color;
	
	        if(markerColor && !Array.isArray(markerColor)) {
	            inheritColorFromMarker = markerColor;
	        }
	        else if(markerLineColor && !Array.isArray(markerLineColor)) {
	            inheritColorFromMarker = markerLineColor;
	        }
	    }
	
	    coerce('fillcolor', Color.addOpacity(
	        (traceOut.line || {}).color ||
	        inheritColorFromMarker ||
	        defaultColor, 0.5
	    ));
	};


/***/ },
/* 435 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	
	module.exports = function cleanData(fullData) {
	    var i,
	        tracei,
	        filli,
	        j,
	        tracej;
	
	    // remove opacity for any trace that has a fill or is filled to
	    for(i = 0; i < fullData.length; i++) {
	        tracei = fullData[i];
	        filli = tracei.fill;
	        if((filli === 'none') || (tracei.type !== 'scatter')) continue;
	        tracei.opacity = undefined;
	
	        if(filli === 'tonexty' || filli === 'tonextx') {
	            for(j = i - 1; j >= 0; j--) {
	                tracej = fullData[j];
	                if((tracej.type === 'scatter') &&
	                        (tracej.xaxis === tracei.xaxis) &&
	                        (tracej.yaxis === tracei.yaxis)) {
	                    tracej.opacity = undefined;
	                    break;
	                }
	            }
	        }
	    }
	};


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Axes = __webpack_require__(338);
	var Lib = __webpack_require__(309);
	
	var subTypes = __webpack_require__(360);
	var calcMarkerColorscale = __webpack_require__(437);
	
	
	module.exports = function calc(gd, trace) {
	    var xa = Axes.getFromId(gd, trace.xaxis || 'x'),
	        ya = Axes.getFromId(gd, trace.yaxis || 'y');
	    Lib.markTime('in Scatter.calc');
	
	    var x = xa.makeCalcdata(trace, 'x');
	    Lib.markTime('finished convert x');
	
	    var y = ya.makeCalcdata(trace, 'y');
	    Lib.markTime('finished convert y');
	
	    var serieslen = Math.min(x.length, y.length),
	        marker,
	        s,
	        i;
	
	    // cancel minimum tick spacings (only applies to bars and boxes)
	    xa._minDtick = 0;
	    ya._minDtick = 0;
	
	    if(x.length > serieslen) x.splice(serieslen, x.length - serieslen);
	    if(y.length > serieslen) y.splice(serieslen, y.length - serieslen);
	
	    // check whether bounds should be tight, padded, extended to zero...
	    // most cases both should be padded on both ends, so start with that.
	    var xOptions = {padded: true},
	        yOptions = {padded: true};
	
	    if(subTypes.hasMarkers(trace)) {
	
	        // Treat size like x or y arrays --- Run d2c
	        // this needs to go before ppad computation
	        marker = trace.marker;
	        s = marker.size;
	
	        if(Array.isArray(s)) {
	            // I tried auto-type but category and dates dont make much sense.
	            var ax = {type: 'linear'};
	            Axes.setConvert(ax);
	            s = ax.makeCalcdata(trace.marker, 'size');
	            if(s.length > serieslen) s.splice(serieslen, s.length - serieslen);
	        }
	
	        var sizeref = 1.6 * (trace.marker.sizeref || 1),
	            markerTrans;
	        if(trace.marker.sizemode === 'area') {
	            markerTrans = function(v) {
	                return Math.max(Math.sqrt((v || 0) / sizeref), 3);
	            };
	        }
	        else {
	            markerTrans = function(v) {
	                return Math.max((v || 0) / sizeref, 3);
	            };
	        }
	        xOptions.ppad = yOptions.ppad = Array.isArray(s) ?
	            s.map(markerTrans) : markerTrans(s);
	    }
	
	    calcMarkerColorscale(trace);
	
	    // TODO: text size
	
	    // include zero (tight) and extremes (padded) if fill to zero
	    // (unless the shape is closed, then it's just filling the shape regardless)
	    if(((trace.fill === 'tozerox') ||
	            ((trace.fill === 'tonextx') && gd.firstscatter)) &&
	            ((x[0] !== x[serieslen - 1]) || (y[0] !== y[serieslen - 1]))) {
	        xOptions.tozero = true;
	    }
	
	    // if no error bars, markers or text, or fill to y=0 remove x padding
	    else if(!trace.error_y.visible && (
	            ['tonexty', 'tozeroy'].indexOf(trace.fill) !== -1 ||
	            (!subTypes.hasMarkers(trace) && !subTypes.hasText(trace))
	        )) {
	        xOptions.padded = false;
	        xOptions.ppad = 0;
	    }
	
	    // now check for y - rather different logic, though still mostly padded both ends
	    // include zero (tight) and extremes (padded) if fill to zero
	    // (unless the shape is closed, then it's just filling the shape regardless)
	    if(((trace.fill === 'tozeroy') || ((trace.fill === 'tonexty') && gd.firstscatter)) &&
	            ((x[0] !== x[serieslen - 1]) || (y[0] !== y[serieslen - 1]))) {
	        yOptions.tozero = true;
	    }
	
	    // tight y: any x fill
	    else if(['tonextx', 'tozerox'].indexOf(trace.fill) !== -1) {
	        yOptions.padded = false;
	    }
	
	    Lib.markTime('ready for Axes.expand');
	    Axes.expand(xa, x, xOptions);
	    Lib.markTime('done expand x');
	    Axes.expand(ya, y, yOptions);
	    Lib.markTime('done expand y');
	
	    // create the "calculated data" to plot
	    var cd = new Array(serieslen);
	    for(i = 0; i < serieslen; i++) {
	        cd[i] = (isNumeric(x[i]) && isNumeric(y[i])) ?
	            {x: x[i], y: y[i]} : {x: false, y: false};
	    }
	
	    // this has migrated up from arraysToCalcdata as we have a reference to 's' here
	    if(typeof s !== undefined) Lib.mergeArray(s, cd, 'ms');
	
	    gd.firstscatter = false;
	    return cd;
	};


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var hasColorscale = __webpack_require__(358);
	var calcColorscale = __webpack_require__(357);
	
	var subTypes = __webpack_require__(360);
	
	
	// common to 'scatter', 'scatter3d' and 'scattergeo'
	module.exports = function calcMarkerColorscale(trace) {
	    if(!subTypes.hasMarkers(trace)) return;
	
	    var marker = trace.marker;
	
	    // auto-z and autocolorscale if applicable
	    if(hasColorscale(trace, 'marker')) {
	        calcColorscale(trace, marker.color, 'marker', 'c');
	    }
	
	    if(hasColorscale(trace, 'marker.line')) {
	        calcColorscale(trace, marker.line.color, 'marker.line', 'c');
	    }
	};


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	
	
	// arrayOk attributes, merge them into calcdata array
	module.exports = function arraysToCalcdata(cd) {
	    var trace = cd[0].trace,
	        marker = trace.marker;
	
	    Lib.mergeArray(trace.text, cd, 'tx');
	    Lib.mergeArray(trace.textposition, cd, 'tp');
	    if(trace.textfont) {
	        Lib.mergeArray(trace.textfont.size, cd, 'ts');
	        Lib.mergeArray(trace.textfont.color, cd, 'tc');
	        Lib.mergeArray(trace.textfont.family, cd, 'tf');
	    }
	
	    if(marker && marker.line) {
	        var markerLine = marker.line;
	        Lib.mergeArray(marker.opacity, cd, 'mo');
	        Lib.mergeArray(marker.symbol, cd, 'mx');
	        Lib.mergeArray(marker.color, cd, 'mc');
	        Lib.mergeArray(markerLine.color, cd, 'mlc');
	        Lib.mergeArray(markerLine.width, cd, 'mlw');
	    }
	};


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Lib = __webpack_require__(309);
	var Drawing = __webpack_require__(340);
	var ErrorBars = __webpack_require__(398);
	
	var subTypes = __webpack_require__(360);
	var arraysToCalcdata = __webpack_require__(438);
	var linePoints = __webpack_require__(440);
	
	
	module.exports = function plot(gd, plotinfo, cdscatter) {
	    selectMarkers(gd, plotinfo, cdscatter);
	
	    var xa = plotinfo.x(),
	        ya = plotinfo.y();
	
	    // make the container for scatter plots
	    // (so error bars can find them along with bars)
	    var scattertraces = plotinfo.plot.select('.scatterlayer')
	        .selectAll('g.trace.scatter')
	        .data(cdscatter);
	
	    scattertraces.enter().append('g')
	        .attr('class', 'trace scatter')
	        .style('stroke-miterlimit', 2);
	
	    // error bars are at the bottom
	    scattertraces.call(ErrorBars.plot, plotinfo);
	
	    // BUILD LINES AND FILLS
	    var prevpath = '',
	        ownFillEl3, ownFillDir, tonext, nexttonext;
	
	    scattertraces.each(function(d) {
	        var trace = d[0].trace,
	            line = trace.line,
	            tr = d3.select(this);
	        if(trace.visible !== true) return;
	
	        ownFillDir = trace.fill.charAt(trace.fill.length - 1);
	        if(ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';
	
	        d[0].node3 = tr; // store node for tweaking by selectPoints
	
	        arraysToCalcdata(d);
	
	        if(!subTypes.hasLines(trace) && trace.fill === 'none') return;
	
	        var thispath,
	            thisrevpath,
	            // fullpath is all paths for this curve, joined together straight
	            // across gaps, for filling
	            fullpath = '',
	            // revpath is fullpath reversed, for fill-to-next
	            revpath = '',
	            // functions for converting a point array to a path
	            pathfn, revpathbase, revpathfn;
	
	        // make the fill-to-zero path now, so it shows behind the line
	        // fill to next puts the fill associated with one trace
	        // grouped with the previous
	        if(trace.fill.substr(0, 6) === 'tozero' || trace.fill === 'toself' ||
	                (trace.fill.substr(0, 2) === 'to' && !prevpath)) {
	            ownFillEl3 = tr.append('path')
	                .classed('js-fill', true);
	        }
	        else ownFillEl3 = null;
	
	        // make the fill-to-next path now for the NEXT trace, so it shows
	        // behind both lines.
	        // nexttonext was created last time, but give it
	        // this curve's data for fill color
	        if(nexttonext) tonext = nexttonext.datum(d);
	
	        // now make a new nexttonext for next time
	        nexttonext = tr.append('path').classed('js-fill', true);
	
	        if(['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {
	            pathfn = Drawing.steps(line.shape);
	            revpathbase = Drawing.steps(
	                line.shape.split('').reverse().join('')
	            );
	        }
	        else if(line.shape === 'spline') {
	            pathfn = revpathbase = function(pts) {
	                var pLast = pts[pts.length - 1];
	                if(pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {
	                    // identical start and end points: treat it as a
	                    // closed curve so we don't get a kink
	                    return Drawing.smoothclosed(pts.slice(1), line.smoothing);
	                }
	                else {
	                    return Drawing.smoothopen(pts, line.smoothing);
	                }
	            };
	        }
	        else {
	            pathfn = revpathbase = function(pts) {
	                return 'M' + pts.join('L');
	            };
	        }
	
	        revpathfn = function(pts) {
	            // note: this is destructive (reverses pts in place) so can't use pts after this
	            return revpathbase(pts.reverse());
	        };
	
	        var segments = linePoints(d, {
	            xaxis: xa,
	            yaxis: ya,
	            connectGaps: trace.connectgaps,
	            baseTolerance: Math.max(line.width || 1, 3) / 4,
	            linear: line.shape === 'linear'
	        });
	
	        if(segments.length) {
	            var pt0 = segments[0][0],
	                lastSegment = segments[segments.length - 1],
	                pt1 = lastSegment[lastSegment.length - 1];
	
	            for(var i = 0; i < segments.length; i++) {
	                var pts = segments[i];
	                thispath = pathfn(pts);
	                thisrevpath = revpathfn(pts);
	                if(!fullpath) {
	                    fullpath = thispath;
	                    revpath = thisrevpath;
	                }
	                else if(ownFillDir) {
	                    fullpath += 'L' + thispath.substr(1);
	                    revpath = thisrevpath + ('L' + revpath.substr(1));
	                }
	                else {
	                    fullpath += 'Z' + thispath;
	                    revpath = thisrevpath + 'Z' + revpath;
	                }
	                if(subTypes.hasLines(trace) && pts.length > 1) {
	                    tr.append('path').classed('js-line', true).attr('d', thispath);
	                }
	            }
	            if(ownFillEl3) {
	                if(pt0 && pt1) {
	                    if(ownFillDir) {
	                        if(ownFillDir === 'y') {
	                            pt0[1] = pt1[1] = ya.c2p(0, true);
	                        }
	                        else if(ownFillDir === 'x') {
	                            pt0[0] = pt1[0] = xa.c2p(0, true);
	                        }
	
	                        // fill to zero: full trace path, plus extension of
	                        // the endpoints to the appropriate axis
	                        ownFillEl3.attr('d', fullpath + 'L' + pt1 + 'L' + pt0 + 'Z');
	                    }
	                    // fill to self: just join the path to itself
	                    else ownFillEl3.attr('d', fullpath + 'Z');
	                }
	            }
	            else if(trace.fill.substr(0, 6) === 'tonext' && fullpath && prevpath) {
	                // fill to next: full trace path, plus the previous path reversed
	                if(trace.fill === 'tonext') {
	                    // tonext: for use by concentric shapes, like manually constructed
	                    // contours, we just add the two paths closed on themselves.
	                    // This makes strange results if one path is *not* entirely
	                    // inside the other, but then that is a strange usage.
	                    tonext.attr('d', fullpath + 'Z' + prevpath + 'Z');
	                }
	                else {
	                    // tonextx/y: for now just connect endpoints with lines. This is
	                    // the correct behavior if the endpoints are at the same value of
	                    // y/x, but if they *aren't*, we should ideally do more complicated
	                    // things depending on whether the new endpoint projects onto the
	                    // existing curve or off the end of it
	                    tonext.attr('d', fullpath + 'L' + prevpath.substr(1) + 'Z');
	                }
	            }
	            prevpath = revpath;
	        }
	    });
	
	    // remove paths that didn't get used
	    scattertraces.selectAll('path:not([d])').remove();
	
	    function visFilter(d) {
	        return d.filter(function(v) { return v.vis; });
	    }
	
	    scattertraces.append('g')
	        .attr('class', 'points')
	        .each(function(d) {
	            var trace = d[0].trace,
	                s = d3.select(this),
	                showMarkers = subTypes.hasMarkers(trace),
	                showText = subTypes.hasText(trace);
	
	            if((!showMarkers && !showText) || trace.visible !== true) s.remove();
	            else {
	                if(showMarkers) {
	                    s.selectAll('path.point')
	                        .data(trace.marker.maxdisplayed ? visFilter : Lib.identity)
	                        .enter().append('path')
	                            .classed('point', true)
	                            .call(Drawing.translatePoints, xa, ya);
	                }
	                if(showText) {
	                    s.selectAll('g')
	                        .data(trace.marker.maxdisplayed ? visFilter : Lib.identity)
	                        // each text needs to go in its own 'g' in case
	                        // it gets converted to mathjax
	                        .enter().append('g')
	                            .append('text')
	                            .call(Drawing.translatePoints, xa, ya);
	                }
	            }
	        });
	};
	
	function selectMarkers(gd, plotinfo, cdscatter) {
	    var xa = plotinfo.x(),
	        ya = plotinfo.y(),
	        xr = d3.extent(xa.range.map(xa.l2c)),
	        yr = d3.extent(ya.range.map(ya.l2c));
	
	    cdscatter.forEach(function(d, i) {
	        var trace = d[0].trace;
	        if(!subTypes.hasMarkers(trace)) return;
	        // if marker.maxdisplayed is used, select a maximum of
	        // mnum markers to show, from the set that are in the viewport
	        var mnum = trace.marker.maxdisplayed;
	
	        // TODO: remove some as we get away from the viewport?
	        if(mnum === 0) return;
	
	        var cd = d.filter(function(v) {
	                return v.x>=xr[0] && v.x<=xr[1] && v.y>=yr[0] && v.y<=yr[1];
	            }),
	            inc = Math.ceil(cd.length / mnum),
	            tnum = 0;
	        cdscatter.forEach(function(cdj, j) {
	            var tracei = cdj[0].trace;
	            if(subTypes.hasMarkers(tracei) &&
	                    tracei.marker.maxdisplayed>0 && j<i) {
	                tnum++;
	            }
	        });
	
	        // if multiple traces use maxdisplayed, stagger which markers we
	        // display this formula offsets successive traces by 1/3 of the
	        // increment, adding an extra small amount after each triplet so
	        // it's not quite periodic
	        var i0 = Math.round(tnum*inc/3 + Math.floor(tnum/3) * inc/7.1);
	
	        // for error bars: save in cd which markers to show
	        // so we don't have to repeat this
	        d.forEach(function(v) { delete v.vis; });
	        cd.forEach(function(v, i) {
	            if(Math.round((i + i0) % inc) === 0) v.vis = true;
	        });
	    });
	}


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Axes = __webpack_require__(338);
	
	
	module.exports = function linePoints(d, opts) {
	    var xa = opts.xaxis,
	        ya = opts.yaxis,
	        connectGaps = opts.connectGaps,
	        baseTolerance = opts.baseTolerance,
	        linear = opts.linear,
	        segments = [],
	        badnum = Axes.BADNUM,
	        minTolerance = 0.2, // fraction of tolerance "so close we don't even consider it a new point"
	        pts = new Array(d.length),
	        pti = 0,
	        i,
	
	        // pt variables are pixel coordinates [x,y] of one point
	        clusterStartPt, // these four are the outputs of clustering on a line
	        clusterEndPt,
	        clusterHighPt,
	        clusterLowPt,
	        thisPt, // "this" is the next point we're considering adding to the cluster
	
	        clusterRefDist,
	        clusterHighFirst, // did we encounter the high point first, then a low point, or vice versa?
	        clusterUnitVector, // the first two points in the cluster determine its unit vector
	                           // so the second is always in the "High" direction
	        thisVector, // the pixel delta from clusterStartPt
	
	        // val variables are (signed) pixel distances along the cluster vector
	        clusterHighVal,
	        clusterLowVal,
	        thisVal,
	
	        // deviation variables are (signed) pixel distances normal to the cluster vector
	        clusterMinDeviation,
	        clusterMaxDeviation,
	        thisDeviation;
	
	    // turn one calcdata point into pixel coordinates
	    function getPt(index) {
	        var x = xa.c2p(d[index].x),
	            y = ya.c2p(d[index].y);
	        if(x === badnum || y === badnum) return false;
	        return [x, y];
	    }
	
	    // if we're off-screen, increase tolerance over baseTolerance
	    function getTolerance(pt) {
	        var xFrac = pt[0] / xa._length,
	            yFrac = pt[1] / ya._length;
	        return (1 + 10 * Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1)) * baseTolerance;
	    }
	
	    function ptDist(pt1, pt2) {
	        var dx = pt1[0] - pt2[0],
	            dy = pt1[1] - pt2[1];
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    // loop over ALL points in this trace
	    for(i = 0; i < d.length; i++) {
	        clusterStartPt = getPt(i);
	        if(!clusterStartPt) continue;
	
	        pti = 0;
	        pts[pti++] = clusterStartPt;
	
	        // loop over one segment of the trace
	        for(i++; i < d.length; i++) {
	            clusterHighPt = getPt(i);
	            if(!clusterHighPt) {
	                if(connectGaps) continue;
	                else break;
	            }
	
	            // can't decimate if nonlinear line shape
	            // TODO: we *could* decimate [hv]{2,3} shapes if we restricted clusters to horz or vert again
	            // but spline would be verrry awkward to decimate
	            if(!linear) {
	                pts[pti++] = clusterHighPt;
	                continue;
	            }
	
	            clusterRefDist = ptDist(clusterHighPt, clusterStartPt);
	
	            if(clusterRefDist < getTolerance(clusterHighPt) * minTolerance) continue;
	
	            clusterUnitVector = [
	                (clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist,
	                (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist
	            ];
	
	            clusterLowPt = clusterStartPt;
	            clusterHighVal = clusterRefDist;
	            clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;
	            clusterHighFirst = false;
	            clusterEndPt = clusterHighPt;
	
	            // loop over one cluster of points that collapse onto one line
	            for(i++; i < d.length; i++) {
	                thisPt = getPt(i);
	                if(!thisPt) {
	                    if(connectGaps) continue;
	                    else break;
	                }
	                thisVector = [
	                    thisPt[0] - clusterStartPt[0],
	                    thisPt[1] - clusterStartPt[1]
	                ];
	                // cross product (or dot with normal to the cluster vector)
	                thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];
	                clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);
	                clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);
	
	                if(clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt)) break;
	
	                clusterEndPt = thisPt;
	                thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];
	
	                if(thisVal > clusterHighVal) {
	                    clusterHighVal = thisVal;
	                    clusterHighPt = thisPt;
	                    clusterHighFirst = false;
	                } else if(thisVal < clusterLowVal) {
	                    clusterLowVal = thisVal;
	                    clusterLowPt = thisPt;
	                    clusterHighFirst = true;
	                }
	            }
	
	            // insert this cluster into pts
	            // we've already inserted the start pt, now check if we have high and low pts
	            if(clusterHighFirst) {
	                pts[pti++] = clusterHighPt;
	                if(clusterEndPt !== clusterLowPt) pts[pti++] = clusterLowPt;
	            } else {
	                if(clusterLowPt !== clusterStartPt) pts[pti++] = clusterLowPt;
	                if(clusterEndPt !== clusterHighPt) pts[pti++] = clusterHighPt;
	            }
	            // and finally insert the end pt
	            pts[pti++] = clusterEndPt;
	
	            // have we reached the end of this segment?
	            if(i >= d.length || !thisPt) break;
	
	            // otherwise we have an out-of-cluster point to insert as next clusterStartPt
	            pts[pti++] = thisPt;
	            clusterStartPt = thisPt;
	        }
	
	        segments.push(pts.slice(0, pti));
	    }
	
	    return segments;
	};


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	var getColorscale = __webpack_require__(316);
	var drawColorbar = __webpack_require__(397);
	
	
	module.exports = function colorbar(gd, cd) {
	    var trace = cd[0].trace,
	        marker = trace.marker,
	        cbId = 'cb' + trace.uid;
	
	    gd._fullLayout._infolayer.selectAll('.' + cbId).remove();
	
	    // TODO unify Scatter.colorbar and Heatmap.colorbar
	    // TODO make Plotly[module].colorbar support multiple colorbar per trace
	
	    if((marker === undefined) || !marker.showscale) {
	        Plots.autoMargin(gd, cbId);
	        return;
	    }
	
	    var scl = getColorscale(marker.colorscale),
	        vals = marker.color,
	        cmin = marker.cmin,
	        cmax = marker.cmax;
	
	    if(!isNumeric(cmin)) cmin = Lib.aggNums(Math.min, null, vals);
	    if(!isNumeric(cmax)) cmax = Lib.aggNums(Math.max, null, vals);
	
	    var cb = cd[0].t.cb = drawColorbar(gd, cbId);
	
	    cb.fillcolor(d3.scale.linear()
	            .domain(scl.map(function(v) { return cmin + v[0] * (cmax - cmin); }))
	            .range(scl.map(function(v) { return v[1]; })))
	        .filllevels({start: cmin, end: cmax, size: (cmax - cmin) / 254})
	        .options(marker.colorbar)();
	
	    Lib.markTime('done colorbar');
	};


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Drawing = __webpack_require__(340);
	var ErrorBars = __webpack_require__(398);
	
	
	module.exports = function style(gd) {
	    var s = d3.select(gd).selectAll('g.trace.scatter');
	
	    s.style('opacity', function(d) {
	        return d[0].trace.opacity;
	    });
	
	    s.selectAll('g.points')
	        .each(function(d) {
	            d3.select(this).selectAll('path.point')
	                .call(Drawing.pointStyle, d.trace || d[0].trace);
	            d3.select(this).selectAll('text')
	                .call(Drawing.textPointStyle, d.trace || d[0].trace);
	        });
	
	    s.selectAll('g.trace path.js-line')
	        .call(Drawing.lineGroupStyle);
	
	    s.selectAll('g.trace path.js-fill')
	        .call(Drawing.fillGroupStyle);
	
	    s.call(ErrorBars.style);
	};


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Fx = __webpack_require__(382);
	var ErrorBars = __webpack_require__(398);
	var getTraceColor = __webpack_require__(444);
	
	
	module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
	    var cd = pointData.cd,
	        trace = cd[0].trace,
	        xa = pointData.xa,
	        ya = pointData.ya,
	        dx = function(di) {
	            // scatter points: d.mrc is the calculated marker radius
	            // adjust the distance so if you're inside the marker it
	            // always will show up regardless of point size, but
	            // prioritize smaller points
	            var rad = Math.max(3, di.mrc || 0);
	            return Math.max(Math.abs(xa.c2p(di.x)-xa.c2p(xval))-rad, 1-3/rad);
	        },
	        dy = function(di) {
	            var rad = Math.max(3, di.mrc || 0);
	            return Math.max(Math.abs(ya.c2p(di.y)-ya.c2p(yval))-rad, 1-3/rad);
	        },
	        dxy = function(di) {
	            var rad = Math.max(3, di.mrc || 0),
	                dx = Math.abs(xa.c2p(di.x)-xa.c2p(xval)),
	                dy = Math.abs(ya.c2p(di.y)-ya.c2p(yval));
	            return Math.max(Math.sqrt(dx*dx + dy*dy)-rad, 1-3/rad);
	        },
	        distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
	
	    Fx.getClosest(cd, distfn, pointData);
	
	    // skip the rest (for this trace) if we didn't find a close point
	    if(pointData.index === false) return;
	
	    // the closest data point
	    var di = cd[pointData.index],
	        xc = xa.c2p(di.x, true),
	        yc = ya.c2p(di.y, true),
	        rad = di.mrc || 1;
	
	    pointData.color = getTraceColor(trace, di);
	
	    pointData.x0 = xc - rad;
	    pointData.x1 = xc + rad;
	    pointData.xLabelVal = di.x;
	
	    pointData.y0 = yc - rad;
	    pointData.y1 = yc + rad;
	    pointData.yLabelVal = di.y;
	
	    if(di.tx) pointData.text = di.tx;
	    else if(trace.text) pointData.text = trace.text;
	
	    ErrorBars.hoverInfo(di, trace, pointData);
	
	    return [pointData];
	};


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Color = __webpack_require__(333);
	var subtypes = __webpack_require__(360);
	
	
	module.exports = function getTraceColor(trace, di) {
	    var lc, tc;
	
	    // TODO: text modes
	
	    if(trace.mode === 'lines') {
	        lc = trace.line.color;
	        return (lc && Color.opacity(lc)) ?
	            lc : trace.fillcolor;
	    }
	    else if(trace.mode === 'none') {
	        return trace.fill ? trace.fillcolor : '';
	    }
	    else {
	        var mc = di.mcc || (trace.marker || {}).color,
	            mlc = di.mlcc || ((trace.marker || {}).line || {}).color;
	
	        tc = (mc && Color.opacity(mc)) ? mc :
	            (mlc && Color.opacity(mlc) &&
	                (di.mlw || ((trace.marker || {}).line || {}).width)) ? mlc : '';
	
	        if(tc) {
	            // make sure the points aren't TOO transparent
	            if(Color.opacity(tc) < 0.3) {
	                return Color.addOpacity(tc, 0.3);
	            }
	            else return tc;
	        }
	        else {
	            lc = (trace.line || {}).color;
	            return (lc && Color.opacity(lc) &&
	                subtypes.hasLines(trace) && trace.line.width) ?
	                    lc : trace.fillcolor;
	        }
	    }
	};


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var subtypes = __webpack_require__(360);
	
	var DESELECTDIM = 0.2;
	
	module.exports = function selectPoints(searchInfo, polygon) {
	    var cd = searchInfo.cd,
	        xa = searchInfo.xaxis,
	        ya = searchInfo.yaxis,
	        selection = [],
	        trace = cd[0].trace,
	        curveNumber = trace.index,
	        marker = trace.marker,
	        i,
	        di,
	        x,
	        y;
	
	    // TODO: include lines? that would require per-segment line properties
	    if(!subtypes.hasMarkers(trace) && ! subtypes.hasText(trace)) return;
	
	    var opacity = Array.isArray(marker.opacity) ? 1 : marker.opacity;
	
	    if(polygon === false) { // clear selection
	        for(i = 0; i < cd.length; i++) cd[i].dim = 0;
	    }
	    else {
	        for(i = 0; i < cd.length; i++) {
	            di = cd[i];
	            x = xa.c2p(di.x);
	            y = ya.c2p(di.y);
	            if(polygon.contains([x, y])) {
	                selection.push({
	                    curveNumber: curveNumber,
	                    pointNumber: i,
	                    x: di.x,
	                    y: di.y
	                });
	                di.dim = 0;
	            }
	            else di.dim = 1;
	        }
	    }
	
	    // do the dimming here, as well as returning the selection
	    // The logic here duplicates Drawing.pointStyle, but I don't want
	    // d.dim in pointStyle in case something goes wrong with selection.
	    cd[0].node3.selectAll('path.point')
	        .style('opacity', function(d) {
	            return ((d.mo+1 || opacity+1) - 1) * (d.dim ? DESELECTDIM : 1);
	        });
	    cd[0].node3.selectAll('text')
	        .style('opacity', function(d) {
	            return d.dim ? DESELECTDIM : 1;
	        });
	
	    return selection;
	};


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var Plots = __webpack_require__(332);
	
	var constants = __webpack_require__(352);
	
	exports.name = 'cartesian';
	
	exports.attr = ['xaxis', 'yaxis'];
	
	exports.idRoot = ['x', 'y'];
	
	exports.idRegex = constants.idRegex;
	
	exports.attrRegex = constants.attrRegex;
	
	exports.attributes = __webpack_require__(447);
	
	exports.plot = function(gd) {
	    var fullLayout = gd._fullLayout,
	        subplots = Plots.getSubplotIds(fullLayout, 'cartesian'),
	        calcdata = gd.calcdata,
	        modules = fullLayout._modules;
	
	    function getCdSubplot(calcdata, subplot) {
	        var cdSubplot = [];
	
	        for(var i = 0; i < calcdata.length; i++) {
	            var cd = calcdata[i];
	            var trace = cd[0].trace;
	
	            if(trace.xaxis + trace.yaxis === subplot) {
	                cdSubplot.push(cd);
	            }
	        }
	
	        return cdSubplot;
	    }
	
	    function getCdModule(cdSubplot, _module) {
	        var cdModule = [];
	
	        for(var i = 0; i < cdSubplot.length; i++) {
	            var cd = cdSubplot[i];
	            var trace = cd[0].trace;
	
	            if((trace._module === _module) && (trace.visible === true)) {
	                cdModule.push(cd);
	            }
	        }
	
	        return cdModule;
	    }
	
	    for(var i = 0; i < subplots.length; i++) {
	        var subplot = subplots[i],
	            subplotInfo = fullLayout._plots[subplot],
	            cdSubplot = getCdSubplot(calcdata, subplot);
	
	        // remove old traces, then redraw everything
	        // TODO: use enter/exit appropriately in the plot functions
	        // so we don't need this - should sometimes be a big speedup
	        if(subplotInfo.plot) subplotInfo.plot.selectAll('g.trace').remove();
	
	        for(var j = 0; j < modules.length; j++) {
	            var _module = modules[j];
	
	            // skip over non-cartesian trace modules
	            if(_module.basePlotModule.name !== 'cartesian') continue;
	
	            // plot all traces of this type on this subplot at once
	            var cdModule = getCdModule(cdSubplot, _module);
	            _module.plot(gd, subplotInfo, cdModule);
	
	            Lib.markTime('done ' + (cdModule[0] && cdModule[0][0].trace.type));
	        }
	    }
	};


/***/ },
/* 447 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    xaxis: {
	        valType: 'subplotid',
	        role: 'info',
	        dflt: 'x',
	        description: [
	            'Sets a reference between this trace\'s x coordinates and',
	            'a 2D cartesian x axis.',
	            'If *x* (the default value), the x coordinates refer to',
	            '`layout.xaxis`.',
	            'If *x2*, the x coordinates refer to `layout.xaxis2`, and so on.'
	        ].join(' ')
	    },
	    yaxis: {
	        valType: 'subplotid',
	        role: 'info',
	        dflt: 'y',
	        description: [
	            'Sets a reference between this trace\'s y coordinates and',
	            'a 2D cartesian y axis.',
	            'If *y* (the default value), the y coordinates refer to',
	            '`layout.yaxis`.',
	            'If *y2*, the y coordinates refer to `layout.xaxis2`, and so on.'
	        ].join(' ')
	    }
	};


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var m4FromQuat = __webpack_require__(449);
	var isNumeric = __webpack_require__(312);
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var Events = __webpack_require__(383);
	var Queue = __webpack_require__(328);
	
	var Plots = __webpack_require__(332);
	var Fx = __webpack_require__(382);
	
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var ErrorBars = __webpack_require__(398);
	var Images = __webpack_require__(421);
	var Legend = __webpack_require__(412);
	var RangeSlider = __webpack_require__(364);
	var RangeSelector = __webpack_require__(369);
	var Shapes = __webpack_require__(408);
	var Titles = __webpack_require__(339);
	var manageModeBar = __webpack_require__(450);
	var xmlnsNamespaces = __webpack_require__(327);
	
	
	/**
	 * Main plot-creation function
	 *
	 * Note: will call makePlotFramework if necessary to create the framework
	 *
	 * @param {string id or DOM element} gd
	 *      the id or DOM element of the graph container div
	 * @param {array of objects} data
	 *      array of traces, containing the data and display information for each trace
	 * @param {object} layout
	 *      object describing the overall display of the plot,
	 *      all the stuff that doesn't pertain to any individual trace
	 * @param {object} config
	 *      configuration options (see ./plot_config.js for more info)
	 *
	 */
	Plotly.plot = function(gd, data, layout, config) {
	    Lib.markTime('in plot');
	
	    gd = getGraphDiv(gd);
	
	    // Events.init is idempotent and bails early if gd has already been init'd
	    Events.init(gd);
	
	    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);
	    if(okToPlot === false) return Promise.reject();
	
	    // if there's no data or layout, and this isn't yet a plotly plot
	    // container, log a warning to help plotly.js users debug
	    if(!data && !layout && !Lib.isPlotDiv(gd)) {
	        console.log('Warning: calling Plotly.plot as if redrawing ' +
	            'but this container doesn\'t yet have a plot.', gd);
	    }
	
	    // transfer configuration options to gd until we move over to
	    // a more OO like model
	    setPlotContext(gd, config);
	
	    if(!layout) layout = {};
	
	    // hook class for plots main container (in case of plotly.js
	    // this won't be #embedded-graph or .js-tab-contents)
	    d3.select(gd).classed('js-plotly-plot', true);
	
	    // off-screen getBoundingClientRect testing space,
	    // in #js-plotly-tester (and stored as gd._tester)
	    // so we can share cached text across tabs
	    Drawing.makeTester(gd);
	
	    // collect promises for any async actions during plotting
	    // any part of the plotting code can push to gd._promises, then
	    // before we move to the next step, we check that they're all
	    // complete, and empty out the promise list again.
	    gd._promises = [];
	
	    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));
	
	    // if there is already data on the graph, append the new data
	    // if you only want to redraw, pass a non-array for data
	    if(Array.isArray(data)) {
	        cleanData(data, gd.data);
	
	        if(graphWasEmpty) gd.data = data;
	        else gd.data.push.apply(gd.data, data);
	
	        // for routines outside graph_obj that want a clean tab
	        // (rather than appending to an existing one) gd.empty
	        // is used to determine whether to make a new tab
	        gd.empty = false;
	    }
	
	    if(!gd.layout || graphWasEmpty) gd.layout = cleanLayout(layout);
	
	    // if the user is trying to drag the axes, allow new data and layout
	    // to come in but don't allow a replot.
	    if(gd._dragging) {
	        // signal to drag handler that after everything else is done
	        // we need to replot, because something has changed
	        gd._replotPending = true;
	        return Promise.reject();
	    } else {
	        // we're going ahead with a replot now
	        gd._replotPending = false;
	    }
	
	    Plots.supplyDefaults(gd);
	
	    // Polar plots
	    if(data && data[0] && data[0].r) return plotPolar(gd, data, layout);
	
	    // so we don't try to re-call Plotly.plot from inside
	    // legend and colorbar, if margins changed
	    gd._replotting = true;
	    var hasData = gd._fullData.length > 0;
	
	    var subplots = Plotly.Axes.getSubplots(gd).join(''),
	        oldSubplots = Object.keys(gd._fullLayout._plots || {}).join(''),
	        hasSameSubplots = (oldSubplots === subplots);
	
	    // Make or remake the framework (ie container and axes) if we need to
	    // note: if they container already exists and has data,
	    //  the new layout gets ignored (as it should)
	    //  but if there's no data there yet, it's just a placeholder...
	    //  then it should destroy and remake the plot
	    if(hasData) {
	        if(gd.framework !== makePlotFramework || graphWasEmpty || !hasSameSubplots) {
	            gd.framework = makePlotFramework;
	            makePlotFramework(gd);
	        }
	    }
	    else if(!hasSameSubplots) {
	        gd.framework = makePlotFramework;
	        makePlotFramework(gd);
	    }
	    else if(graphWasEmpty) makePlotFramework(gd);
	
	    // save initial axis range once per graph
	    if(graphWasEmpty) Plotly.Axes.saveRangeInitial(gd);
	
	    var fullLayout = gd._fullLayout;
	
	    // prepare the data and find the autorange
	
	    // generate calcdata, if we need to
	    // to force redoing calcdata, just delete it before calling Plotly.plot
	    var recalc = !gd.calcdata || gd.calcdata.length !== (gd.data || []).length;
	    if(recalc) doCalcdata(gd);
	
	    // in case it has changed, attach fullData traces to calcdata
	    for(var i = 0; i < gd.calcdata.length; i++) {
	        gd.calcdata[i][0].trace = gd._fullData[i];
	    }
	
	    /*
	     * start async-friendly code - now we're actually drawing things
	     */
	
	    var oldmargins = JSON.stringify(fullLayout._size);
	
	    // draw anything that can affect margins.
	    // currently this is legend and colorbars
	    function marginPushers() {
	        var calcdata = gd.calcdata;
	        var i, cd, trace;
	
	        Legend.draw(gd);
	        RangeSelector.draw(gd);
	
	        for(i = 0; i < calcdata.length; i++) {
	            cd = calcdata[i];
	            trace = cd[0].trace;
	            if(trace.visible !== true || !trace._module.colorbar) {
	                Plots.autoMargin(gd, 'cb'+trace.uid);
	            }
	            else trace._module.colorbar(gd, cd);
	        }
	
	        Plots.doAutoMargin(gd);
	        return Plots.previousPromises(gd);
	    }
	
	    function marginPushersAgain() {
	        // in case the margins changed, draw margin pushers again
	        var seq = JSON.stringify(fullLayout._size)===oldmargins ?
	            [] : [marginPushers, layoutStyles];
	        return Lib.syncOrAsync(seq.concat(Fx.init),gd);
	    }
	
	    function positionAndAutorange() {
	        if(!recalc) return;
	
	        var subplots = Plots.getSubplotIds(fullLayout, 'cartesian'),
	            modules = fullLayout._modules;
	
	        // position and range calculations for traces that
	        // depend on each other ie bars (stacked or grouped)
	        // and boxes (grouped) push each other out of the way
	
	        var subplotInfo, _module;
	
	        for(var i = 0; i < subplots.length; i++) {
	            subplotInfo = fullLayout._plots[subplots[i]];
	
	            for(var j = 0; j < modules.length; j++) {
	                _module = modules[j];
	                if(_module.setPositions) _module.setPositions(gd, subplotInfo);
	            }
	        }
	
	        Lib.markTime('done with bar/box adjustments');
	
	        // calc and autorange for errorbars
	        ErrorBars.calc(gd);
	        Lib.markTime('done ErrorBars.calc');
	
	        // TODO: autosize extra for text markers
	        return Lib.syncOrAsync([
	            Shapes.calcAutorange,
	            Plotly.Annotations.calcAutorange,
	            doAutoRange
	        ], gd);
	    }
	
	    function doAutoRange() {
	        var axList = Plotly.Axes.list(gd, '', true);
	        for(var i = 0; i < axList.length; i++) {
	            Plotly.Axes.doAutoRange(axList[i]);
	        }
	    }
	
	    function drawAxes() {
	        // draw ticks, titles, and calculate axis scaling (._b, ._m)
	        return Plotly.Axes.doTicks(gd, 'redraw');
	    }
	
	    // Now plot the data
	    function drawData() {
	        var calcdata = gd.calcdata,
	            i;
	
	        // in case of traces that were heatmaps or contour maps
	        // previously, remove them and their colorbars explicitly
	        for(i = 0; i < calcdata.length; i++) {
	            var trace = calcdata[i][0].trace,
	                isVisible = (trace.visible === true),
	                uid = trace.uid;
	
	            if(!isVisible || !Plots.traceIs(trace, '2dMap')) {
	                fullLayout._paper.selectAll(
	                    '.hm' + uid +
	                    ',.contour' + uid +
	                    ',#clip' + uid
	                ).remove();
	            }
	
	            if(!isVisible || !trace._module.colorbar) {
	                fullLayout._infolayer.selectAll('.cb' + uid).remove();
	            }
	        }
	
	        // loop over the base plot modules present on graph
	        var basePlotModules = fullLayout._basePlotModules;
	        for(i = 0; i < basePlotModules.length; i++) {
	            basePlotModules[i].plot(gd);
	        }
	
	        // styling separate from drawing
	        Plots.style(gd);
	        Lib.markTime('done Plots.style');
	
	        // show annotations and shapes
	        Shapes.drawAll(gd);
	        Plotly.Annotations.drawAll(gd);
	
	        // source links
	        Plots.addLinks(gd);
	
	        // Mark the first render as complete
	        gd._replotting = false;
	
	        return Plots.previousPromises(gd);
	    }
	
	    // An initial paint must be completed before these components can be
	    // correctly sized and the whole plot re-margined. gd._replotting must
	    // be set to false before these will work properly.
	    function finalDraw() {
	        Shapes.drawAll(gd);
	        Images.draw(gd);
	        Plotly.Annotations.drawAll(gd);
	        Legend.draw(gd);
	        RangeSlider.draw(gd);
	        RangeSelector.draw(gd);
	    }
	
	    function cleanUp() {
	        // now we're REALLY TRULY done plotting...
	        // so mark it as done and let other procedures call a replot
	        Lib.markTime('done plot');
	        gd.emit('plotly_afterplot');
	    }
	
	    Lib.syncOrAsync([
	        Plots.previousPromises,
	        marginPushers,
	        marginPushersAgain,
	        positionAndAutorange,
	        layoutStyles,
	        drawAxes,
	        drawData,
	        finalDraw
	    ], gd, cleanUp);
	
	    // even if everything we did was synchronous, return a promise
	    // so that the caller doesn't care which route we took
	    return Promise.all(gd._promises).then(function() {
	        return gd;
	    });
	};
	
	// Get the container div: we store all variables for this plot as
	// properties of this div
	// some callers send this in by DOM element, others by id (string)
	function getGraphDiv(gd) {
	    var gdElement;
	
	    if(typeof gd === 'string') {
	        gdElement = document.getElementById(gd);
	
	        if(gdElement === null) {
	            throw new Error('No DOM element with id \'' + gd + '\' exists on the page.');
	        }
	
	        return gdElement;
	    }
	    else if(gd===null || gd===undefined) {
	        throw new Error('DOM element provided is null or undefined');
	    }
	
	    return gd;  // otherwise assume that gd is a DOM element
	}
	
	function opaqueSetBackground(gd, bgColor) {
	    gd._fullLayout._paperdiv.style('background', 'white');
	    Plotly.defaultConfig.setBackground(gd, bgColor);
	}
	
	function setPlotContext(gd, config) {
	    if(!gd._context) gd._context = Lib.extendFlat({}, Plotly.defaultConfig);
	    var context = gd._context;
	
	    if(config) {
	        Object.keys(config).forEach(function(key) {
	            if(key in context) {
	                if(key === 'setBackground' && config[key] === 'opaque') {
	                    context[key] = opaqueSetBackground;
	                }
	                else context[key] = config[key];
	            }
	        });
	
	        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility
	        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {
	            context.plotGlPixelRatio = context.plot3dPixelRatio;
	        }
	    }
	
	    //staticPlot forces a bunch of others:
	    if(context.staticPlot) {
	        context.editable = false;
	        context.autosizable = false;
	        context.scrollZoom = false;
	        context.doubleClick = false;
	        context.showTips = false;
	        context.showLink = false;
	        context.displayModeBar = false;
	    }
	}
	
	function plotPolar(gd, data, layout) {
	    // build or reuse the container skeleton
	    var plotContainer = d3.select(gd).selectAll('.plot-container')
	        .data([0]);
	    plotContainer.enter()
	        .insert('div', ':first-child')
	        .classed('plot-container plotly', true);
	    var paperDiv = plotContainer.selectAll('.svg-container')
	        .data([0]);
	    paperDiv.enter().append('div')
	        .classed('svg-container',true)
	        .style('position','relative');
	
	    // empty it everytime for now
	    paperDiv.html('');
	
	    // fulfill gd requirements
	    if(data) gd.data = data;
	    if(layout) gd.layout = layout;
	    Plotly.micropolar.manager.fillLayout(gd);
	
	    if(gd._fullLayout.autosize === 'initial' && gd._context.autosizable) {
	        plotAutoSize(gd,{});
	        gd._fullLayout.autosize = layout.autosize = true;
	    }
	    // resize canvas
	    paperDiv.style({
	        width: gd._fullLayout.width + 'px',
	        height: gd._fullLayout.height + 'px'
	    });
	
	    // instantiate framework
	    gd.framework = Plotly.micropolar.manager.framework(gd);
	
	    // plot
	    gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());
	
	    // set undo point
	    gd.framework.setUndoPoint();
	
	    // get the resulting svg for extending it
	    var polarPlotSVG = gd.framework.svg();
	
	    // editable title
	    var opacity = 1;
	    var txt = gd._fullLayout.title;
	    if(txt === '' || !txt) opacity = 0;
	    var placeholderText = 'Click to enter title';
	
	    var titleLayout = function() {
	        this.call(Plotly.util.convertToTspans);
	        //TODO: html/mathjax
	        //TODO: center title
	    };
	
	    var title = polarPlotSVG.select('.title-group text')
	        .call(titleLayout);
	
	    if(gd._context.editable) {
	        title.attr({'data-unformatted': txt});
	        if(!txt || txt === placeholderText) {
	            opacity = 0.2;
	            title.attr({'data-unformatted': placeholderText})
	                .text(placeholderText)
	                .style({opacity: opacity})
	                .on('mouseover.opacity',function() {
	                    d3.select(this).transition().duration(100)
	                        .style('opacity',1);
	                })
	                .on('mouseout.opacity',function() {
	                    d3.select(this).transition().duration(1000)
	                        .style('opacity',0);
	                });
	        }
	
	        var setContenteditable = function() {
	            this.call(Plotly.util.makeEditable)
	                .on('edit', function(text) {
	                    gd.framework({layout: {title: text}});
	                    this.attr({'data-unformatted': text})
	                        .text(text)
	                        .call(titleLayout);
	                    this.call(setContenteditable);
	                })
	                .on('cancel', function() {
	                    var txt = this.attr('data-unformatted');
	                    this.text(txt).call(titleLayout);
	                });
	        };
	        title.call(setContenteditable);
	    }
	
	    gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);
	    Plots.addLinks(gd);
	
	    return Promise.resolve();
	}
	
	function cleanLayout(layout) {
	    // make a few changes to the layout right away
	    // before it gets used for anything
	    // backward compatibility and cleanup of nonstandard options
	    var i, j;
	
	    if(!layout) layout = {};
	
	    // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...
	    if(layout.xaxis1) {
	        if(!layout.xaxis) layout.xaxis = layout.xaxis1;
	        delete layout.xaxis1;
	    }
	    if(layout.yaxis1) {
	        if(!layout.yaxis) layout.yaxis = layout.yaxis1;
	        delete layout.yaxis1;
	    }
	
	    var axList = Plotly.Axes.list({_fullLayout: layout});
	    for(i = 0; i < axList.length; i++) {
	        var ax = axList[i];
	        if(ax.anchor && ax.anchor !== 'free') {
	            ax.anchor = Plotly.Axes.cleanId(ax.anchor);
	        }
	        if(ax.overlaying) ax.overlaying = Plotly.Axes.cleanId(ax.overlaying);
	
	        // old method of axis type - isdate and islog (before category existed)
	        if(!ax.type) {
	            if(ax.isdate) ax.type='date';
	            else if(ax.islog) ax.type='log';
	            else if(ax.isdate===false && ax.islog===false) ax.type='linear';
	        }
	        if(ax.autorange==='withzero' || ax.autorange==='tozero') {
	            ax.autorange = true;
	            ax.rangemode = 'tozero';
	        }
	        delete ax.islog;
	        delete ax.isdate;
	        delete ax.categories; // replaced by _categories
	
	        // prune empty domain arrays made before the new nestedProperty
	        if(emptyContainer(ax, 'domain')) delete ax.domain;
	
	        // autotick -> tickmode
	        if(ax.autotick !== undefined) {
	            if(ax.tickmode === undefined) {
	                ax.tickmode = ax.autotick ? 'auto' : 'linear';
	            }
	            delete ax.autotick;
	        }
	    }
	
	    if(layout.annotations !== undefined && !Array.isArray(layout.annotations)) {
	        console.log('annotations must be an array');
	        delete layout.annotations;
	    }
	    var annotationsLen = (layout.annotations || []).length;
	    for(i = 0; i < annotationsLen; i++) {
	        var ann = layout.annotations[i];
	        if(ann.ref) {
	            if(ann.ref==='paper') {
	                ann.xref = 'paper';
	                ann.yref = 'paper';
	            }
	            else if(ann.ref==='data') {
	                ann.xref = 'x';
	                ann.yref = 'y';
	            }
	            delete ann.ref;
	        }
	        cleanAxRef(ann, 'xref');
	        cleanAxRef(ann, 'yref');
	    }
	
	    if(layout.shapes !== undefined && !Array.isArray(layout.shapes)) {
	        console.log('shapes must be an array');
	        delete layout.shapes;
	    }
	    var shapesLen = (layout.shapes||[]).length;
	    for(i = 0; i < shapesLen; i++) {
	        var shape = layout.shapes[i];
	        cleanAxRef(shape, 'xref');
	        cleanAxRef(shape, 'yref');
	    }
	
	    var legend = layout.legend;
	    if(legend) {
	        // check for old-style legend positioning (x or y is +/- 100)
	        if(legend.x > 3) {
	            legend.x = 1.02;
	            legend.xanchor = 'left';
	        }
	        else if(legend.x < -2) {
	            legend.x = -0.02;
	            legend.xanchor = 'right';
	        }
	
	        if(legend.y > 3) {
	            legend.y = 1.02;
	            legend.yanchor = 'bottom';
	        }
	        else if(legend.y < -2) {
	            legend.y = -0.02;
	            legend.yanchor = 'top';
	        }
	    }
	
	    /*
	     * Moved from rotate -> orbit for dragmode
	     */
	    if(layout.dragmode === 'rotate') layout.dragmode = 'orbit';
	
	    // cannot have scene1, numbering goes scene, scene2, scene3...
	    if(layout.scene1) {
	        if(!layout.scene) layout.scene = layout.scene1;
	        delete layout.scene1;
	    }
	
	    /*
	     * Clean up Scene layouts
	     */
	    var sceneIds = Plots.getSubplotIds(layout, 'gl3d');
	    for(i = 0; i < sceneIds.length; i++) {
	        var scene = layout[sceneIds[i]];
	
	        // clean old Camera coords
	        var cameraposition = scene.cameraposition;
	        if(Array.isArray(cameraposition) && cameraposition[0].length === 4) {
	            var rotation = cameraposition[0],
	                center = cameraposition[1],
	                radius = cameraposition[2],
	                mat = m4FromQuat([], rotation),
	                eye = [];
	
	            for(j = 0; j < 3; ++j) {
	                eye[j] = center[i] + radius * mat[2 + 4 * j];
	            }
	
	            scene.camera = {
	                eye: {x: eye[0], y: eye[1], z: eye[2]},
	                center: {x: center[0], y: center[1], z: center[2]},
	                up: {x: mat[1], y: mat[5], z: mat[9]}
	            };
	
	            delete scene.cameraposition;
	        }
	    }
	
	    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor
	    // supported, but new tinycolor does not because they're not valid css
	    Lib.markTime('finished rest of cleanLayout, starting color');
	    Color.clean(layout);
	    Lib.markTime('finished cleanLayout color.clean');
	
	    return layout;
	}
	
	function cleanAxRef(container, attr) {
	    var valIn = container[attr],
	        axLetter = attr.charAt(0);
	    if(valIn && valIn !== 'paper') {
	        container[attr] = Plotly.Axes.cleanId(valIn, axLetter);
	    }
	}
	
	// Make a few changes to the data right away
	// before it gets used for anything
	function cleanData(data, existingData) {
	
	    // Enforce unique IDs
	    var suids = [], // seen uids --- so we can weed out incoming repeats
	        uids = data.concat(Array.isArray(existingData) ? existingData : [])
	               .filter(function(trace) { return 'uid' in trace; })
	               .map(function(trace) { return trace.uid; });
	
	    for(var tracei = 0; tracei < data.length; tracei++) {
	        var trace = data[tracei];
	        var i;
	
	        // assign uids to each trace and detect collisions.
	        if(!('uid' in trace) || suids.indexOf(trace.uid) !== -1) {
	            var newUid;
	
	            for(i = 0; i < 100; i++) {
	                newUid = Lib.randstr(uids);
	                if(suids.indexOf(newUid)===-1) break;
	            }
	            trace.uid = Lib.randstr(uids);
	            uids.push(trace.uid);
	        }
	        // keep track of already seen uids, so that if there are
	        // doubles we force the trace with a repeat uid to
	        // acquire a new one
	        suids.push(trace.uid);
	
	        // BACKWARD COMPATIBILITY FIXES
	
	        // use xbins to bin data in x, and ybins to bin data in y
	        if(trace.type==='histogramy' && 'xbins' in trace && !('ybins' in trace)) {
	            trace.ybins = trace.xbins;
	            delete trace.xbins;
	        }
	
	        // error_y.opacity is obsolete - merge into color
	        if(trace.error_y && 'opacity' in trace.error_y) {
	            var dc = Color.defaults,
	                yeColor = trace.error_y.color ||
	                (Plots.traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);
	            trace.error_y.color = Color.addOpacity(
	                Color.rgb(yeColor),
	                Color.opacity(yeColor) * trace.error_y.opacity);
	            delete trace.error_y.opacity;
	        }
	
	        // convert bardir to orientation, and put the data into
	        // the axes it's eventually going to be used with
	        if('bardir' in trace) {
	            if(trace.bardir==='h' && (Plots.traceIs(trace, 'bar') ||
	                     trace.type.substr(0,9)==='histogram')) {
	                trace.orientation = 'h';
	                swapXYData(trace);
	            }
	            delete trace.bardir;
	        }
	
	        // now we have only one 1D histogram type, and whether
	        // it uses x or y data depends on trace.orientation
	        if(trace.type==='histogramy') swapXYData(trace);
	        if(trace.type==='histogramx' || trace.type==='histogramy') {
	            trace.type = 'histogram';
	        }
	
	        // scl->scale, reversescl->reversescale
	        if('scl' in trace) {
	            trace.colorscale = trace.scl;
	            delete trace.scl;
	        }
	        if('reversescl' in trace) {
	            trace.reversescale = trace.reversescl;
	            delete trace.reversescl;
	        }
	
	        // axis ids x1 -> x, y1-> y
	        if(trace.xaxis) trace.xaxis = Plotly.Axes.cleanId(trace.xaxis, 'x');
	        if(trace.yaxis) trace.yaxis = Plotly.Axes.cleanId(trace.yaxis, 'y');
	
	        // scene ids scene1 -> scene
	        if(Plots.traceIs(trace, 'gl3d') && trace.scene) {
	            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
	        }
	
	        if(!Plots.traceIs(trace, 'pie')) {
	            if(Array.isArray(trace.textposition)) {
	                trace.textposition = trace.textposition.map(cleanTextPosition);
	            }
	            else if(trace.textposition) {
	                trace.textposition = cleanTextPosition(trace.textposition);
	            }
	        }
	
	        // fix typo in colorscale definition
	        if(Plots.traceIs(trace, '2dMap')) {
	            if(trace.colorscale === 'YIGnBu') trace.colorscale = 'YlGnBu';
	            if(trace.colorscale === 'YIOrRd') trace.colorscale = 'YlOrRd';
	        }
	        if(Plots.traceIs(trace, 'markerColorscale') && trace.marker) {
	            var cont = trace.marker;
	            if(cont.colorscale === 'YIGnBu') cont.colorscale = 'YlGnBu';
	            if(cont.colorscale === 'YIOrRd') cont.colorscale = 'YlOrRd';
	        }
	
	        // fix typo in surface 'highlight*' definitions
	        if(trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {
	            var dims = ['x', 'y', 'z'];
	
	            for(i = 0; i < dims.length; i++) {
	                var opts = trace.contours[dims[i]];
	
	                if(!Lib.isPlainObject(opts)) continue;
	
	                if(opts.highlightColor) {
	                    opts.highlightcolor = opts.highlightColor;
	                    delete opts.highlightColor;
	                }
	
	                if(opts.highlightWidth) {
	                    opts.highlightwidth = opts.highlightWidth;
	                    delete opts.highlightWidth;
	                }
	            }
	        }
	
	        // prune empty containers made before the new nestedProperty
	        if(emptyContainer(trace, 'line')) delete trace.line;
	        if('marker' in trace) {
	            if(emptyContainer(trace.marker, 'line')) delete trace.marker.line;
	            if(emptyContainer(trace, 'marker')) delete trace.marker;
	        }
	
	        // sanitize rgb(fractions) and rgba(fractions) that old tinycolor
	        // supported, but new tinycolor does not because they're not valid css
	        Lib.markTime('finished rest of cleanData, starting color');
	        Color.clean(trace);
	        Lib.markTime('finished cleanData color.clean');
	    }
	}
	
	// textposition - support partial attributes (ie just 'top')
	// and incorrect use of middle / center etc.
	function cleanTextPosition(textposition) {
	    var posY = 'middle',
	        posX = 'center';
	    if(textposition.indexOf('top')!==-1) posY = 'top';
	    else if(textposition.indexOf('bottom')!==-1) posY = 'bottom';
	
	    if(textposition.indexOf('left')!==-1) posX = 'left';
	    else if(textposition.indexOf('right')!==-1) posX = 'right';
	
	    return posY + ' ' + posX;
	}
	
	function emptyContainer(outer, innerStr) {
	    return (innerStr in outer) &&
	        (typeof outer[innerStr] === 'object') &&
	        (Object.keys(outer[innerStr]).length === 0);
	}
	
	// convenience function to force a full redraw, mostly for use by plotly.js
	Plotly.redraw = function(gd) {
	    gd = getGraphDiv(gd);
	
	    if(!Lib.isPlotDiv(gd)) {
	        console.log('This element is not a Plotly Plot', gd);
	        return;
	    }
	
	    gd.calcdata = undefined;
	    return Plotly.plot(gd).then(function() {
	        gd.emit('plotly_redraw');
	        return gd;
	    });
	};
	
	/**
	 * Convenience function to make idempotent plot option obvious to users.
	 *
	 * @param gd
	 * @param {Object[]} data
	 * @param {Object} layout
	 * @param {Object} config
	 */
	Plotly.newPlot = function(gd, data, layout, config) {
	    gd = getGraphDiv(gd);
	    Plots.purge(gd);
	    return Plotly.plot(gd, data, layout, config);
	};
	
	function doCalcdata(gd) {
	    var axList = Plotly.Axes.list(gd),
	        fullData = gd._fullData,
	        fullLayout = gd._fullLayout;
	
	    var i, trace, module, cd;
	
	    var calcdata = gd.calcdata = new Array(fullData.length);
	
	    // extra helper variables
	    // firstscatter: fill-to-next on the first trace goes to zero
	    gd.firstscatter = true;
	
	    // how many box plots do we have (in case they're grouped)
	    gd.numboxes = 0;
	
	    // for calculating avg luminosity of heatmaps
	    gd._hmpixcount = 0;
	    gd._hmlumcount = 0;
	
	    // for sharing colors across pies (and for legend)
	    fullLayout._piecolormap = {};
	    fullLayout._piedefaultcolorcount = 0;
	
	    // initialize the category list, if there is one, so we start over
	    // to be filled in later by ax.d2c
	    for(i = 0; i < axList.length; i++) {
	        axList[i]._categories = axList[i]._initialCategories.slice();
	    }
	
	    for(i = 0; i < fullData.length; i++) {
	        trace = fullData[i];
	        module = trace._module;
	        cd = [];
	
	        if(module && trace.visible === true) {
	            if(module.calc) cd = module.calc(gd, trace);
	        }
	
	        // make sure there is a first point
	        // this ensures there is a calcdata item for every trace,
	        // even if cartesian logic doesn't handle it
	        if(!Array.isArray(cd) || !cd[0]) cd = [{x: false, y: false}];
	
	        // add the trace-wide properties to the first point,
	        // per point properties to every point
	        // t is the holder for trace-wide properties
	        if(!cd[0].t) cd[0].t = {};
	        cd[0].trace = trace;
	
	        Lib.markTime('done with calcdata for '+i);
	        calcdata[i] = cd;
	    }
	}
	
	/**
	 * Wrap negative indicies to their positive counterparts.
	 *
	 * @param {Number[]} indices An array of indices
	 * @param {Number} maxIndex The maximum index allowable (arr.length - 1)
	 */
	function positivifyIndices(indices, maxIndex) {
	    var parentLength = maxIndex + 1,
	        positiveIndices = [],
	        i,
	        index;
	
	    for(i = 0; i < indices.length; i++) {
	        index = indices[i];
	        if(index < 0) {
	            positiveIndices.push(parentLength + index);
	        } else {
	            positiveIndices.push(index);
	        }
	    }
	    return positiveIndices;
	}
	
	/**
	 * Ensures that an index array for manipulating gd.data is valid.
	 *
	 * Intended for use with addTraces, deleteTraces, and moveTraces.
	 *
	 * @param gd
	 * @param indices
	 * @param arrayName
	 */
	function assertIndexArray(gd, indices, arrayName) {
	    var i,
	        index;
	
	    for(i = 0; i < indices.length; i++) {
	        index = indices[i];
	
	        // validate that indices are indeed integers
	        if(index !== parseInt(index, 10)) {
	            throw new Error('all values in ' + arrayName + ' must be integers');
	        }
	
	        // check that all indices are in bounds for given gd.data array length
	        if(index >= gd.data.length || index < -gd.data.length) {
	            throw new Error(arrayName + ' must be valid indices for gd.data.');
	        }
	
	        // check that indices aren't repeated
	        if(indices.indexOf(index, i + 1) > -1 ||
	                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||
	                index < 0 && indices.indexOf(gd.data.length + index) > -1) {
	            throw new Error('each index in ' + arrayName + ' must be unique.');
	        }
	    }
	}
	
	/**
	 * Private function used by Plotly.moveTraces to check input args
	 *
	 * @param gd
	 * @param currentIndices
	 * @param newIndices
	 */
	function checkMoveTracesArgs(gd, currentIndices, newIndices) {
	
	    // check that gd has attribute 'data' and 'data' is array
	    if(!Array.isArray(gd.data)) {
	        throw new Error('gd.data must be an array.');
	    }
	
	    // validate currentIndices array
	    if(typeof currentIndices === 'undefined') {
	        throw new Error('currentIndices is a required argument.');
	    } else if(!Array.isArray(currentIndices)) {
	        currentIndices = [currentIndices];
	    }
	    assertIndexArray(gd, currentIndices, 'currentIndices');
	
	    // validate newIndices array if it exists
	    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {
	        newIndices = [newIndices];
	    }
	    if(typeof newIndices !== 'undefined') {
	        assertIndexArray(gd, newIndices, 'newIndices');
	    }
	
	    // check currentIndices and newIndices are the same length if newIdices exists
	    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {
	        throw new Error('current and new indices must be of equal length.');
	    }
	
	}
	/**
	 * A private function to reduce the type checking clutter in addTraces.
	 *
	 * @param gd
	 * @param traces
	 * @param newIndices
	 */
	function checkAddTracesArgs(gd, traces, newIndices) {
	    var i,
	        value;
	
	    // check that gd has attribute 'data' and 'data' is array
	    if(!Array.isArray(gd.data)) {
	        throw new Error('gd.data must be an array.');
	    }
	
	    // make sure traces exists
	    if(typeof traces === 'undefined') {
	        throw new Error('traces must be defined.');
	    }
	
	    // make sure traces is an array
	    if(!Array.isArray(traces)) {
	        traces = [traces];
	    }
	
	    // make sure each value in traces is an object
	    for(i = 0; i < traces.length; i++) {
	        value = traces[i];
	        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {
	            throw new Error('all values in traces array must be non-array objects');
	        }
	    }
	
	    // make sure we have an index for each trace
	    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {
	        newIndices = [newIndices];
	    }
	    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {
	        throw new Error(
	            'if indices is specified, traces.length must equal indices.length'
	        );
	    }
	}
	
	/**
	 * A private function to reduce the type checking clutter in spliceTraces.
	 * Get all update Properties from gd.data. Validate inputs and outputs.
	 * Used by prependTrace and extendTraces
	 *
	 * @param gd
	 * @param update
	 * @param indices
	 * @param maxPoints
	 */
	function assertExtendTracesArgs(gd, update, indices, maxPoints) {
	
	    var maxPointsIsObject = Lib.isPlainObject(maxPoints);
	
	    if(!Array.isArray(gd.data)) {
	        throw new Error('gd.data must be an array');
	    }
	    if(!Lib.isPlainObject(update)) {
	        throw new Error('update must be a key:value object');
	    }
	
	    if(typeof indices === 'undefined') {
	        throw new Error('indices must be an integer or array of integers');
	    }
	
	    assertIndexArray(gd, indices, 'indices');
	
	    for(var key in update) {
	
	        /*
	         * Verify that the attribute to be updated contains as many trace updates
	         * as indices. Failure must result in throw and no-op
	         */
	        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {
	            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');
	        }
	
	        /*
	         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1
	         */
	        if(maxPointsIsObject &&
	            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||
	            maxPoints[key].length !== update[key].length)) {
	            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +
	                            'corrispondence with the keys and number of traces in the update object');
	        }
	    }
	}
	
	/**
	 * A private function to reduce the type checking clutter in spliceTraces.
	 *
	 * @param {Object|HTMLDivElement} gd
	 * @param {Object} update
	 * @param {Number[]} indices
	 * @param {Number||Object} maxPoints
	 * @return {Object[]}
	 */
	function getExtendProperties(gd, update, indices, maxPoints) {
	
	    var maxPointsIsObject = Lib.isPlainObject(maxPoints),
	        updateProps = [];
	    var trace, target, prop, insert, maxp;
	
	    // allow scalar index to represent a single trace position
	    if(!Array.isArray(indices)) indices = [indices];
	
	    // negative indices are wrapped around to their positive value. Equivalent to python indexing.
	    indices = positivifyIndices(indices, gd.data.length - 1);
	
	    // loop through all update keys and traces and harvest validated data.
	    for(var key in update) {
	
	        for(var j = 0; j < indices.length; j++) {
	
	            /*
	             * Choose the trace indexed by the indices map argument and get the prop setter-getter
	             * instance that references the key and value for this particular trace.
	             */
	            trace = gd.data[indices[j]];
	            prop = Lib.nestedProperty(trace, key);
	
	            /*
	             * Target is the existing gd.data.trace.dataArray value like "x" or "marker.size"
	             * Target must exist as an Array to allow the extend operation to be performed.
	             */
	            target = prop.get();
	            insert = update[key][j];
	
	            if(!Array.isArray(insert)) {
	                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');
	            }
	            if(!Array.isArray(target)) {
	                throw new Error('cannot extend missing or non-array attribute: ' + key);
	            }
	
	            /*
	             * maxPoints may be an object map or a scalar. If object select the key:value, else
	             * Use the scalar maxPoints for all key and trace combinations.
	             */
	            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;
	
	            // could have chosen null here, -1 just tells us to not take a window
	            if(!isNumeric(maxp)) maxp = -1;
	
	            /*
	             * Wrap the nestedProperty in an object containing required data
	             * for lengthening and windowing this particular trace - key combination.
	             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.
	             */
	            updateProps.push({
	                prop: prop,
	                target: target,
	                insert: insert,
	                maxp: Math.floor(maxp)
	            });
	        }
	    }
	
	    // all target and insertion data now validated
	    return updateProps;
	}
	
	/**
	 * A private function to key Extend and Prepend traces DRY
	 *
	 * @param {Object|HTMLDivElement} gd
	 * @param {Object} update
	 * @param {Number[]} indices
	 * @param {Number||Object} maxPoints
	 * @param {Function} lengthenArray
	 * @param {Function} spliceArray
	 * @return {Object}
	 */
	function spliceTraces(gd, update, indices, maxPoints, lengthenArray, spliceArray) {
	
	    assertExtendTracesArgs(gd, update, indices, maxPoints);
	
	    var updateProps = getExtendProperties(gd, update, indices, maxPoints),
	        remainder = [],
	        undoUpdate = {},
	        undoPoints = {};
	    var target, prop, maxp;
	
	    for(var i = 0; i < updateProps.length; i++) {
	
	        /*
	         * prop is the object returned by Lib.nestedProperties
	         */
	        prop = updateProps[i].prop;
	        maxp = updateProps[i].maxp;
	
	        target = lengthenArray(updateProps[i].target, updateProps[i].insert);
	
	        /*
	         * If maxp is set within post-extension trace.length, splice to maxp length.
	         * Otherwise skip function call as splice op will have no effect anyway.
	         */
	        if(maxp >= 0 && maxp < target.length) remainder = spliceArray(target, maxp);
	
	        /*
	         * to reverse this operation we need the size of the original trace as the reverse
	         * operation will need to window out any lengthening operation performed in this pass.
	         */
	        maxp = updateProps[i].target.length;
	
	        /*
	         * Magic happens here! update gd.data.trace[key] with new array data.
	         */
	        prop.set(target);
	
	        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];
	        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];
	
	        /*
	         * build the inverse update object for the undo operation
	         */
	        undoUpdate[prop.astr].push(remainder);
	
	        /*
	         * build the matching maxPoints undo object containing original trace lengths.
	         */
	        undoPoints[prop.astr].push(maxp);
	    }
	
	    return {update: undoUpdate, maxPoints: undoPoints};
	}
	
	/**
	 * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints
	 *
	 * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend
	 * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints
	 * from the head, whereas Extend truncates the head of the array, counting backward maxPoints
	 * from the tail.
	 *
	 * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no
	 * truncation / windowing will be performed. If its zero, well the whole trace is truncated.
	 *
	 * @param {Object|HTMLDivElement} gd The graph div
	 * @param {Object} update The key:array map of target attributes to extend
	 * @param {Number|Number[]} indices The locations of traces to be extended
	 * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.
	 *
	 */
	Plotly.extendTraces = function extendTraces(gd, update, indices, maxPoints) {
	    gd = getGraphDiv(gd);
	
	    var undo = spliceTraces(gd, update, indices, maxPoints,
	
	                           /*
	                            * The Lengthen operation extends trace from end with insert
	                            */
	                            function(target, insert) {
	                                return target.concat(insert);
	                            },
	
	                            /*
	                             * Window the trace keeping maxPoints, counting back from the end
	                             */
	                            function(target, maxPoints) {
	                                return target.splice(0, target.length - maxPoints);
	                            });
	
	    var promise = Plotly.redraw(gd);
	
	    var undoArgs = [gd, undo.update, indices, undo.maxPoints];
	    if(Queue) {
	        Queue.add(gd, Plotly.prependTraces, undoArgs, extendTraces, arguments);
	    }
	
	    return promise;
	};
	
	Plotly.prependTraces = function prependTraces(gd, update, indices, maxPoints) {
	    gd = getGraphDiv(gd);
	
	    var undo = spliceTraces(gd, update, indices, maxPoints,
	
	                           /*
	                            * The Lengthen operation extends trace by appending insert to start
	                            */
	                            function(target, insert) {
	                                return insert.concat(target);
	                            },
	
	                            /*
	                             * Window the trace keeping maxPoints, counting forward from the start
	                             */
	                            function(target, maxPoints) {
	                                return target.splice(maxPoints, target.length);
	                            });
	
	    var promise = Plotly.redraw(gd);
	
	    var undoArgs = [gd, undo.update, indices, undo.maxPoints];
	    if(Queue) {
	        Queue.add(gd, Plotly.extendTraces, undoArgs, prependTraces, arguments);
	    }
	
	    return promise;
	};
	
	/**
	 * Add data traces to an existing graph div.
	 *
	 * @param {Object|HTMLDivElement} gd The graph div
	 * @param {Object[]} gd.data The array of traces we're adding to
	 * @param {Object[]|Object} traces The object or array of objects to add
	 * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces
	 *
	 */
	Plotly.addTraces = function addTraces(gd, traces, newIndices) {
	    gd = getGraphDiv(gd);
	
	    var currentIndices = [],
	        undoFunc = Plotly.deleteTraces,
	        redoFunc = addTraces,
	        undoArgs = [gd, currentIndices],
	        redoArgs = [gd, traces],  // no newIndices here
	        i,
	        promise;
	
	    // all validation is done elsewhere to remove clutter here
	    checkAddTracesArgs(gd, traces, newIndices);
	
	    // make sure traces is an array
	    if(!Array.isArray(traces)) {
	        traces = [traces];
	    }
	    cleanData(traces, gd.data);
	
	    // add the traces to gd.data (no redrawing yet!)
	    for(i = 0; i < traces.length; i += 1) {
	        gd.data.push(traces[i]);
	    }
	
	    // to continue, we need to call moveTraces which requires currentIndices
	    for(i = 0; i < traces.length; i++) {
	        currentIndices.push(-traces.length + i);
	    }
	
	    // if the user didn't define newIndices, they just want the traces appended
	    // i.e., we can simply redraw and be done
	    if(typeof newIndices === 'undefined') {
	        promise = Plotly.redraw(gd);
	        if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
	        return promise;
	    }
	
	    // make sure indices is property defined
	    if(!Array.isArray(newIndices)) {
	        newIndices = [newIndices];
	    }
	
	    try {
	
	        // this is redundant, but necessary to not catch later possible errors!
	        checkMoveTracesArgs(gd, currentIndices, newIndices);
	    }
	    catch(error) {
	
	        // something went wrong, reset gd to be safe and rethrow error
	        gd.data.splice(gd.data.length - traces.length, traces.length);
	        throw error;
	    }
	
	    // if we're here, the user has defined specific places to place the new traces
	    // this requires some extra work that moveTraces will do
	    if(Queue) Queue.startSequence(gd);
	    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
	    promise = Plotly.moveTraces(gd, currentIndices, newIndices);
	    if(Queue) Queue.stopSequence(gd);
	    return promise;
	};
	
	/**
	 * Delete traces at `indices` from gd.data array.
	 *
	 * @param {Object|HTMLDivElement} gd The graph div
	 * @param {Object[]} gd.data The array of traces we're removing from
	 * @param {Number|Number[]} indices The indices
	 */
	Plotly.deleteTraces = function deleteTraces(gd, indices) {
	    gd = getGraphDiv(gd);
	
	    var traces = [],
	        undoFunc = Plotly.addTraces,
	        redoFunc = deleteTraces,
	        undoArgs = [gd, traces, indices],
	        redoArgs = [gd, indices],
	        i,
	        deletedTrace;
	
	    // make sure indices are defined
	    if(typeof indices === 'undefined') {
	        throw new Error('indices must be an integer or array of integers.');
	    } else if(!Array.isArray(indices)) {
	        indices = [indices];
	    }
	    assertIndexArray(gd, indices, 'indices');
	
	    // convert negative indices to positive indices
	    indices = positivifyIndices(indices, gd.data.length - 1);
	
	    // we want descending here so that splicing later doesn't affect indexing
	    indices.sort(Lib.sorterDes);
	    for(i = 0; i < indices.length; i += 1) {
	        deletedTrace = gd.data.splice(indices[i], 1)[0];
	        traces.push(deletedTrace);
	    }
	
	    var promise = Plotly.redraw(gd);
	
	    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
	
	    return promise;
	};
	
	/**
	 * Move traces at currentIndices array to locations in newIndices array.
	 *
	 * If newIndices is omitted, currentIndices will be moved to the end. E.g.,
	 * these are equivalent:
	 *
	 * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])
	 * Plotly.moveTraces(gd, [1, 2, 3])
	 *
	 * @param {Object|HTMLDivElement} gd The graph div
	 * @param {Object[]} gd.data The array of traces we're removing from
	 * @param {Number|Number[]} currentIndices The locations of traces to be moved
	 * @param {Number|Number[]} [newIndices] The locations to move traces to
	 *
	 * Example calls:
	 *
	 *      // move trace i to location x
	 *      Plotly.moveTraces(gd, i, x)
	 *
	 *      // move trace i to end of array
	 *      Plotly.moveTraces(gd, i)
	 *
	 *      // move traces i, j, k to end of array (i != j != k)
	 *      Plotly.moveTraces(gd, [i, j, k])
	 *
	 *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)
	 *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])
	 *
	 *      // reorder all traces (assume there are 5--a, b, c, d, e)
	 *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'
	 */
	Plotly.moveTraces = function moveTraces(gd, currentIndices, newIndices) {
	    gd = getGraphDiv(gd);
	
	    var newData = [],
	        movingTraceMap = [],
	        undoFunc = moveTraces,
	        redoFunc = moveTraces,
	        undoArgs = [gd, newIndices, currentIndices],
	        redoArgs = [gd, currentIndices, newIndices],
	        i;
	
	    // to reduce complexity here, check args elsewhere
	    // this throws errors where appropriate
	    checkMoveTracesArgs(gd, currentIndices, newIndices);
	
	    // make sure currentIndices is an array
	    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];
	
	    // if undefined, define newIndices to point to the end of gd.data array
	    if(typeof newIndices === 'undefined') {
	        newIndices = [];
	        for(i = 0; i < currentIndices.length; i++) {
	            newIndices.push(-currentIndices.length + i);
	        }
	    }
	
	    // make sure newIndices is an array if it's user-defined
	    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];
	
	    // convert negative indices to positive indices (they're the same length)
	    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
	    newIndices = positivifyIndices(newIndices, gd.data.length - 1);
	
	    // at this point, we've coerced the index arrays into predictable forms
	
	    // get the traces that aren't being moved around
	    for(i = 0; i < gd.data.length; i++) {
	
	        // if index isn't in currentIndices, include it in ignored!
	        if(currentIndices.indexOf(i) === -1) {
	            newData.push(gd.data[i]);
	        }
	    }
	
	    // get a mapping of indices to moving traces
	    for(i = 0; i < currentIndices.length; i++) {
	        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});
	    }
	
	    // reorder this mapping by newIndex, ascending
	    movingTraceMap.sort(function(a, b) {
	        return a.newIndex - b.newIndex;
	    });
	
	    // now, add the moving traces back in, in order!
	    for(i = 0; i < movingTraceMap.length; i += 1) {
	        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
	    }
	
	    gd.data = newData;
	
	    var promise = Plotly.redraw(gd);
	
	    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
	
	    return promise;
	};
	
	// -----------------------------------------------------
	// restyle and relayout: these two control all redrawing
	// for data (restyle) and everything else (relayout)
	// -----------------------------------------------------
	
	// restyle: change styling of an existing plot
	// can be called two ways:
	//
	// restyle(gd, astr, val [,traces])
	//      gd - graph div (string id or dom element)
	//      astr - attribute string (like 'marker.symbol')
	//      val - value to give this attribute
	//      traces - integer or array of integers for the traces
	//          to alter (all if omitted)
	//
	// restyle(gd, aobj [,traces])
	//      aobj - {astr1:val1, astr2:val2...} allows setting
	//          multiple attributes simultaneously
	//
	// val (or val1, val2... in the object form) can be an array,
	// to apply different values to each trace.
	// If the array is too short, it will wrap around (useful for
	// style files that want to specify cyclical default values).
	Plotly.restyle = function restyle(gd, astr, val, traces) {
	    gd = getGraphDiv(gd);
	
	    var i, fullLayout = gd._fullLayout,
	        aobj = {};
	
	    if(typeof astr === 'string') aobj[astr] = val;
	    else if(Lib.isPlainObject(astr)) {
	        aobj = astr;
	        if(traces===undefined) traces = val; // the 3-arg form
	    }
	    else {
	        console.log('restyle fail',astr,val,traces);
	        return Promise.reject();
	    }
	
	    if(Object.keys(aobj).length) gd.changed = true;
	
	    if(isNumeric(traces)) traces=[traces];
	    else if(!Array.isArray(traces) || !traces.length) {
	        traces=gd._fullData.map(function(v,i) { return i; });
	    }
	
	    // recalcAttrs attributes need a full regeneration of calcdata
	    // as well as a replot, because the right objects may not exist,
	    // or autorange may need recalculating
	    // in principle we generally shouldn't need to redo ALL traces... that's
	    // harder though.
	    var recalcAttrs = [
	        'mode','visible','type','orientation','fill',
	        'histfunc','histnorm','text',
	        'x', 'y', 'z',
	        'a', 'b', 'c',
	        'xtype','x0','dx','ytype','y0','dy','xaxis','yaxis',
	        'line.width',
	        'connectgaps', 'transpose', 'zsmooth',
	        'showscale', 'marker.showscale',
	        'zauto', 'marker.cauto',
	        'autocolorscale', 'marker.autocolorscale',
	        'colorscale', 'marker.colorscale',
	        'reversescale', 'marker.reversescale',
	        'autobinx','nbinsx','xbins','xbins.start','xbins.end','xbins.size',
	        'autobiny','nbinsy','ybins','ybins.start','ybins.end','ybins.size',
	        'autocontour','ncontours','contours','contours.coloring',
	        'error_y','error_y.visible','error_y.value','error_y.type',
	        'error_y.traceref','error_y.array','error_y.symmetric',
	        'error_y.arrayminus','error_y.valueminus','error_y.tracerefminus',
	        'error_x','error_x.visible','error_x.value','error_x.type',
	        'error_x.traceref','error_x.array','error_x.symmetric',
	        'error_x.arrayminus','error_x.valueminus','error_x.tracerefminus',
	        'swapxy','swapxyaxes','orientationaxes',
	        'marker.colors', 'values', 'labels', 'label0', 'dlabel', 'sort',
	        'textinfo', 'textposition', 'textfont.size', 'textfont.family', 'textfont.color',
	        'insidetextfont.size', 'insidetextfont.family', 'insidetextfont.color',
	        'outsidetextfont.size', 'outsidetextfont.family', 'outsidetextfont.color',
	        'hole', 'scalegroup', 'domain', 'domain.x', 'domain.y',
	        'domain.x[0]', 'domain.x[1]', 'domain.y[0]', 'domain.y[1]',
	        'tilt', 'tiltaxis', 'depth', 'direction', 'rotation', 'pull'
	    ];
	    for(i = 0; i < traces.length; i++) {
	        if(Plots.traceIs(gd._fullData[traces[i]], 'box')) {
	            recalcAttrs.push('name');
	            break;
	        }
	    }
	
	    // autorangeAttrs attributes need a full redo of calcdata
	    // only if an axis is autoranged,
	    // because .calc() is where the autorange gets determined
	    // TODO: could we break this out as well?
	    var autorangeAttrs = [
	        'marker', 'marker.size', 'textfont',
	        'boxpoints','jitter','pointpos','whiskerwidth','boxmean'
	    ];
	    // replotAttrs attributes need a replot (because different
	    // objects need to be made) but not a recalc
	    var replotAttrs = [
	        'zmin', 'zmax', 'zauto',
	        'marker.cmin', 'marker.cmax', 'marker.cauto',
	        'contours.start','contours.end','contours.size',
	        'contours.showlines',
	        'line','line.smoothing','line.shape',
	        'error_y.width','error_x.width','error_x.copy_ystyle',
	        'marker.maxdisplayed'
	    ];
	    // these ones show up in restyle because they make more sense
	    // in the style box, but they're graph-wide attributes, so set
	    // in gd.layout also axis scales and range show up here because
	    // we may need to undo them. These all trigger a recalc
	    // var layoutAttrs = [
	    //     'barmode', 'barnorm','bargap', 'bargroupgap',
	    //     'boxmode', 'boxgap', 'boxgroupgap',
	    //     '?axis.autorange', '?axis.range', '?axis.rangemode'
	    // ];
	
	    // these ones may alter the axis type
	    // (at least if the first trace is involved)
	    var axtypeAttrs = [
	        'type','x','y','x0','y0','orientation','xaxis','yaxis'
	    ];
	
	    // flags for which kind of update we need to do
	    var docalc = false,
	        docalcAutorange = false,
	        doplot = false,
	        dolayout = false,
	        dostyle = false,
	        docolorbars = false;
	    // copies of the change (and previous values of anything affected)
	    // for the undo / redo queue
	    var redoit = {},
	        undoit = {},
	        axlist,
	        flagAxForDelete = {};
	
	    // At the moment, only cartesian, pie and ternary plot types can afford
	    // to not go through a full replot
	    var doPlotWhiteList = ['cartesian', 'pie', 'ternary'];
	    fullLayout._basePlotModules.forEach(function(_module) {
	        if(doPlotWhiteList.indexOf(_module.name) === -1) doplot = true;
	    });
	
	    // make a new empty vals array for undoit
	    function a0() { return traces.map(function() { return undefined; }); }
	
	    // for autoranging multiple axes
	    function addToAxlist(axid) {
	        var axName = Plotly.Axes.id2name(axid);
	        if(axlist.indexOf(axName)===-1) { axlist.push(axName); }
	    }
	    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }
	    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }
	
	    // for attrs that interact (like scales & autoscales), save the
	    // old vals before making the change
	    // val=undefined will not set a value, just record what the value was.
	    // val=null will delete the attribute
	    // attr can be an array to set several at once (all to the same val)
	    function doextra(attr,val,i) {
	        if(Array.isArray(attr)) {
	            attr.forEach(function(a) { doextra(a,val,i); });
	            return;
	        }
	        // quit if explicitly setting this elsewhere
	        if(attr in aobj) return;
	
	        var extraparam;
	        if(attr.substr(0, 6) === 'LAYOUT') {
	            extraparam = Lib.nestedProperty(gd.layout, attr.replace('LAYOUT', ''));
	        } else {
	            extraparam = Lib.nestedProperty(gd.data[traces[i]], attr);
	        }
	
	        if(!(attr in undoit)) {
	            undoit[attr] = a0();
	        }
	        if(undoit[attr][i]===undefined) {
	            undoit[attr][i]=extraparam.get();
	        }
	        if(val!==undefined) {
	            extraparam.set(val);
	        }
	    }
	    var zscl = ['zmin', 'zmax'],
	        xbins = ['xbins.start', 'xbins.end', 'xbins.size'],
	        ybins = ['ybins.start', 'ybins.end', 'ybins.size'],
	        contourAttrs = ['contours.start', 'contours.end', 'contours.size'];
	
	    // now make the changes to gd.data (and occasionally gd.layout)
	    // and figure out what kind of graphics update we need to do
	    for(var ai in aobj) {
	        var vi = aobj[ai],
	            cont,
	            contFull,
	            param,
	            oldVal,
	            newVal;
	        redoit[ai] = vi;
	
	        if(ai.substr(0,6)==='LAYOUT') {
	            param = Lib.nestedProperty(gd.layout, ai.replace('LAYOUT', ''));
	            undoit[ai] = [param.get()];
	            // since we're allowing val to be an array, allow it here too,
	            // even though that's meaningless
	            param.set(Array.isArray(vi) ? vi[0] : vi);
	            // ironically, the layout attrs in restyle only require replot,
	            // not relayout
	            docalc = true;
	            continue;
	        }
	
	        // set attribute in gd.data
	        undoit[ai] = a0();
	        for(i=0; i<traces.length; i++) {
	            cont = gd.data[traces[i]];
	            contFull = gd._fullData[traces[i]];
	            param = Lib.nestedProperty(cont,ai);
	            oldVal = param.get();
	            newVal = Array.isArray(vi) ? vi[i%vi.length] : vi;
	
	            // setting bin or z settings should turn off auto
	            // and setting auto should save bin or z settings
	            if(zscl.indexOf(ai)!==-1) {
	                doextra('zauto', false, i);
	            }
	            else if(ai === 'colorscale') {
	                doextra('autocolorscale', false, i);
	            }
	            else if(ai === 'autocolorscale') {
	                doextra('colorscale', undefined, i);
	            }
	            else if(ai === 'marker.colorscale') {
	                doextra('marker.autocolorscale', false, i);
	            }
	            else if(ai === 'marker.autocolorscale') {
	                doextra('marker.colorscale', undefined, i);
	            }
	            else if(ai==='zauto') {
	                doextra(zscl, undefined, i);
	            }
	            else if(xbins.indexOf(ai)!==-1) {
	                doextra('autobinx', false, i);
	            }
	            else if(ai==='autobinx') {
	                doextra(xbins, undefined, i);
	            }
	            else if(ybins.indexOf(ai)!==-1) {
	                doextra('autobiny', false, i);
	            }
	            else if(ai==='autobiny') {
	                doextra(ybins, undefined, i);
	            }
	            else if(contourAttrs.indexOf(ai)!==-1) {
	                doextra('autocontour', false, i);
	            }
	            else if(ai==='autocontour') {
	                doextra(contourAttrs, undefined, i);
	            }
	            // heatmaps: setting x0 or dx, y0 or dy,
	            // should turn xtype/ytype to 'scaled' if 'array'
	            else if(['x0','dx'].indexOf(ai)!==-1 &&
	                    contFull.x && contFull.xtype!=='scaled') {
	                doextra('xtype', 'scaled', i);
	            }
	            else if(['y0','dy'].indexOf(ai)!==-1 &&
	                    contFull.y && contFull.ytype!=='scaled') {
	                doextra('ytype', 'scaled', i);
	            }
	            // changing colorbar size modes,
	            // make the resulting size not change
	            // note that colorbar fractional sizing is based on the
	            // original plot size, before anything (like a colorbar)
	            // increases the margins
	            else if(ai==='colorbar.thicknessmode' && param.get() !== newVal &&
	                        ['fraction','pixels'].indexOf(newVal) !== -1 &&
	                        contFull.colorbar) {
	                var thicknorm =
	                    ['top','bottom'].indexOf(contFull.colorbar.orient)!==-1 ?
	                        (fullLayout.height - fullLayout.margin.t - fullLayout.margin.b) :
	                        (fullLayout.width - fullLayout.margin.l - fullLayout.margin.r);
	                doextra('colorbar.thickness', contFull.colorbar.thickness *
	                    (newVal === 'fraction' ? 1/thicknorm : thicknorm), i);
	            }
	            else if(ai==='colorbar.lenmode' && param.get() !== newVal &&
	                        ['fraction','pixels'].indexOf(newVal) !== -1 &&
	                        contFull.colorbar) {
	                var lennorm =
	                    ['top','bottom'].indexOf(contFull.colorbar.orient)!==-1 ?
	                        (fullLayout.width - fullLayout.margin.l - fullLayout.margin.r) :
	                        (fullLayout.height - fullLayout.margin.t - fullLayout.margin.b);
	                doextra('colorbar.len', contFull.colorbar.len *
	                    (newVal === 'fraction' ? 1/lennorm : lennorm), i);
	            }
	            else if(ai === 'colorbar.tick0' || ai === 'colorbar.dtick') {
	                doextra('colorbar.tickmode', 'linear', i);
	            }
	            else if(ai === 'colorbar.tickmode') {
	                doextra(['colorbar.tick0', 'colorbar.dtick'], undefined, i);
	            }
	
	
	            if(ai === 'type' && (newVal === 'pie') !== (oldVal === 'pie')) {
	                var labelsTo = 'x',
	                    valuesTo = 'y';
	                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {
	                    labelsTo = 'y';
	                    valuesTo = 'x';
	                }
	                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);
	                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);
	                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);
	
	                if(oldVal === 'pie') {
	                    Lib.nestedProperty(cont, 'marker.color')
	                        .set(Lib.nestedProperty(cont, 'marker.colors').get());
	
	                    // super kludgy - but if all pies are gone we won't remove them otherwise
	                    fullLayout._pielayer.selectAll('g.trace').remove();
	                } else if(Plots.traceIs(cont, 'cartesian')) {
	                    Lib.nestedProperty(cont, 'marker.colors')
	                        .set(Lib.nestedProperty(cont, 'marker.color').get());
	                    //look for axes that are no longer in use and delete them
	                    flagAxForDelete[cont.xaxis || 'x'] = true;
	                    flagAxForDelete[cont.yaxis || 'y'] = true;
	                }
	            }
	
	            undoit[ai][i] = oldVal;
	            // set the new value - if val is an array, it's one el per trace
	            // first check for attributes that get more complex alterations
	            var swapAttrs = [
	                'swapxy','swapxyaxes','orientation','orientationaxes'
	            ];
	            if(swapAttrs.indexOf(ai)!==-1) {
	                // setting an orientation: make sure it's changing
	                // before we swap everything else
	                if(ai==='orientation') {
	                    param.set(newVal);
	                    if(param.get()===undoit[ai][i]) continue;
	                }
	                // orientationaxes has no value,
	                // it flips everything and the axes
	                else if(ai==='orientationaxes') {
	                    cont.orientation =
	                        {v: 'h', h: 'v'}[contFull.orientation];
	                }
	                swapXYData(cont);
	            }
	            // all the other ones, just modify that one attribute
	            else param.set(newVal);
	
	        }
	
	        // swap the data attributes of the relevant x and y axes?
	        if(['swapxyaxes','orientationaxes'].indexOf(ai)!==-1) {
	            Plotly.Axes.swap(gd, traces);
	        }
	
	        // swap hovermode if set to "compare x/y data"
	        if(ai === 'orientationaxes') {
	            var hovermode = Lib.nestedProperty(gd.layout, 'hovermode');
	            if(hovermode.get() === 'x') {
	                hovermode.set('y');
	            } else if(hovermode.get() === 'y') {
	                hovermode.set('x');
	            }
	        }
	
	        // check if we need to call axis type
	        if((traces.indexOf(0)!==-1) && (axtypeAttrs.indexOf(ai)!==-1)) {
	            Plotly.Axes.clearTypes(gd,traces);
	            docalc = true;
	        }
	
	        // switching from auto to manual binning or z scaling doesn't
	        // actually do anything but change what you see in the styling
	        // box. everything else at least needs to apply styles
	        if((['autobinx','autobiny','zauto'].indexOf(ai)===-1) ||
	                newVal!==false) {
	            dostyle = true;
	        }
	        if(['colorbar', 'line'].indexOf(param.parts[0])!==-1 ||
	            param.parts[0]==='marker' && param.parts[1]==='colorbar') {
	            docolorbars = true;
	        }
	
	        if(recalcAttrs.indexOf(ai)!==-1) {
	            // major enough changes deserve autoscale, autobin, and
	            // non-reversed axes so people don't get confused
	            if(['orientation','type'].indexOf(ai)!==-1) {
	                axlist = [];
	                for(i=0; i<traces.length; i++) {
	                    var trace = gd.data[traces[i]];
	
	                    if(Plots.traceIs(trace, 'cartesian')) {
	                        addToAxlist(trace.xaxis||'x');
	                        addToAxlist(trace.yaxis||'y');
	
	                        if(astr === 'type') {
	                            doextra(['autobinx','autobiny'], true, i);
	                        }
	                    }
	                }
	
	                doextra(axlist.map(autorangeAttr), true, 0);
	                doextra(axlist.map(rangeAttr), [0, 1], 0);
	            }
	            docalc = true;
	        }
	        else if(replotAttrs.indexOf(ai)!==-1) doplot = true;
	        else if(autorangeAttrs.indexOf(ai)!==-1) docalcAutorange = true;
	    }
	
	    // check axes we've flagged for possible deletion
	    // flagAxForDelete is a hash so we can make sure we only get each axis once
	    var axListForDelete = Object.keys(flagAxForDelete);
	    axisLoop:
	    for(i = 0; i < axListForDelete.length; i++) {
	        var axId = axListForDelete[i],
	            axLetter = axId.charAt(0),
	            axAttr = axLetter + 'axis';
	        for(var j = 0; j < gd.data.length; j++) {
	            if(Plots.traceIs(gd.data[j], 'cartesian') &&
	                    (gd.data[j][axAttr] || axLetter) === axId) {
	                continue axisLoop;
	            }
	        }
	
	        // no data on this axis - delete it.
	        doextra('LAYOUT' + Plotly.Axes.id2name(axId), null, 0);
	    }
	
	    // now all attribute mods are done, as are redo and undo
	    // so we can save them
	    if(Queue) {
	        Queue.add(gd, restyle, [gd, undoit, traces], restyle, [gd, redoit, traces]);
	    }
	
	    // do we need to force a recalc?
	    var autorangeOn = false;
	    Plotly.Axes.list(gd).forEach(function(ax) {
	        if(ax.autorange) autorangeOn = true;
	    });
	    if(docalc || dolayout || (docalcAutorange && autorangeOn)) {
	        gd.calcdata = undefined;
	    }
	
	    // now update the graphics
	    // a complete layout redraw takes care of plot and
	    var seq;
	    if(dolayout) {
	        seq = [function changeLayout() {
	            var copyLayout = gd.layout;
	            gd.layout = undefined;
	            return Plotly.plot(gd, '', copyLayout);
	        }];
	    }
	    else if(docalc || doplot || docalcAutorange) {
	        seq = [Plotly.plot];
	    }
	    else {
	        Plots.supplyDefaults(gd);
	        seq = [Plots.previousPromises];
	        if(dostyle) {
	            seq.push(function doStyle() {
	                // first see if we need to do arraysToCalcdata
	                // call it regardless of what change we made, in case
	                // supplyDefaults brought in an array that was already
	                // in gd.data but not in gd._fullData previously
	                var i, cdi, arraysToCalcdata;
	                for(i = 0; i < gd.calcdata.length; i++) {
	                    cdi = gd.calcdata[i];
	                    arraysToCalcdata = (((cdi[0]||{}).trace||{})._module||{}).arraysToCalcdata;
	                    if(arraysToCalcdata) arraysToCalcdata(cdi);
	                }
	                Plots.style(gd);
	                Legend.draw(gd);
	                return Plots.previousPromises(gd);
	            });
	        }
	        if(docolorbars) {
	            seq.push(function doColorBars() {
	                gd.calcdata.forEach(function(cd) {
	                    if((cd[0].t || {}).cb) {
	                        var trace = cd[0].trace,
	                            cb = cd[0].t.cb;
	
	                        if(Plots.traceIs(trace, 'contour')) {
	                            cb.line({
	                                width: trace.contours.showlines!==false ?
	                                    trace.line.width : 0,
	                                dash: trace.line.dash,
	                                color: trace.contours.coloring==='line' ?
	                                    cb._opts.line.color : trace.line.color
	                            });
	                        }
	                        if(Plots.traceIs(trace, 'markerColorscale')) {
	                            cb.options(trace.marker.colorbar)();
	                        }
	                        else cb.options(trace.colorbar)();
	                    }
	                });
	                return Plots.previousPromises(gd);
	            });
	        }
	    }
	
	    var plotDone = Lib.syncOrAsync(seq, gd);
	
	    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();
	
	    return plotDone.then(function() {
	        gd.emit('plotly_restyle', Lib.extendDeep([], [redoit, traces]));
	        return gd;
	    });
	};
	
	// swap all the data and data attributes associated with x and y
	function swapXYData(trace) {
	    var i;
	    Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);
	    if(Array.isArray(trace.z) && Array.isArray(trace.z[0])) {
	        if(trace.transpose) delete trace.transpose;
	        else trace.transpose = true;
	    }
	    if(trace.error_x && trace.error_y) {
	        var errorY = trace.error_y,
	            copyYstyle = ('copy_ystyle' in errorY) ? errorY.copy_ystyle :
	                !(errorY.color || errorY.thickness || errorY.width);
	        Lib.swapAttrs(trace, ['error_?.copy_ystyle']);
	        if(copyYstyle) {
	            Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);
	        }
	    }
	    if(trace.hoverinfo) {
	        var hoverInfoParts = trace.hoverinfo.split('+');
	        for(i=0; i<hoverInfoParts.length; i++) {
	            if(hoverInfoParts[i]==='x') hoverInfoParts[i] = 'y';
	            else if(hoverInfoParts[i]==='y') hoverInfoParts[i] = 'x';
	        }
	        trace.hoverinfo = hoverInfoParts.join('+');
	    }
	}
	
	// relayout: change layout in an existing plot
	// can be called two ways:
	//
	// relayout(gd, astr, val)
	//      gd - graph div (string id or dom element)
	//      astr - attribute string (like 'xaxis.range[0]')
	//      val - value to give this attribute
	//
	// relayout(gd,aobj)
	//      aobj - {astr1:val1, astr2:val2...}
	//          allows setting multiple attributes simultaneously
	Plotly.relayout = function relayout(gd, astr, val) {
	    gd = getGraphDiv(gd);
	
	    if(gd.framework && gd.framework.isPolar) {
	        return Promise.resolve(gd);
	    }
	
	    var layout = gd.layout,
	        fullLayout = gd._fullLayout,
	        aobj = {},
	        dolegend = false,
	        doticks = false,
	        dolayoutstyle = false,
	        doplot = false,
	        docalc = false,
	        domodebar = false,
	        newkey, axes, keys, xyref, scene, axisAttr, i;
	
	    if(typeof astr === 'string') aobj[astr] = val;
	    else if(Lib.isPlainObject(astr)) aobj = astr;
	    else {
	        console.log('relayout fail',astr,val);
	        return Promise.reject();
	    }
	
	    if(Object.keys(aobj).length) gd.changed = true;
	
	    keys = Object.keys(aobj);
	    axes = Plotly.Axes.list(gd);
	
	    for(i = 0; i < keys.length; i++) {
	        // look for 'allaxes', split out into all axes
	        if(keys[i].indexOf('allaxes')===0) {
	            for(var j=0; j<axes.length; j++) {
	                // in case of 3D the axis are nested within a scene which is held in _id
	                scene = axes[j]._id.substr(1);
	                axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';
	                newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);
	                if(!aobj[newkey]) { aobj[newkey] = aobj[keys[i]]; }
	            }
	            delete aobj[keys[i]];
	        }
	        // split annotation.ref into xref and yref
	        if(keys[i].match(/^annotations\[[0-9-]+\].ref$/)) {
	            xyref = aobj[keys[i]].split('y');
	            aobj[keys[i].replace('ref','xref')] = xyref[0];
	            aobj[keys[i].replace('ref','yref')] = xyref.length===2 ?
	                ('y'+xyref[1]) : 'paper';
	            delete aobj[keys[i]];
	        }
	    }
	
	    // copies of the change (and previous values of anything affected)
	    // for the undo / redo queue
	    var redoit = {},
	        undoit = {};
	
	    // for attrs that interact (like scales & autoscales), save the
	    // old vals before making the change
	    // val=undefined will not set a value, just record what the value was.
	    // attr can be an array to set several at once (all to the same val)
	    function doextra(attr,val) {
	        if(Array.isArray(attr)) {
	            attr.forEach(function(a) { doextra(a,val); });
	            return;
	        }
	        // quit if explicitly setting this elsewhere
	        if(attr in aobj) return;
	
	        var p = Lib.nestedProperty(layout,attr);
	        if(!(attr in undoit)) undoit[attr] = p.get();
	        if(val!==undefined) p.set(val);
	    }
	
	    // for editing annotations or shapes - is it on autoscaled axes?
	    function refAutorange(obj, axletter) {
	        var axName = Plotly.Axes.id2name(obj[axletter+'ref']||axletter);
	        return (fullLayout[axName]||{}).autorange;
	    }
	
	    var hw = ['height', 'width'];
	
	    // alter gd.layout
	    for(var ai in aobj) {
	        var p = Lib.nestedProperty(layout,ai),
	            vi = aobj[ai],
	            plen = p.parts.length,
	            // p.parts may end with an index integer if the property is an array
	            pend = typeof p.parts[plen-1] === 'string' ? (plen-1) : (plen-2),
	            // last property in chain (leaf node)
	            pleaf = p.parts[pend],
	            // leaf plus immediate parent
	            pleafPlus = p.parts[pend - 1] + '.' + pleaf,
	            // trunk nodes (everything except the leaf)
	            ptrunk = p.parts.slice(0, pend).join('.'),
	            parentIn = Lib.nestedProperty(gd.layout, ptrunk).get(),
	            parentFull = Lib.nestedProperty(fullLayout, ptrunk).get();
	
	        redoit[ai] = vi;
	
	        // axis reverse is special - it is its own inverse
	        // op and has no flag.
	        undoit[ai] = (pleaf === 'reverse') ? vi : p.get();
	
	        // check autosize or autorange vs size and range
	        if(hw.indexOf(ai) !== -1) {
	            doextra('autosize', false);
	        }
	        else if(ai === 'autosize') {
	            doextra(hw, undefined);
	        }
	        else if(pleafPlus.match(/^[xyz]axis[0-9]*\.range(\[[0|1]\])?$/)) {
	            doextra(ptrunk+'.autorange', false);
	        }
	        else if(pleafPlus.match(/^[xyz]axis[0-9]*\.autorange$/)) {
	            doextra([ptrunk + '.range[0]',ptrunk + '.range[1]'],
	                undefined);
	        }
	        else if(pleafPlus.match(/^aspectratio\.[xyz]$/)) {
	            doextra(p.parts[0]+'.aspectmode', 'manual');
	        }
	        else if(pleafPlus.match(/^aspectmode$/)) {
	            doextra([ptrunk + '.x', ptrunk + '.y', ptrunk + '.z'], undefined);
	        }
	        else if(pleaf === 'tick0' || pleaf === 'dtick') {
	            doextra(ptrunk + '.tickmode', 'linear');
	        }
	        else if(pleaf === 'tickmode') {
	            doextra([ptrunk + '.tick0', ptrunk + '.dtick'], undefined);
	        }
	        else if(/[xy]axis[0-9]*?$/.test(pleaf) && !Object.keys(vi || {}).length) {
	            docalc = true;
	        }
	        else if(/[xy]axis[0-9]*\.categoryorder$/.test(pleafPlus)) {
	            docalc = true;
	        }
	        else if(/[xy]axis[0-9]*\.categoryarray/.test(pleafPlus)) {
	            docalc = true;
	        }
	
	        if(pleafPlus.indexOf('rangeslider') !== -1) {
	            docalc = true;
	        }
	
	        // toggling log without autorange: need to also recalculate ranges
	        // logical XOR (ie are we toggling log)
	        if(pleaf==='type' && ((parentFull.type === 'log') !== (vi === 'log'))) {
	            var ax = parentIn;
	            if(!ax || !ax.range) {
	                doextra(ptrunk+'.autorange', true);
	            }
	            else if(!parentFull.autorange) {
	                var r0 = ax.range[0],
	                    r1 = ax.range[1];
	                if(vi === 'log') {
	                    // if both limits are negative, autorange
	                    if(r0 <= 0 && r1 <= 0) {
	                        doextra(ptrunk+'.autorange', true);
	                    }
	                    // if one is negative, set it 6 orders below the other.
	                    if(r0 <= 0) r0 = r1/1e6;
	                    else if(r1 <= 0) r1 = r0/1e6;
	                    // now set the range values as appropriate
	                    doextra(ptrunk+'.range[0]', Math.log(r0) / Math.LN10);
	                    doextra(ptrunk+'.range[1]', Math.log(r1) / Math.LN10);
	                }
	                else {
	                    doextra(ptrunk+'.range[0]', Math.pow(10, r0));
	                    doextra(ptrunk+'.range[1]', Math.pow(10, r1));
	                }
	            }
	            else if(vi === 'log') {
	                // just make sure the range is positive and in the right
	                // order, it'll get recalculated later
	                ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];
	            }
	        }
	
	        // handle axis reversal explicitly, as there's no 'reverse' flag
	        if(pleaf ==='reverse') {
	            if(parentIn.range) parentIn.range.reverse();
	            else {
	                doextra(ptrunk+'.autorange', true);
	                parentIn.range = [1, 0];
	            }
	
	            if(parentFull.autorange) docalc = true;
	            else doplot = true;
	        }
	        // send annotation and shape mods one-by-one through Annotations.draw(),
	        // don't set via nestedProperty
	        // that's because add and remove are special
	        else if(p.parts[0] === 'annotations' || p.parts[0] === 'shapes') {
	            var objNum = p.parts[1],
	                objType = p.parts[0],
	                objList = layout[objType] || [],
	                objModule = Plotly[Lib.titleCase(objType)],
	                obji = objList[objNum] || {};
	            // if p.parts is just an annotation number, and val is either
	            // 'add' or an entire annotation to add, the undo is 'remove'
	            // if val is 'remove' then undo is the whole annotation object
	            if(p.parts.length === 2) {
	                if(aobj[ai] === 'add' || Lib.isPlainObject(aobj[ai])) {
	                    undoit[ai] = 'remove';
	                }
	                else if(aobj[ai] === 'remove') {
	                    if(objNum === -1) {
	                        undoit[objType] = objList;
	                        delete undoit[ai];
	                    }
	                    else undoit[ai] = obji;
	                }
	                else console.log('???', aobj);
	            }
	            if((refAutorange(obji, 'x') || refAutorange(obji, 'y')) &&
	                    !Lib.containsAny(ai, ['color', 'opacity', 'align', 'dash'])) {
	                docalc = true;
	            }
	            // TODO: combine all edits to a given annotation / shape into one call
	            // as it is we get separate calls for x and y (or ax and ay) on move
	            objModule.draw(gd, objNum, p.parts.slice(2).join('.'), aobj[ai]);
	            delete aobj[ai];
	        } else if(p.parts[0] === 'images') {
	            var update = Lib.objectFromPath(astr, vi);
	            Lib.extendDeepAll(gd.layout, update);
	
	            Images.supplyLayoutDefaults(gd.layout, gd._fullLayout);
	            Images.draw(gd);
	        }
	        // alter gd.layout
	        else {
	            // check whether we can short-circuit a full redraw
	            // 3d or geo at this point just needs to redraw.
	            if(p.parts[0].indexOf('scene') === 0) doplot = true;
	            else if(p.parts[0].indexOf('geo') === 0) doplot = true;
	            else if(p.parts[0].indexOf('ternary') === 0) doplot = true;
	            else if(fullLayout._has('gl2d') &&
	                (ai.indexOf('axis') !== -1 || p.parts[0] === 'plot_bgcolor')
	            ) doplot = true;
	            else if(ai === 'hiddenlabels') docalc = true;
	            else if(p.parts[0].indexOf('legend')!==-1) dolegend = true;
	            else if(ai.indexOf('title')!==-1) doticks = true;
	            else if(p.parts[0].indexOf('bgcolor')!==-1) dolayoutstyle = true;
	            else if(p.parts.length>1 &&
	                    Lib.containsAny(p.parts[1], ['tick', 'exponent', 'grid', 'zeroline'])) {
	                doticks = true;
	            }
	            else if(ai.indexOf('.linewidth')!==-1 &&
	                    ai.indexOf('axis')!==-1) {
	                doticks = dolayoutstyle = true;
	            }
	            else if(p.parts.length>1 && p.parts[1].indexOf('line')!==-1) {
	                dolayoutstyle = true;
	            }
	            else if(p.parts.length>1 && p.parts[1]==='mirror') {
	                doticks = dolayoutstyle = true;
	            }
	            else if(ai==='margin.pad') {
	                doticks = dolayoutstyle = true;
	            }
	            else if(p.parts[0]==='margin' ||
	                    p.parts[1]==='autorange' ||
	                    p.parts[1]==='rangemode' ||
	                    p.parts[1]==='type' ||
	                    p.parts[1]==='domain' ||
	                    ai.match(/^(bar|box|font)/)) {
	                docalc = true;
	            }
	            /*
	             * hovermode and dragmode don't need any redrawing, since they just
	             * affect reaction to user input. everything else, assume full replot.
	             * height, width, autosize get dealt with below. Except for the case of
	             * of subplots - scenes - which require scene.updateFx to be called.
	             */
	            else if(['hovermode', 'dragmode'].indexOf(ai) !== -1) domodebar = true;
	            else if(['hovermode','dragmode','height',
	                    'width','autosize'].indexOf(ai)===-1) {
	                doplot = true;
	            }
	
	            p.set(vi);
	        }
	    }
	    // now all attribute mods are done, as are
	    // redo and undo so we can save them
	    if(Queue) {
	        Queue.add(gd, relayout, [gd, undoit], relayout, [gd, redoit]);
	    }
	
	    // calculate autosizing - if size hasn't changed,
	    // will remove h&w so we don't need to redraw
	    if(aobj.autosize) aobj = plotAutoSize(gd,aobj);
	
	    if(aobj.height || aobj.width || aobj.autosize) docalc = true;
	
	    // redraw
	    // first check if there's still anything to do
	    var ak = Object.keys(aobj),
	        seq = [Plots.previousPromises];
	
	    if(doplot || docalc) {
	        seq.push(function layoutReplot() {
	            // force plot() to redo the layout
	            gd.layout = undefined;
	
	            // force it to redo calcdata?
	            if(docalc) gd.calcdata = undefined;
	
	            // replot with the modified layout
	            return Plotly.plot(gd, '', layout);
	        });
	    }
	    else if(ak.length) {
	        // if we didn't need to redraw entirely, just do the needed parts
	        Plots.supplyDefaults(gd);
	        fullLayout = gd._fullLayout;
	
	        if(dolegend) {
	            seq.push(function doLegend() {
	                Legend.draw(gd);
	                return Plots.previousPromises(gd);
	            });
	        }
	
	        if(dolayoutstyle) seq.push(layoutStyles);
	
	        if(doticks) {
	            seq.push(function() {
	                Plotly.Axes.doTicks(gd,'redraw');
	                drawMainTitle(gd);
	                return Plots.previousPromises(gd);
	            });
	        }
	
	        // this is decoupled enough it doesn't need async regardless
	        if(domodebar) {
	            var subplotIds;
	            manageModeBar(gd);
	
	            subplotIds = Plots.getSubplotIds(fullLayout, 'gl3d');
	            for(i = 0; i < subplotIds.length; i++) {
	                scene = fullLayout[subplotIds[i]]._scene;
	                scene.updateFx(fullLayout.dragmode, fullLayout.hovermode);
	            }
	
	            subplotIds = Plots.getSubplotIds(fullLayout, 'gl2d');
	            for(i = 0; i < subplotIds.length; i++) {
	                scene = fullLayout._plots[subplotIds[i]]._scene2d;
	                scene.updateFx(fullLayout);
	            }
	
	            subplotIds = Plots.getSubplotIds(fullLayout, 'geo');
	            for(i = 0; i < subplotIds.length; i++) {
	                var geo = fullLayout[subplotIds[i]]._geo;
	                geo.updateFx(fullLayout.hovermode);
	            }
	        }
	    }
	
	    function setRange(changes) {
	        var newMin = changes['xaxis.range[0]'],
	            newMax = changes['xaxis.range[1]'];
	
	        var rangeSlider = fullLayout.xaxis && fullLayout.xaxis.rangeslider ?
	            fullLayout.xaxis.rangeslider : {};
	
	        if(rangeSlider.visible) {
	            if(newMin || newMax) {
	                fullLayout.xaxis.rangeslider.setRange(newMin, newMax);
	            } else if(changes['xaxis.autorange']) {
	                fullLayout.xaxis.rangeslider.setRange();
	            }
	        }
	    }
	
	    var plotDone = Lib.syncOrAsync(seq, gd);
	
	    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
	
	    return plotDone.then(function() {
	        var changes = Lib.extendDeep({}, redoit);
	
	        setRange(changes);
	        gd.emit('plotly_relayout', changes);
	
	        return gd;
	    });
	};
	
	/**
	 * Purge a graph container div back to its initial pre-Plotly.plot state
	 *
	 * @param {string id or DOM element} gd
	 *      the id or DOM element of the graph container div
	 */
	Plotly.purge = function purge(gd) {
	    gd = getGraphDiv(gd);
	
	    var fullLayout = gd._fullLayout || {},
	        fullData = gd._fullData || [];
	
	    // remove gl contexts
	    Plots.cleanPlot([], {}, fullData, fullLayout);
	
	    // purge properties
	    Plots.purge(gd);
	
	    // purge event emitter methods
	    Events.purge(gd);
	
	    // remove plot container
	    if(fullLayout._container) fullLayout._container.remove();
	
	    delete gd._context;
	    delete gd._replotPending;
	    delete gd._mouseDownTime;
	    delete gd._hmpixcount;
	    delete gd._hmlumcount;
	
	    return gd;
	};
	
	/**
	 * Reduce all reserved margin objects to a single required margin reservation.
	 *
	 * @param {Object} margins
	 * @returns {{left: number, right: number, bottom: number, top: number}}
	 */
	function calculateReservedMargins(margins) {
	    var resultingMargin = {left: 0, right: 0, bottom: 0, top: 0},
	        marginName;
	
	    if(margins) {
	        for(marginName in margins) {
	            if(margins.hasOwnProperty(marginName)) {
	                resultingMargin.left += margins[marginName].left || 0;
	                resultingMargin.right += margins[marginName].right || 0;
	                resultingMargin.bottom += margins[marginName].bottom || 0;
	                resultingMargin.top += margins[marginName].top || 0;
	            }
	        }
	    }
	    return resultingMargin;
	}
	
	function plotAutoSize(gd, aobj) {
	    var fullLayout = gd._fullLayout,
	        context = gd._context,
	        computedStyle;
	
	    var newHeight, newWidth;
	
	    gd.emit('plotly_autosize');
	
	    // embedded in an iframe - just take the full iframe size
	    // if we get to this point, with no aspect ratio restrictions
	    if(gd._context.fillFrame) {
	        newWidth = window.innerWidth;
	        newHeight = window.innerHeight;
	
	        // somehow we get a few extra px height sometimes...
	        // just hide it
	        document.body.style.overflow = 'hidden';
	    }
	    else if(isNumeric(context.frameMargins) && context.frameMargins > 0) {
	        var reservedMargins = calculateReservedMargins(gd._boundingBoxMargins),
	            reservedWidth = reservedMargins.left + reservedMargins.right,
	            reservedHeight = reservedMargins.bottom + reservedMargins.top,
	            gdBB = fullLayout._container.node().getBoundingClientRect(),
	            factor = 1 - 2*context.frameMargins;
	
	        newWidth = Math.round(factor * (gdBB.width - reservedWidth));
	        newHeight = Math.round(factor * (gdBB.height - reservedHeight));
	    }
	    else {
	        // plotly.js - let the developers do what they want, either
	        // provide height and width for the container div,
	        // specify size in layout, or take the defaults,
	        // but don't enforce any ratio restrictions
	        computedStyle = window.getComputedStyle(gd);
	        newHeight = parseFloat(computedStyle.height) || fullLayout.height;
	        newWidth = parseFloat(computedStyle.width) || fullLayout.width;
	    }
	
	    if(Math.abs(fullLayout.width - newWidth) > 1 ||
	            Math.abs(fullLayout.height - newHeight) > 1) {
	        fullLayout.height = gd.layout.height = newHeight;
	        fullLayout.width = gd.layout.width = newWidth;
	    }
	    // if there's no size change, update layout but
	    // delete the autosize attr so we don't redraw
	    // but can't call layoutStyles for initial autosize
	    else if(fullLayout.autosize !== 'initial') {
	        delete(aobj.autosize);
	        fullLayout.autosize = gd.layout.autosize = true;
	    }
	
	    Plots.sanitizeMargins(fullLayout);
	
	    return aobj;
	}
	
	// -------------------------------------------------------
	// makePlotFramework: Create the plot container and axes
	// -------------------------------------------------------
	function makePlotFramework(gd) {
	    var gd3 = d3.select(gd),
	        fullLayout = gd._fullLayout;
	
	    // Plot container
	    fullLayout._container = gd3.selectAll('.plot-container').data([0]);
	    fullLayout._container.enter().insert('div', ':first-child')
	        .classed('plot-container', true)
	        .classed('plotly', true);
	
	    // Make the svg container
	    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);
	    fullLayout._paperdiv.enter().append('div')
	        .classed('svg-container', true)
	        .style('position','relative');
	
	    // Initial autosize
	    if(fullLayout.autosize === 'initial') {
	        plotAutoSize(gd, {});
	        fullLayout.autosize = true;
	        gd.layout.autosize = true;
	    }
	
	    // Make the graph containers
	    // start fresh each time we get here, so we know the order comes out
	    // right, rather than enter/exit which can muck up the order
	    // TODO: sort out all the ordering so we don't have to
	    // explicitly delete anything
	    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')
	        .data([0]);
	    fullLayout._glcontainer.enter().append('div')
	        .classed('gl-container', true);
	
	    fullLayout._geocontainer = fullLayout._paperdiv.selectAll('.geo-container')
	        .data([0]);
	    fullLayout._geocontainer.enter().append('div')
	        .classed('geo-container', true);
	
	    fullLayout._paperdiv.selectAll('.main-svg').remove();
	
	    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')
	        .classed('main-svg', true);
	
	    fullLayout._toppaper = fullLayout._paperdiv.append('svg')
	        .classed('main-svg', true);
	
	    if(!fullLayout._uid) {
	        var otherUids = [];
	        d3.selectAll('defs').each(function() {
	            if(this.id) otherUids.push(this.id.split('-')[1]);
	        });
	        fullLayout._uid = Lib.randstr(otherUids);
	    }
	
	    fullLayout._paperdiv.selectAll('.main-svg')
	        .attr(xmlnsNamespaces.svgAttrs);
	
	    fullLayout._defs = fullLayout._paper.append('defs')
	        .attr('id', 'defs-' + fullLayout._uid);
	
	    fullLayout._topdefs = fullLayout._toppaper.append('defs')
	        .attr('id', 'topdefs-' + fullLayout._uid);
	
	    fullLayout._draggers = fullLayout._paper.append('g')
	        .classed('draglayer', true);
	
	    // lower shape layer
	    // (only for shapes to be drawn below the whole plot)
	    var layerBelow = fullLayout._paper.append('g')
	        .classed('layer-below', true);
	    fullLayout._imageLowerLayer = layerBelow.append('g')
	        .classed('imagelayer', true);
	    fullLayout._shapeLowerLayer = layerBelow.append('g')
	        .classed('shapelayer', true);
	
	    var subplots = Plotly.Axes.getSubplots(gd);
	    if(subplots.join('') !== Object.keys(gd._fullLayout._plots || {}).join('')) {
	        makeSubplots(gd, subplots);
	    }
	
	    if(fullLayout._has('cartesian')) makeCartesianPlotFramwork(gd, subplots);
	
	    // single ternary layer for the whole plot
	    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);
	
	    // shape layers in subplots
	    var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
	    fullLayout._imageSubplotLayer = layerSubplot.selectAll('.imagelayer');
	    fullLayout._shapeSubplotLayer = layerSubplot.selectAll('.shapelayer');
	
	    // upper shape layer
	    // (only for shapes to be drawn above the whole plot, including subplots)
	    var layerAbove = fullLayout._paper.append('g')
	        .classed('layer-above', true);
	    fullLayout._imageUpperLayer = layerAbove.append('g')
	        .classed('imagelayer', true);
	    fullLayout._shapeUpperLayer = layerAbove.append('g')
	        .classed('shapelayer', true);
	
	    // single pie layer for the whole plot
	    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);
	
	    // fill in image server scrape-svg
	    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);
	    fullLayout._geoimages = fullLayout._paper.append('g').classed('geoimages', true);
	
	    // lastly info (legend, annotations) and hover layers go on top
	    // these are in a different svg element normally, but get collapsed into a single
	    // svg when exporting (after inserting 3D)
	    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);
	    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);
	    fullLayout._hoverlayer = fullLayout._toppaper.append('g').classed('hoverlayer', true);
	
	    gd.emit('plotly_framework');
	
	    // position and style the containers, make main title
	    var frameWorkDone = Lib.syncOrAsync([
	        layoutStyles,
	        function goAxes() { return Plotly.Axes.doTicks(gd,'redraw'); },
	        Fx.init
	    ], gd);
	
	    if(frameWorkDone && frameWorkDone.then) {
	        gd._promises.push(frameWorkDone);
	    }
	
	    return frameWorkDone;
	}
	
	// create '_plots' object grouping x/y axes into subplots
	// to be better manage subplots
	function makeSubplots(gd, subplots) {
	    var _plots = gd._fullLayout._plots = {};
	    var subplot, plotinfo;
	
	    function getAxisFunc(subplot, axLetter) {
	        return function() {
	            return Plotly.Axes.getFromId(gd, subplot, axLetter);
	        };
	    }
	
	    for(var i = 0; i < subplots.length; i++) {
	        subplot = subplots[i];
	        plotinfo = _plots[subplot] = {};
	
	        plotinfo.id = subplot;
	
	        // references to the axis objects controlling this subplot
	        plotinfo.x = getAxisFunc(subplot, 'x');
	        plotinfo.y = getAxisFunc(subplot, 'y');
	
	        // TODO investigate why replacing calls to .x and .y
	        // for .xaxis and .yaxis makes the `pseudo_html`
	        // test image fail
	        plotinfo.xaxis = plotinfo.x();
	        plotinfo.yaxis = plotinfo.y();
	    }
	}
	
	function makeCartesianPlotFramwork(gd, subplots) {
	    var fullLayout = gd._fullLayout;
	
	    // Layers to keep plot types in the right order.
	    // from back to front:
	    // 1. heatmaps, 2D histos and contour maps
	    // 2. bars / 1D histos
	    // 3. errorbars for bars and scatter
	    // 4. scatter
	    // 5. box plots
	    function plotLayers(svg) {
	        svg.append('g').classed('imagelayer', true);
	        svg.append('g').classed('maplayer', true);
	        svg.append('g').classed('barlayer', true);
	        svg.append('g').classed('boxlayer', true);
	        svg.append('g').classed('scatterlayer', true);
	    }
	
	    // create all the layers in order, so we know they'll stay in order
	    var overlays = [];
	
	    fullLayout._paper.selectAll('g.subplot').data(subplots)
	      .enter().append('g')
	        .classed('subplot', true)
	        .each(function(subplot) {
	            var plotinfo = fullLayout._plots[subplot],
	                plotgroup = plotinfo.plotgroup = d3.select(this).classed(subplot, true),
	                xa = plotinfo.xaxis,
	                ya = plotinfo.yaxis;
	
	            // references to any subplots overlaid on this one
	            plotinfo.overlays = [];
	
	            // is this subplot overlaid on another?
	            // ax.overlaying is the id of another axis of the same
	            // dimension that this one overlays to be an overlaid subplot,
	            // the main plot must exist make sure we're not trying to
	            // overlay on an axis that's already overlaying another
	            var xa2 = Plotly.Axes.getFromId(gd, xa.overlaying) || xa;
	            if(xa2 !== xa && xa2.overlaying) {
	                xa2 = xa;
	                xa.overlaying = false;
	            }
	
	            var ya2 = Plotly.Axes.getFromId(gd, ya.overlaying) || ya;
	            if(ya2 !== ya && ya2.overlaying) {
	                ya2 = ya;
	                ya.overlaying = false;
	            }
	
	            var mainplot = xa2._id+ya2._id;
	            if(mainplot!==subplot && subplots.indexOf(mainplot)!==-1) {
	                plotinfo.mainplot = mainplot;
	                overlays.push(plotinfo);
	
	                // for now force overlays to overlay completely... so they
	                // can drag together correctly and share backgrounds.
	                // Later perhaps we make separate axis domain and
	                // tick/line domain or something, so they can still share
	                // the (possibly larger) dragger and background but don't
	                // have to both be drawn over that whole domain
	                xa.domain = xa2.domain.slice();
	                ya.domain = ya2.domain.slice();
	            }
	            else {
	                // main subplot - make the components of
	                // the plot and containers for overlays
	                plotinfo.bg = plotgroup.append('rect')
	                    .style('stroke-width', 0);
	
	                // back layer for shapes and images to
	                // be drawn below a subplot
	                var backlayer = plotgroup.append('g')
	                    .classed('layer-subplot', true);
	
	                plotinfo.shapelayer = backlayer.append('g')
	                    .classed('shapelayer', true);
	                plotinfo.imagelayer = backlayer.append('g')
	                    .classed('imagelayer', true);
	                plotinfo.gridlayer = plotgroup.append('g');
	                plotinfo.overgrid = plotgroup.append('g');
	                plotinfo.zerolinelayer = plotgroup.append('g');
	                plotinfo.overzero = plotgroup.append('g');
	                plotinfo.plot = plotgroup.append('g').call(plotLayers);
	                plotinfo.overplot = plotgroup.append('g');
	                plotinfo.xlines = plotgroup.append('path');
	                plotinfo.ylines = plotgroup.append('path');
	                plotinfo.overlines = plotgroup.append('g');
	                plotinfo.xaxislayer = plotgroup.append('g');
	                plotinfo.yaxislayer = plotgroup.append('g');
	                plotinfo.overaxes = plotgroup.append('g');
	
	                // make separate drag layers for each subplot,
	                // but append them to paper rather than the plot groups,
	                // so they end up on top of the rest
	            }
	            plotinfo.draglayer = fullLayout._draggers.append('g');
	        });
	
	    // now make the components of overlaid subplots
	    // overlays don't have backgrounds, and append all
	    // their other components to the corresponding
	    // extra groups of their main Plots.
	    overlays.forEach(function(plotinfo) {
	        var mainplot = fullLayout._plots[plotinfo.mainplot];
	        mainplot.overlays.push(plotinfo);
	
	        plotinfo.gridlayer = mainplot.overgrid.append('g');
	        plotinfo.zerolinelayer = mainplot.overzero.append('g');
	        plotinfo.plot = mainplot.overplot.append('g').call(plotLayers);
	        plotinfo.xlines = mainplot.overlines.append('path');
	        plotinfo.ylines = mainplot.overlines.append('path');
	        plotinfo.xaxislayer = mainplot.overaxes.append('g');
	        plotinfo.yaxislayer = mainplot.overaxes.append('g');
	    });
	
	    // common attributes for all subplots, overlays or not
	    subplots.forEach(function(subplot) {
	        var plotinfo = fullLayout._plots[subplot];
	
	        plotinfo.xlines
	            .style('fill', 'none')
	            .classed('crisp', true);
	        plotinfo.ylines
	            .style('fill', 'none')
	            .classed('crisp', true);
	    });
	}
	
	// layoutStyles: styling for plot layout elements
	function layoutStyles(gd) {
	    return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);
	}
	
	function lsInner(gd) {
	    var fullLayout = gd._fullLayout,
	        gs = fullLayout._size,
	        axList = Plotly.Axes.list(gd),
	        i;
	
	    // clear axis line positions, to be set in the subplot loop below
	    for(i = 0; i < axList.length; i++) axList[i]._linepositions = {};
	
	    fullLayout._paperdiv
	        .style({
	            width: fullLayout.width + 'px',
	            height: fullLayout.height + 'px'
	        })
	        .selectAll('.main-svg')
	            .call(Drawing.setSize, fullLayout.width, fullLayout.height);
	
	    gd._context.setBackground(gd, fullLayout.paper_bgcolor);
	
	    var freefinished = [];
	    fullLayout._paper.selectAll('g.subplot').each(function(subplot) {
	        var plotinfo = fullLayout._plots[subplot],
	            xa = Plotly.Axes.getFromId(gd, subplot, 'x'),
	            ya = Plotly.Axes.getFromId(gd, subplot, 'y');
	        xa.setScale(); // this may already be done... not sure
	        ya.setScale();
	
	        if(plotinfo.bg) {
	            plotinfo.bg
	                .call(Drawing.setRect,
	                    xa._offset-gs.p, ya._offset-gs.p,
	                    xa._length+2*gs.p, ya._length+2*gs.p)
	                .call(Color.fill, fullLayout.plot_bgcolor);
	        }
	
	
	        // Clip so that data only shows up on the plot area.
	        var clips = fullLayout._defs.selectAll('g.clips'),
	            clipId = 'clip' + fullLayout._uid + subplot + 'plot';
	
	        var plotClip = clips.selectAll('#' + clipId)
	            .data([0]);
	
	        plotClip.enter().append('clipPath')
	            .attr({
	                'class': 'plotclip',
	                'id': clipId
	            })
	            .append('rect');
	
	        plotClip.selectAll('rect')
	            .attr({
	                'width': xa._length,
	                'height': ya._length
	            });
	
	
	        plotinfo.plot.call(Lib.setTranslate, xa._offset, ya._offset);
	        plotinfo.plot.call(Drawing.setClipUrl, clipId);
	
	        var xlw = Drawing.crispRound(gd, xa.linewidth, 1),
	            ylw = Drawing.crispRound(gd, ya.linewidth, 1),
	            xp = gs.p+ylw,
	            xpathPrefix = 'M'+(-xp)+',',
	            xpathSuffix = 'h'+(xa._length+2*xp),
	            showfreex = xa.anchor==='free' &&
	                freefinished.indexOf(xa._id)===-1,
	            freeposx = gs.h*(1-(xa.position||0))+((xlw/2)%1),
	            showbottom =
	                (xa.anchor===ya._id && (xa.mirror||xa.side!=='top')) ||
	                xa.mirror==='all' || xa.mirror==='allticks' ||
	                (xa.mirrors && xa.mirrors[ya._id+'bottom']),
	            bottompos = ya._length+gs.p+xlw/2,
	            showtop =
	                (xa.anchor===ya._id && (xa.mirror||xa.side==='top')) ||
	                xa.mirror==='all' || xa.mirror==='allticks' ||
	                (xa.mirrors && xa.mirrors[ya._id+'top']),
	            toppos = -gs.p-xlw/2,
	
	            // shorten y axis lines so they don't overlap x axis lines
	            yp = gs.p,
	            // except where there's no x line
	            // TODO: this gets more complicated with multiple x and y axes
	            ypbottom = showbottom ? 0 : xlw,
	            yptop = showtop ? 0 : xlw,
	            ypathSuffix = ','+(-yp-yptop)+
	                'v'+(ya._length+2*yp+yptop+ypbottom),
	            showfreey = ya.anchor==='free' &&
	                freefinished.indexOf(ya._id)===-1,
	            freeposy = gs.w*(ya.position||0)+((ylw/2)%1),
	            showleft =
	                (ya.anchor===xa._id && (ya.mirror||ya.side!=='right')) ||
	                ya.mirror==='all' || ya.mirror==='allticks' ||
	                (ya.mirrors && ya.mirrors[xa._id+'left']),
	            leftpos = -gs.p-ylw/2,
	            showright =
	                (ya.anchor===xa._id && (ya.mirror||ya.side==='right')) ||
	                ya.mirror==='all' || ya.mirror==='allticks' ||
	                (ya.mirrors && ya.mirrors[xa._id+'right']),
	            rightpos = xa._length+gs.p+ylw/2;
	
	        // save axis line positions for ticks, draggers, etc to reference
	        // each subplot gets an entry:
	        //    [left or bottom, right or top, free, main]
	        // main is the position at which to draw labels and draggers, if any
	        xa._linepositions[subplot] = [
	            showbottom ? bottompos : undefined,
	            showtop ? toppos : undefined,
	            showfreex ? freeposx : undefined
	        ];
	        if(xa.anchor===ya._id) {
	            xa._linepositions[subplot][3] = xa.side==='top' ?
	                toppos : bottompos;
	        }
	        else if(showfreex) {
	            xa._linepositions[subplot][3] = freeposx;
	        }
	
	        ya._linepositions[subplot] = [
	            showleft ? leftpos : undefined,
	            showright ? rightpos : undefined,
	            showfreey ? freeposy : undefined
	        ];
	        if(ya.anchor===xa._id) {
	            ya._linepositions[subplot][3] = ya.side==='right' ?
	                rightpos : leftpos;
	        }
	        else if(showfreey) {
	            ya._linepositions[subplot][3] = freeposy;
	        }
	
	        // translate all the extra stuff to have the
	        // same origin as the plot area or axes
	        var origin = 'translate('+xa._offset+','+ya._offset+')',
	            originx = origin,
	            originy = origin;
	        if(showfreex) {
	            originx = 'translate('+xa._offset+','+gs.t+')';
	            toppos += ya._offset - gs.t;
	            bottompos += ya._offset - gs.t;
	        }
	        if(showfreey) {
	            originy = 'translate('+gs.l+','+ya._offset+')';
	            leftpos += xa._offset - gs.l;
	            rightpos += xa._offset - gs.l;
	        }
	
	        plotinfo.xlines
	            .attr('transform', originx)
	            .attr('d',(
	                (showbottom ? (xpathPrefix+bottompos+xpathSuffix) : '') +
	                (showtop ? (xpathPrefix+toppos+xpathSuffix) : '') +
	                (showfreex ? (xpathPrefix+freeposx+xpathSuffix) : '')) ||
	                // so it doesn't barf with no lines shown
	                'M0,0')
	            .style('stroke-width',xlw+'px')
	            .call(Color.stroke, xa.showline ?
	                xa.linecolor : 'rgba(0,0,0,0)');
	        plotinfo.ylines
	            .attr('transform', originy)
	            .attr('d',(
	                (showleft ? ('M'+leftpos+ypathSuffix) : '') +
	                (showright ? ('M'+rightpos+ypathSuffix) : '') +
	                (showfreey ? ('M'+freeposy+ypathSuffix) : '')) ||
	                'M0,0')
	            .attr('stroke-width',ylw+'px')
	            .call(Color.stroke,ya.showline ?
	                ya.linecolor : 'rgba(0,0,0,0)');
	
	        plotinfo.xaxislayer.attr('transform',originx);
	        plotinfo.yaxislayer.attr('transform',originy);
	        plotinfo.gridlayer.attr('transform',origin);
	        plotinfo.zerolinelayer.attr('transform',origin);
	        plotinfo.draglayer.attr('transform',origin);
	
	        // mark free axes as displayed, so we don't draw them again
	        if(showfreex) { freefinished.push(xa._id); }
	        if(showfreey) { freefinished.push(ya._id); }
	    });
	
	    Plotly.Axes.makeClipPaths(gd);
	
	    drawMainTitle(gd);
	
	    manageModeBar(gd);
	
	    return gd._promises.length && Promise.all(gd._promises);
	}
	
	function drawMainTitle(gd) {
	    var fullLayout = gd._fullLayout;
	
	    Titles.draw(gd, 'gtitle', {
	        propContainer: fullLayout,
	        propName: 'title',
	        dfltName: 'Plot',
	        attributes: {
	            x: fullLayout.width / 2,
	            y: fullLayout._size.t / 2,
	            'text-anchor': 'middle'
	        }
	    });
	}


/***/ },
/* 449 */
/***/ function(module, exports) {

	module.exports = fromQuat;
	
	/**
	 * Creates a matrix from a quaternion rotation.
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @returns {mat4} out
	 */
	function fromQuat(out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	
	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;
	
	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;
	
	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;
	
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	
	    return out;
	};

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var scatterSubTypes = __webpack_require__(360);
	
	var createModeBar = __webpack_require__(425);
	var modeBarButtons = __webpack_require__(451);
	
	/**
	 * ModeBar wrapper around 'create' and 'update',
	 * chooses buttons to pass to ModeBar constructor based on
	 * plot type and plot config.
	 *
	 * @param {object} gd main plot object
	 *
	 */
	module.exports = function manageModeBar(gd) {
	    var fullLayout = gd._fullLayout,
	        context = gd._context,
	        modeBar = fullLayout._modeBar;
	
	    if(!context.displayModeBar) {
	        if(modeBar) {
	            modeBar.destroy();
	            delete fullLayout._modeBar;
	        }
	        return;
	    }
	
	    if(!Array.isArray(context.modeBarButtonsToRemove)) {
	        throw new Error([
	            '*modeBarButtonsToRemove* configuration options',
	            'must be an array.'
	        ].join(' '));
	    }
	
	    if(!Array.isArray(context.modeBarButtonsToAdd)) {
	        throw new Error([
	            '*modeBarButtonsToAdd* configuration options',
	            'must be an array.'
	        ].join(' '));
	    }
	
	    var customButtons = context.modeBarButtons;
	    var buttonGroups;
	
	    if(Array.isArray(customButtons) && customButtons.length) {
	        buttonGroups = fillCustomButton(customButtons);
	    }
	    else {
	        buttonGroups = getButtonGroups(
	            gd,
	            context.modeBarButtonsToRemove,
	            context.modeBarButtonsToAdd
	        );
	    }
	
	    if(modeBar) modeBar.update(gd, buttonGroups);
	    else fullLayout._modeBar = createModeBar(gd, buttonGroups);
	};
	
	// logic behind which buttons are displayed by default
	function getButtonGroups(gd, buttonsToRemove, buttonsToAdd) {
	    var fullLayout = gd._fullLayout,
	        fullData = gd._fullData;
	
	    var hasCartesian = fullLayout._has('cartesian'),
	        hasGL3D = fullLayout._has('gl3d'),
	        hasGeo = fullLayout._has('geo'),
	        hasPie = fullLayout._has('pie'),
	        hasGL2D = fullLayout._has('gl2d'),
	        hasTernary = fullLayout._has('ternary');
	
	    var groups = [];
	
	    function addGroup(newGroup) {
	        var out = [];
	
	        for(var i = 0; i < newGroup.length; i++) {
	            var button = newGroup[i];
	            if(buttonsToRemove.indexOf(button) !== -1) continue;
	            out.push(modeBarButtons[button]);
	        }
	
	        groups.push(out);
	    }
	
	    // buttons common to all plot types
	    addGroup(['toImage', 'sendDataToCloud']);
	
	    // graphs with more than one plot types get 'union buttons'
	    // which reset the view or toggle hover labels across all subplots.
	    if((hasCartesian || hasGL2D || hasPie || hasTernary) + hasGeo + hasGL3D > 1) {
	        addGroup(['resetViews', 'toggleHover']);
	        return appendButtonsToGroups(groups, buttonsToAdd);
	    }
	
	    if(hasGL3D) {
	        addGroup(['zoom3d', 'pan3d', 'orbitRotation', 'tableRotation']);
	        addGroup(['resetCameraDefault3d', 'resetCameraLastSave3d']);
	        addGroup(['hoverClosest3d']);
	    }
	
	    if(hasGeo) {
	        addGroup(['zoomInGeo', 'zoomOutGeo', 'resetGeo']);
	        addGroup(['hoverClosestGeo']);
	    }
	
	    var allAxesFixed = areAllAxesFixed(fullLayout),
	        dragModeGroup = [];
	
	    if(((hasCartesian || hasGL2D) && !allAxesFixed) || hasTernary) {
	        dragModeGroup = ['zoom2d', 'pan2d'];
	    }
	    if((hasCartesian || hasTernary) && isSelectable(fullData)) {
	        dragModeGroup.push('select2d');
	        dragModeGroup.push('lasso2d');
	    }
	    if(dragModeGroup.length) addGroup(dragModeGroup);
	
	    if((hasCartesian || hasGL2D) && !allAxesFixed && !hasTernary) {
	        addGroup(['zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d']);
	    }
	
	    if(hasCartesian && hasPie) {
	        addGroup(['toggleHover']);
	    }
	    else if(hasGL2D) {
	        addGroup(['hoverClosestGl2d']);
	    }
	    else if(hasCartesian) {
	        addGroup(['hoverClosestCartesian', 'hoverCompareCartesian']);
	    }
	    else if(hasPie) {
	        addGroup(['hoverClosestPie']);
	    }
	
	    return appendButtonsToGroups(groups, buttonsToAdd);
	}
	
	function areAllAxesFixed(fullLayout) {
	    var axList = Plotly.Axes.list({_fullLayout: fullLayout}, null, true);
	    var allFixed = true;
	
	    for(var i = 0; i < axList.length; i++) {
	        if(!axList[i].fixedrange) {
	            allFixed = false;
	            break;
	        }
	    }
	
	    return allFixed;
	}
	
	// look for traces that support selection
	// to be updated as we add more selectPoints handlers
	function isSelectable(fullData) {
	    var selectable = false;
	
	    for(var i = 0; i < fullData.length; i++) {
	        if(selectable) break;
	
	        var trace = fullData[i];
	
	        if(!trace._module || !trace._module.selectPoints) continue;
	
	        if(trace.type === 'scatter' || trace.type === 'scatterternary') {
	            if(scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {
	                selectable = true;
	            }
	        }
	        // assume that in general if the trace module has selectPoints,
	        // then it's selectable. Scatter is an exception to this because it must
	        // have markers or text, not just be a scatter type.
	        else selectable = true;
	    }
	
	    return selectable;
	}
	
	function appendButtonsToGroups(groups, buttons) {
	    if(buttons.length) {
	        if(Array.isArray(buttons[0])) {
	            for(var i = 0; i < buttons.length; i++) {
	                groups.push(buttons[i]);
	            }
	        }
	        else groups.push(buttons);
	    }
	
	    return groups;
	}
	
	// fill in custom buttons referring to default mode bar buttons
	function fillCustomButton(customButtons) {
	    for(var i = 0; i < customButtons.length; i++) {
	        var buttonGroup = customButtons[i];
	
	        for(var j = 0; j < buttonGroup.length; j++) {
	            var button = buttonGroup[j];
	
	            if(typeof button === 'string') {
	                if(modeBarButtons[button] !== undefined) {
	                    customButtons[i][j] = modeBarButtons[button];
	                }
	                else {
	                    throw new Error([
	                        '*modeBarButtons* configuration options',
	                        'invalid button name'
	                    ].join(' '));
	                }
	            }
	        }
	    }
	
	    return customButtons;
	}


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	var setCursor = __webpack_require__(390);
	var downloadImage = __webpack_require__(452);
	var Icons = __webpack_require__(426);
	
	
	var modeBarButtons = module.exports = {};
	
	/**
	 * ModeBar buttons configuration
	 *
	 * @param {string} name
	 *      name / id of the buttons (for tracking)
	 * @param {string} title
	 *      text that appears while hovering over the button,
	 *      enter null, false or '' for no hover text
	 * @param {string} icon
	 *      svg icon object associated with the button
	 *      can be linked to Plotly.Icons to use the default plotly icons
	 * @param {string} [gravity]
	 *      icon positioning
	 * @param {function} click
	 *      click handler associated with the button, a function of
	 *      'gd' (the main graph object) and
	 *      'ev' (the event object)
	 * @param {string} [attr]
	 *      attribute associated with button,
	 *      use this with 'val' to keep track of the state
	 * @param {*} [val]
	 *      initial 'attr' value, can be a function of gd
	 * @param {boolean} [toggle]
	 *      is the button a toggle button?
	 */
	
	modeBarButtons.toImage = {
	    name: 'toImage',
	    title: 'Download plot as a png',
	    icon: Icons.camera,
	    click: function(gd) {
	        var format = 'png';
	
	        Lib.notifier('Taking snapshot - this may take a few seconds', 'long');
	
	        if(Lib.isIE()) {
	            Lib.notifier('IE only supports svg.  Changing format to svg.', 'long');
	            format = 'svg';
	        }
	
	        downloadImage(gd, {'format': format})
	          .then(function(filename) {
	              Lib.notifier('Snapshot succeeded - ' + filename, 'long');
	          })
	          .catch(function() {
	              Lib.notifier('Sorry there was a problem downloading your snapshot!', 'long');
	          });
	    }
	};
	
	modeBarButtons.sendDataToCloud = {
	    name: 'sendDataToCloud',
	    title: 'Save and edit plot in cloud',
	    icon: Icons.disk,
	    click: function(gd) {
	        Plotly.Plots.sendDataToCloud(gd);
	    }
	};
	
	modeBarButtons.zoom2d = {
	    name: 'zoom2d',
	    title: 'Zoom',
	    attr: 'dragmode',
	    val: 'zoom',
	    icon: Icons.zoombox,
	    click: handleCartesian
	};
	
	modeBarButtons.pan2d = {
	    name: 'pan2d',
	    title: 'Pan',
	    attr: 'dragmode',
	    val: 'pan',
	    icon: Icons.pan,
	    click: handleCartesian
	};
	
	modeBarButtons.select2d = {
	    name: 'select2d',
	    title: 'Box Select',
	    attr: 'dragmode',
	    val: 'select',
	    icon: Icons.selectbox,
	    click: handleCartesian
	};
	
	modeBarButtons.lasso2d = {
	    name: 'lasso2d',
	    title: 'Lasso Select',
	    attr: 'dragmode',
	    val: 'lasso',
	    icon: Icons.lasso,
	    click: handleCartesian
	};
	
	modeBarButtons.zoomIn2d = {
	    name: 'zoomIn2d',
	    title: 'Zoom in',
	    attr: 'zoom',
	    val: 'in',
	    icon: Icons.zoom_plus,
	    click: handleCartesian
	};
	
	modeBarButtons.zoomOut2d = {
	    name: 'zoomOut2d',
	    title: 'Zoom out',
	    attr: 'zoom',
	    val: 'out',
	    icon: Icons.zoom_minus,
	    click: handleCartesian
	};
	
	modeBarButtons.autoScale2d = {
	    name: 'autoScale2d',
	    title: 'Autoscale',
	    attr: 'zoom',
	    val: 'auto',
	    icon: Icons.autoscale,
	    click: handleCartesian
	};
	
	modeBarButtons.resetScale2d = {
	    name: 'resetScale2d',
	    title: 'Reset axes',
	    attr: 'zoom',
	    val: 'reset',
	    icon: Icons.home,
	    click: handleCartesian
	};
	
	modeBarButtons.hoverClosestCartesian = {
	    name: 'hoverClosestCartesian',
	    title: 'Show closest data on hover',
	    attr: 'hovermode',
	    val: 'closest',
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: handleCartesian
	};
	
	modeBarButtons.hoverCompareCartesian = {
	    name: 'hoverCompareCartesian',
	    title: 'Compare data on hover',
	    attr: 'hovermode',
	    val: function(gd) {
	        return gd._fullLayout._isHoriz ? 'y' : 'x';
	    },
	    icon: Icons.tooltip_compare,
	    gravity: 'ne',
	    click: handleCartesian
	};
	
	var DRAGCURSORS = {
	    pan: 'move',
	    zoom: 'crosshair',
	    select: 'crosshair',
	    lasso: 'crosshair'
	};
	
	function handleCartesian(gd, ev) {
	    var button = ev.currentTarget,
	        astr = button.getAttribute('data-attr'),
	        val = button.getAttribute('data-val') || true,
	        fullLayout = gd._fullLayout,
	        aobj = {};
	
	    if(astr === 'zoom') {
	        var mag = (val === 'in') ? 0.5 : 2,
	            r0 = (1 + mag) / 2,
	            r1 = (1 - mag) / 2,
	            axList = Plotly.Axes.list(gd, null, true);
	
	        var ax, axName;
	
	        for(var i = 0; i < axList.length; i++) {
	            ax = axList[i];
	
	            if(!ax.fixedrange) {
	                axName = ax._name;
	                if(val === 'auto') aobj[axName + '.autorange'] = true;
	                else if(val === 'reset') {
	                    if(ax._rangeInitial === undefined) {
	                        aobj[axName + '.autorange'] = true;
	                    }
	                    else {
	                        var rangeInitial = ax._rangeInitial.slice();
	                        aobj[axName + '.range[0]'] = rangeInitial[0];
	                        aobj[axName + '.range[1]'] = rangeInitial[1];
	                    }
	                }
	                else {
	                    var rangeNow = ax.range;
	                    aobj[axName + '.range[0]'] = r0 * rangeNow[0] + r1 * rangeNow[1];
	                    aobj[axName + '.range[1]'] = r0 * rangeNow[1] + r1 * rangeNow[0];
	                }
	            }
	        }
	    }
	    else {
	        // if ALL traces have orientation 'h', 'hovermode': 'x' otherwise: 'y'
	        if(astr==='hovermode' && (val==='x' || val==='y')) {
	            val = fullLayout._isHoriz ? 'y' : 'x';
	            button.setAttribute('data-val', val);
	        }
	
	        aobj[astr] = val;
	    }
	
	    Plotly.relayout(gd, aobj).then(function() {
	        if(astr === 'dragmode') {
	            if(fullLayout._has('cartesian')) {
	                setCursor(
	                    fullLayout._paper.select('.nsewdrag'),
	                    DRAGCURSORS[val]
	                );
	            }
	            Plotly.Fx.supplyLayoutDefaults(gd.layout, fullLayout, gd._fullData);
	            Plotly.Fx.init(gd);
	        }
	    });
	}
	
	modeBarButtons.zoom3d = {
	    name: 'zoom3d',
	    title: 'Zoom',
	    attr: 'scene.dragmode',
	    val: 'zoom',
	    icon: Icons.zoombox,
	    click: handleDrag3d
	};
	
	modeBarButtons.pan3d = {
	    name: 'pan3d',
	    title: 'Pan',
	    attr: 'scene.dragmode',
	    val: 'pan',
	    icon: Icons.pan,
	    click: handleDrag3d
	};
	
	modeBarButtons.orbitRotation = {
	    name: 'orbitRotation',
	    title: 'orbital rotation',
	    attr: 'scene.dragmode',
	    val: 'orbit',
	    icon: Icons['3d_rotate'],
	    click: handleDrag3d
	};
	
	modeBarButtons.tableRotation = {
	    name: 'tableRotation',
	    title: 'turntable rotation',
	    attr: 'scene.dragmode',
	    val: 'turntable',
	    icon: Icons['z-axis'],
	    click: handleDrag3d
	};
	
	function handleDrag3d(gd, ev) {
	    var button = ev.currentTarget,
	        attr = button.getAttribute('data-attr'),
	        val = button.getAttribute('data-val') || true,
	        fullLayout = gd._fullLayout,
	        sceneIds = Plotly.Plots.getSubplotIds(fullLayout, 'gl3d'),
	        layoutUpdate = {};
	
	    var parts = attr.split('.');
	
	    for(var i = 0; i < sceneIds.length; i++) {
	        layoutUpdate[sceneIds[i] + '.' + parts[1]] = val;
	    }
	
	    Plotly.relayout(gd, layoutUpdate);
	}
	
	modeBarButtons.resetCameraDefault3d = {
	    name: 'resetCameraDefault3d',
	    title: 'Reset camera to default',
	    attr: 'resetDefault',
	    icon: Icons.home,
	    click: handleCamera3d
	};
	
	modeBarButtons.resetCameraLastSave3d = {
	    name: 'resetCameraLastSave3d',
	    title: 'Reset camera to last save',
	    attr: 'resetLastSave',
	    icon: Icons.movie,
	    click: handleCamera3d
	};
	
	function handleCamera3d(gd, ev) {
	    var button = ev.currentTarget,
	        attr = button.getAttribute('data-attr'),
	        fullLayout = gd._fullLayout,
	        sceneIds = Plotly.Plots.getSubplotIds(fullLayout, 'gl3d');
	
	    for(var i = 0; i < sceneIds.length; i++) {
	        var sceneId = sceneIds[i],
	            fullSceneLayout = fullLayout[sceneId],
	            scene = fullSceneLayout._scene;
	
	        if(attr === 'resetDefault') scene.setCameraToDefault();
	        else if(attr === 'resetLastSave') {
	            // This handler looks in the un-updated fullLayout.scene.camera object to reset the camera
	            // to the last saved position.
	            scene.setCamera(fullSceneLayout.camera);
	        }
	    }
	}
	
	modeBarButtons.hoverClosest3d = {
	    name: 'hoverClosest3d',
	    title: 'Toggle show closest data on hover',
	    attr: 'hovermode',
	    val: null,
	    toggle: true,
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: handleHover3d
	};
	
	function handleHover3d(gd, ev) {
	    var button = ev.currentTarget,
	        val = button._previousVal || false,
	        layout = gd.layout,
	        fullLayout = gd._fullLayout,
	        sceneIds = Plotly.Plots.getSubplotIds(fullLayout, 'gl3d');
	
	    var axes = ['xaxis', 'yaxis', 'zaxis'],
	        spikeAttrs = ['showspikes', 'spikesides', 'spikethickness', 'spikecolor'];
	
	    // initialize 'current spike' object to be stored in the DOM
	    var currentSpikes = {},
	        axisSpikes = {},
	        layoutUpdate = {};
	
	    if(val) {
	        layoutUpdate = Lib.extendDeep(layout, val);
	        button._previousVal = null;
	    }
	    else {
	        layoutUpdate = {
	            'allaxes.showspikes': false
	        };
	
	        for(var i = 0; i < sceneIds.length; i++) {
	            var sceneId = sceneIds[i],
	                sceneLayout = fullLayout[sceneId],
	                sceneSpikes = currentSpikes[sceneId] = {};
	
	            sceneSpikes.hovermode = sceneLayout.hovermode;
	            layoutUpdate[sceneId + '.hovermode'] = false;
	
	            // copy all the current spike attrs
	            for(var j = 0; j < 3; j++) {
	                var axis = axes[j];
	                axisSpikes = sceneSpikes[axis] = {};
	
	                for(var k = 0; k < spikeAttrs.length; k++) {
	                    var spikeAttr = spikeAttrs[k];
	                    axisSpikes[spikeAttr] = sceneLayout[axis][spikeAttr];
	                }
	            }
	        }
	
	        button._previousVal = Lib.extendDeep({}, currentSpikes);
	    }
	
	    Plotly.relayout(gd, layoutUpdate);
	}
	
	modeBarButtons.zoomInGeo = {
	    name: 'zoomInGeo',
	    title: 'Zoom in',
	    attr: 'zoom',
	    val: 'in',
	    icon: Icons.zoom_plus,
	    click: handleGeo
	};
	
	modeBarButtons.zoomOutGeo = {
	    name: 'zoomOutGeo',
	    title: 'Zoom out',
	    attr: 'zoom',
	    val: 'out',
	    icon: Icons.zoom_minus,
	    click: handleGeo
	};
	
	modeBarButtons.resetGeo = {
	    name: 'resetGeo',
	    title: 'Reset',
	    attr: 'reset',
	    val: null,
	    icon: Icons.autoscale,
	    click: handleGeo
	};
	
	modeBarButtons.hoverClosestGeo = {
	    name: 'hoverClosestGeo',
	    title: 'Toggle show closest data on hover',
	    attr: 'hovermode',
	    val: null,
	    toggle: true,
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: toggleHover
	};
	
	function handleGeo(gd, ev) {
	    var button = ev.currentTarget,
	        attr = button.getAttribute('data-attr'),
	        val = button.getAttribute('data-val') || true,
	        fullLayout = gd._fullLayout,
	        geoIds = Plotly.Plots.getSubplotIds(fullLayout, 'geo');
	
	    for(var i = 0; i < geoIds.length; i++) {
	        var geo = fullLayout[geoIds[i]]._geo;
	
	        if(attr === 'zoom') {
	            var scale = geo.projection.scale();
	            var newScale = (val === 'in') ? 2 * scale : 0.5 * scale;
	            geo.projection.scale(newScale);
	            geo.zoom.scale(newScale);
	            geo.render();
	        }
	        else if(attr === 'reset') geo.zoomReset();
	    }
	}
	
	modeBarButtons.hoverClosestGl2d = {
	    name: 'hoverClosestGl2d',
	    title: 'Toggle show closest data on hover',
	    attr: 'hovermode',
	    val: null,
	    toggle: true,
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: toggleHover
	};
	
	modeBarButtons.hoverClosestPie = {
	    name: 'hoverClosestPie',
	    title: 'Toggle show closest data on hover',
	    attr: 'hovermode',
	    val: 'closest',
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: toggleHover
	};
	
	function toggleHover(gd) {
	    var fullLayout = gd._fullLayout;
	
	    var onHoverVal;
	    if(fullLayout._has('cartesian')) {
	        onHoverVal = fullLayout._isHoriz ? 'y' : 'x';
	    }
	    else onHoverVal = 'closest';
	
	    var newHover = gd._fullLayout.hovermode ? false : onHoverVal;
	
	    Plotly.relayout(gd, 'hovermode', newHover);
	}
	
	// buttons when more then one plot types are present
	
	modeBarButtons.toggleHover = {
	    name: 'toggleHover',
	    title: 'Toggle show closest data on hover',
	    attr: 'hovermode',
	    val: null,
	    toggle: true,
	    icon: Icons.tooltip_basic,
	    gravity: 'ne',
	    click: function(gd, ev) {
	        toggleHover(gd);
	
	        // the 3d hovermode update must come
	        // last so that layout.hovermode update does not
	        // override scene?.hovermode?.layout.
	        handleHover3d(gd, ev);
	    }
	};
	
	modeBarButtons.resetViews = {
	    name: 'resetViews',
	    title: 'Reset views',
	    icon: Icons.home,
	    click: function(gd, ev) {
	        var button = ev.currentTarget;
	
	        button.setAttribute('data-attr', 'zoom');
	        button.setAttribute('data-val', 'reset');
	        handleCartesian(gd, ev);
	
	        button.setAttribute('data-attr', 'resetLastSave');
	        handleCamera3d(gd, ev);
	
	        // N.B handleCamera3d also triggers a replot for
	        // geo subplots.
	    }
	};


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var toImage = __webpack_require__(453);
	var Lib = __webpack_require__(309); // for isIE
	var fileSaver = __webpack_require__(459);
	
	/**
	 * @param {object} gd figure Object
	 * @param {object} opts option object
	 * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'
	 * @param opts.width width of snapshot in px
	 * @param opts.height height of snapshot in px
	 * @param opts.filename name of file excluding extension
	 */
	function downloadImage(gd, opts) {
	
	    // check for undefined opts
	    opts = opts || {};
	
	    // default to png
	    opts.format = opts.format || 'png';
	
	    return new Promise(function(resolve,reject) {
	        if(gd._snapshotInProgress) {
	            reject(new Error('Snapshotting already in progress.'));
	        }
	
	        // see comments within svgtoimg for additional
	        //   discussion of problems with IE
	        //   can now draw to canvas, but CORS tainted canvas
	        //   does not allow toDataURL
	        //   svg format will work though
	        if(Lib.isIE() && opts.format !== 'svg') {
	            reject(new Error('Sorry IE does not support downloading from canvas. Try {format:\'svg\'} instead.'));
	        }
	
	        gd._snapshotInProgress = true;
	        var promise = toImage(gd, opts);
	
	        var filename = opts.filename || gd.fn || 'newplot';
	        filename += '.' + opts.format;
	
	        promise.then(function(result) {
	            gd._snapshotInProgress = false;
	            return fileSaver(result,filename);
	        }).then(function(name) {
	            resolve(name);
	        }).catch(function(err) {
	            gd._snapshotInProgress = false;
	            reject(err);
	        });
	    });
	}
	
	module.exports = downloadImage;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	
	var isNumeric = __webpack_require__(312);
	
	/**
	 * @param {object} gd figure Object
	 * @param {object} opts option object
	 * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'
	 * @param opts.width width of snapshot in px
	 * @param opts.height height of snapshot in px
	 */
	function toImage(gd, opts) {
	    var Snapshot = __webpack_require__(454);
	
	    var promise = new Promise(function(resolve, reject) {
	        // check for undefined opts
	        opts = opts || {};
	        // default to png
	        opts.format = opts.format || 'png';
	
	        var isSizeGood = function(size) {
	            // undefined and null are valid options
	            if(size === undefined || size === null) {
	                return true;
	            }
	
	            if(isNumeric(size) && size > 1) {
	                return true;
	            }
	
	            return false;
	        };
	
	        if(!isSizeGood(opts.width) || !isSizeGood(opts.height)) {
	            reject(new Error('Height and width should be pixel values.'));
	        }
	
	        // first clone the GD so we can operate in a clean environment
	        var clone = Snapshot.clone(gd, {format: 'png', height: opts.height, width: opts.width});
	        var clonedGd = clone.td;
	
	        // put the cloned div somewhere off screen before attaching to DOM
	        clonedGd.style.position = 'absolute';
	        clonedGd.style.left = '-5000px';
	        document.body.appendChild(clonedGd);
	
	        function wait() {
	            var delay = Snapshot.getDelay(clonedGd._fullLayout);
	
	            return new Promise(function(resolve, reject) {
	                setTimeout(function() {
	                    var svg = Snapshot.toSVG(clonedGd);
	
	                    var canvasContainer = window.document.createElement('div');
	                    var canvas = window.document.createElement('canvas');
	
	                    canvasContainer.appendChild(canvas);
	
	                    canvasContainer.id = Plotly.Lib.randstr();
	                    canvas.id = Plotly.Lib.randstr();
	
	                    Snapshot.svgToImg({
	                        format: opts.format,
	                        width: clonedGd._fullLayout.width,
	                        height: clonedGd._fullLayout.height,
	                        canvas: canvas,
	                        svg: svg,
	                        // ask svgToImg to return a Promise
	                        //  rather than EventEmitter
	                        //  leave EventEmitter for backward
	                        //  compatibility
	                        promise: true
	                    }).then(function(url) {
	                        if(clonedGd) document.body.removeChild(clonedGd);
	                        resolve(url);
	                    }).catch(function(err) {
	                        reject(err);
	                    });
	                }, delay);
	            });
	        }
	
	        var redrawFunc = Snapshot.getRedrawFunc(clonedGd);
	
	        Plotly.plot(clonedGd, clone.data, clone.layout, clone.config)
	            // TODO: the following is Plotly.Plots.redrawText but without the waiting.
	            // we shouldn't need to do this, but in *occasional* cases we do. Figure
	            // out why and take it out.
	
	            // not sure the above TODO makes sense anymore since
	            //   we have converted to promises
	            .then(redrawFunc)
	            .then(wait)
	            .then(function(url) { resolve(url); })
	            .catch(function(err) {
	                reject(err);
	            });
	    });
	
	    return promise;
	}
	
	module.exports = toImage;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	function getDelay(fullLayout) {
	
	    // polar clears fullLayout._has for some reason
	    if(!fullLayout._has) return 0;
	
	    // maybe we should add a 'gl' (and 'svg') layoutCategory ??
	    return (fullLayout._has('gl3d')|| fullLayout._has('gl2d')) ? 500 : 0;
	}
	
	function getRedrawFunc(gd) {
	
	    // do not work if polar is present
	    if((gd.data && gd.data[0] && gd.data[0].r)) return;
	
	    return function() {
	        (gd.calcdata || []).forEach(function(d) {
	            if(d[0] && d[0].t && d[0].t.cb) d[0].t.cb();
	        });
	    };
	}
	
	var Snapshot = {
	    getDelay: getDelay,
	    getRedrawFunc: getRedrawFunc,
	    clone: __webpack_require__(455),
	    toSVG: __webpack_require__(456),
	    svgToImg: __webpack_require__(457),
	    toImage: __webpack_require__(458),
	    downloadImage: __webpack_require__(452)
	};
	
	module.exports = Snapshot;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	
	var extendFlat = Plotly.Lib.extendFlat;
	var extendDeep = Plotly.Lib.extendDeep;
	
	// Put default plotTile layouts here
	function cloneLayoutOverride(tileClass) {
	    var override;
	
	    switch(tileClass) {
	        case 'themes__thumb':
	            override = {
	                autosize: true,
	                width: 150,
	                height: 150,
	                title: '',
	                showlegend: false,
	                margin: {l: 5, r: 5, t: 5, b: 5, pad: 0},
	                annotations: []
	            };
	            break;
	
	        case 'thumbnail':
	            override = {
	                title: '',
	                hidesources: true,
	                showlegend: false,
	                borderwidth: 0,
	                bordercolor: '',
	                margin: {l: 1, r: 1, t: 1, b: 1, pad: 0},
	                annotations: []
	            };
	            break;
	
	        default:
	            override = {};
	    }
	
	
	    return override;
	}
	
	function keyIsAxis(keyName) {
	    var types = ['xaxis', 'yaxis', 'zaxis'];
	    return (types.indexOf(keyName.slice(0, 5)) > -1);
	}
	
	
	module.exports = function clonePlot(graphObj, options) {
	
	    // Polar plot compatibility
	    if(graphObj.framework && graphObj.framework.isPolar) {
	        graphObj = graphObj.framework.getConfig();
	    }
	
	    var i;
	    var oldData = graphObj.data;
	    var oldLayout = graphObj.layout;
	    var newData = extendDeep([], oldData);
	    var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
	
	    if(options.width) newLayout.width = options.width;
	    if(options.height) newLayout.height = options.height;
	
	    if(options.tileClass === 'thumbnail' || options.tileClass === 'themes__thumb') {
	        // kill annotations
	        newLayout.annotations = [];
	        var keys = Object.keys(newLayout);
	
	        for(i = 0; i < keys.length; i++) {
	            if(keyIsAxis(keys[i])) {
	                newLayout[keys[i]].title = '';
	            }
	        }
	
	        // kill colorbar and pie labels
	        for(i = 0; i < newData.length; i++) {
	            var trace = newData[i];
	            trace.showscale = false;
	            if(trace.marker) trace.marker.showscale = false;
	            if(trace.type === 'pie') trace.textposition = 'none';
	        }
	    }
	
	    if(Array.isArray(options.annotations)) {
	        for(i = 0; i < options.annotations.length; i++) {
	            newLayout.annotations.push(options.annotations[i]);
	        }
	    }
	
	    var sceneIds = Plotly.Plots.getSubplotIds(newLayout, 'gl3d');
	
	    if(sceneIds.length) {
	        var axesImageOverride = {};
	        if(options.tileClass === 'thumbnail') {
	            axesImageOverride = {
	                title: '',
	                showaxeslabels: false,
	                showticklabels: false,
	                linetickenable: false
	            };
	        }
	        for(i = 0; i < sceneIds.length; i++) {
	            var sceneId = sceneIds[i];
	
	            extendFlat(newLayout[sceneId].xaxis, axesImageOverride);
	            extendFlat(newLayout[sceneId].yaxis, axesImageOverride);
	            extendFlat(newLayout[sceneId].zaxis, axesImageOverride);
	
	            // TODO what does this do?
	            newLayout[sceneId]._scene = null;
	        }
	    }
	
	    var td = document.createElement('div');
	    if(options.tileClass) td.className = options.tileClass;
	
	    var plotTile = {
	        td: td,
	        layout: newLayout,
	        data: newData,
	        config: {
	            staticPlot: (options.staticPlot === undefined) ?
	                true :
	                options.staticPlot,
	            plotGlPixelRatio: (options.plotGlPixelRatio === undefined) ?
	                2 :
	                options.plotGlPixelRatio,
	            displaylogo: options.displaylogo || false,
	            showLink: options.showLink || false,
	            showTips: options.showTips || false
	        }
	    };
	
	    if(options.setBackground !== 'transparent') {
	        plotTile.config.setBackground = options.setBackground || 'opaque';
	    }
	
	    // attaching the default Layout the td, so you can grab it later
	    plotTile.td.defaultLayout = cloneLayoutOverride(options.tileClass);
	
	    return plotTile;
	};


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Plots = __webpack_require__(332);
	var svgTextUtils = __webpack_require__(326);
	var Drawing = __webpack_require__(340);
	var Color = __webpack_require__(333);
	
	var xmlnsNamespaces = __webpack_require__(327);
	
	
	module.exports = function toSVG(gd, format) {
	
	    // make background color a rect in the svg, then revert after scraping
	    // all other alterations have been dealt with by properly preparing the svg
	    // in the first place... like setting cursors with css classes so we don't
	    // have to remove them, and providing the right namespaces in the svg to
	    // begin with
	    var fullLayout = gd._fullLayout,
	        svg = fullLayout._paper,
	        size = fullLayout._size,
	        domain,
	        i;
	
	    svg.insert('rect', ':first-child')
	        .call(Drawing.setRect, 0, 0, fullLayout.width, fullLayout.height)
	        .call(Color.fill, fullLayout.paper_bgcolor);
	
	    /* Grab the 3d scenes and rasterize em. Calculate their positions,
	     * then insert them into the SVG element as images */
	    var sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d'),
	        scene;
	
	    for(i = 0; i < sceneIds.length; i++) {
	        scene = fullLayout[sceneIds[i]];
	        domain = scene.domain;
	        insertGlImage(fullLayout, scene._scene, {
	            x: size.l + size.w * domain.x[0],
	            y: size.t + size.h * (1 - domain.y[1]),
	            width: size.w * (domain.x[1] - domain.x[0]),
	            height: size.h * (domain.y[1] - domain.y[0])
	        });
	    }
	
	    // similarly for 2d scenes
	    var subplotIds = Plots.getSubplotIds(fullLayout, 'gl2d'),
	        subplot;
	
	    for(i = 0; i < subplotIds.length; i++) {
	        subplot = fullLayout._plots[subplotIds[i]];
	        insertGlImage(fullLayout, subplot._scene2d, {
	            x: size.l,
	            y: size.t,
	            width: size.w,
	            height: size.h
	        });
	    }
	
	    // Grab the geos off the geo-container and place them in geoimages
	    var geoIds = Plots.getSubplotIds(fullLayout, 'geo'),
	        geoLayout,
	        geoFramework;
	
	    for(i = 0; i < geoIds.length; i++) {
	        geoLayout = fullLayout[geoIds[i]];
	        domain = geoLayout.domain;
	        geoFramework = geoLayout._geo.framework;
	
	        geoFramework.attr('style', null);
	        geoFramework
	            .attr({
	                x: size.l + size.w * domain.x[0] + geoLayout._marginX,
	                y: size.t + size.h * (1 - domain.y[1]) + geoLayout._marginY,
	                width: geoLayout._width,
	                height: geoLayout._height
	            });
	
	        fullLayout._geoimages.node()
	            .appendChild(geoFramework.node());
	    }
	
	    // now that we've got the 3d images in the right layer,
	    // add top items above them assumes everything in toppaper is either
	    // a group or a defs, and if it's empty (like hoverlayer) we can ignore it.
	    if(fullLayout._toppaper) {
	        var nodes = fullLayout._toppaper.node().childNodes;
	
	        // make copy of nodes as childNodes prop gets mutated in loop below
	        var topGroups = Array.prototype.slice.call(nodes);
	
	        for(i = 0; i < topGroups.length; i++) {
	            var topGroup = topGroups[i];
	
	            if(topGroup.childNodes.length) svg.node().appendChild(topGroup);
	        }
	    }
	
	    // remove draglayer for Adobe Illustrator compatibility
	    if(fullLayout._draggers) {
	        fullLayout._draggers.remove();
	    }
	
	    // in case the svg element had an explicit background color, remove this
	    // we want the rect to get the color so it's the right size; svg bg will
	    // fill whatever container it's displayed in regardless of plot size.
	    svg.node().style.background = '';
	
	    svg.selectAll('text')
	        .attr('data-unformatted', null)
	        .each(function() {
	            // hidden text is pre-formatting mathjax, the browser ignores it but it can still confuse batik
	            var txt = d3.select(this);
	            if(txt.style('visibility') === 'hidden') {
	                txt.remove();
	                return;
	            }
	
	            // I've seen font-family styles with non-escaped double quotes in them - breaks the
	            // serialized svg because the style attribute itself is double-quoted!
	            // Is this an IE thing? Any other attributes or style elements that can have quotes in them?
	            // TODO: this looks like a noop right now - what happened to it?
	
	            /*
	             * Font-family styles with double quotes in them breaks the to-image
	             * step in FF42 because the style attribute itself is wrapped in
	             * double quotes. See:
	             *
	             * - http://codepen.io/etpinard/pen/bEdQWK
	             * - https://github.com/plotly/plotly.js/pull/104
	             *
	             * for more info.
	             */
	            var ff = txt.style('font-family');
	            if(ff && ff.indexOf('"') !== -1) {
	                txt.style('font-family', ff.replace(/"/g, '\\\''));
	            }
	        });
	
	    if(format === 'pdf' || format === 'eps') {
	        // these formats make the extra line MathJax adds around symbols look super thick in some cases
	        // it looks better if this is removed entirely.
	        svg.selectAll('#MathJax_SVG_glyphs path')
	            .attr('stroke-width', 0);
	    }
	
	    // fix for IE namespacing quirk?
	    // http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with-ie
	    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns', xmlnsNamespaces.svg);
	    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns:xlink', xmlnsNamespaces.xlink);
	
	    var s = new window.XMLSerializer().serializeToString(svg.node());
	    s = svgTextUtils.html_entity_decode(s);
	    s = svgTextUtils.xml_entity_encode(s);
	
	    return s;
	};
	
	function insertGlImage(fullLayout, scene, opts) {
	    var imageData = scene.toImage('png');
	
	    fullLayout._glimages.append('svg:image')
	        .attr({
	            xmlns: xmlnsNamespaces.svg,
	            'xlink:href': imageData,
	            x: opts.x,
	            y: opts.y,
	            width: opts.width,
	            height: opts.height,
	            preserveAspectRatio: 'none'
	        });
	
	    scene.destroy();
	}


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var EventEmitter = __webpack_require__(384).EventEmitter;
	
	function svgToImg(opts) {
	
	    var ev = opts.emitter || new EventEmitter();
	
	    var promise = new Promise(function(resolve, reject) {
	
	        var Image = window.Image;
	
	        var svg = opts.svg;
	        var format = opts.format || 'png';
	
	        // IE is very strict, so we will need to clean
	        //  svg with the following regex
	        //  yes this is messy, but do not know a better way
	        // Even with this IE will not work due to tainted canvas
	        //  see https://github.com/kangax/fabric.js/issues/1957
	        //      http://stackoverflow.com/questions/18112047/canvas-todataurl-working-in-all-browsers-except-ie10
	        // Leave here just in case the CORS/tainted IE issue gets resolved
	        if(Lib.isIE()) {
	            // replace double quote with single quote
	            svg = svg.replace(/"/gi,'\'');
	            // url in svg are single quoted
	            //   since we changed double to single
	            //   we'll need to change these to double-quoted
	            svg = svg.replace(/(\('#)(.*)('\))/gi,'(\"$2\")');
	            // font names with spaces will be escaped single-quoted
	            //   we'll need to change these to double-quoted
	            svg = svg.replace(/(\\')/gi,'\"');
	            // IE only support svg
	            if(format!=='svg') {
	                var ieSvgError = new Error('Sorry IE does not support downloading from canvas. Try {format:\'svg\'} instead.');
	                reject(ieSvgError);
	                // eventually remove the ev
	                //  in favor of promises
	                if(!opts.promise) {
	                    return ev.emit('error', ieSvgError);
	                } else {
	                    return promise;
	                }
	            }
	        }
	
	        var canvas = opts.canvas;
	
	        var ctx = canvas.getContext('2d');
	        var img = new Image();
	
	        // for Safari support, eliminate createObjectURL
	        //  this decision could cause problems if content
	        //  is not restricted to svg
	        var url = 'data:image/svg+xml,' + encodeURIComponent(svg);
	
	        canvas.height = opts.height || 150;
	        canvas.width = opts.width || 300;
	
	        img.onload = function() {
	            var imgData;
	
	            // don't need to draw to canvas if svg
	            //  save some time and also avoid failure on IE
	            if(format !== 'svg') {
	                ctx.drawImage(img, 0, 0);
	            }
	
	            switch(format) {
	                case 'jpeg':
	                    imgData = canvas.toDataURL('image/jpeg');
	                    break;
	                case 'png':
	                    imgData = canvas.toDataURL('image/png');
	                    break;
	                case 'webp':
	                    imgData = canvas.toDataURL('image/webp');
	                    break;
	                case 'svg':
	                    imgData = svg;
	                    break;
	                default:
	                    reject(new Error('Image format is not jpeg, png or svg'));
	                    // eventually remove the ev
	                    //  in favor of promises
	                    if(!opts.promise) {
	                        return ev.emit('error', 'Image format is not jpeg, png or svg');
	                    }
	            }
	            resolve(imgData);
	            // eventually remove the ev
	            //  in favor of promises
	            if(!opts.promise) {
	                ev.emit('success', imgData);
	            }
	        };
	
	        img.onerror = function(err) {
	            reject(err);
	            // eventually remove the ev
	            //  in favor of promises
	            if(!opts.promise) {
	                return ev.emit('error', err);
	            }
	        };
	
	        img.src = url;
	    });
	
	    // temporary for backward compatibility
	    //  move to only Promise in 2.0.0
	    //  and eliminate the EventEmitter
	    if(opts.promise) {
	        return promise;
	    }
	
	    return ev;
	}
	
	module.exports = svgToImg;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	/*eslint dot-notation: [2, {"allowPattern": "^catch$"}]*/
	
	'use strict';
	
	var EventEmitter = __webpack_require__(384).EventEmitter;
	var Plotly = __webpack_require__(304);
	
	/**
	 * @param {object} gd figure Object
	 * @param {object} opts option object
	 * @param opts.format 'jpeg' | 'png' | 'webp' | 'svg'
	 */
	function toImage(gd, opts) {
	
	    // first clone the GD so we can operate in a clean environment
	    var Snapshot = Plotly.Snapshot;
	    var ev = new EventEmitter();
	
	    var clone = Snapshot.clone(gd, {format: 'png'});
	    var clonedGd = clone.td;
	
	    // put the cloned div somewhere off screen before attaching to DOM
	    clonedGd.style.position = 'absolute';
	    clonedGd.style.left = '-5000px';
	    document.body.appendChild(clonedGd);
	
	    function wait() {
	        var delay = Snapshot.getDelay(clonedGd._fullLayout);
	
	        setTimeout(function() {
	            var svg = Plotly.Snapshot.toSVG(clonedGd);
	
	            var canvasContainer = window.document.createElement('div');
	            var canvas = window.document.createElement('canvas');
	
	            // window.document.body.appendChild(canvasContainer);
	            canvasContainer.appendChild(canvas);
	
	            canvasContainer.id = Plotly.Lib.randstr();
	            canvas.id = Plotly.Lib.randstr();
	
	            ev = Plotly.Snapshot.svgToImg({
	                format: opts.format,
	                width: clonedGd._fullLayout.width,
	                height: clonedGd._fullLayout.height,
	                canvas: canvas,
	                emitter: ev,
	                svg: svg
	            });
	
	            ev.clean = function() {
	                if(clonedGd) document.body.removeChild(clonedGd);
	            };
	
	        }, delay);
	    }
	
	    var redrawFunc = Snapshot.getRedrawFunc(clonedGd);
	
	    Plotly.plot(clonedGd, clone.data, clone.layout, clone.config)
	        // TODO: the following is Plotly.Plots.redrawText but without the waiting.
	        // we shouldn't need to do this, but in *occasional* cases we do. Figure
	        // out why and take it out.
	        .then(redrawFunc)
	        .then(wait)
	        .catch(function(err) {
	            ev.emit('error', err);
	        });
	
	
	    return ev;
	}
	
	module.exports = toImage;


/***/ },
/* 459 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	/*
	* substantial portions of this code from FileSaver.js
	* https://github.com/eligrey/FileSaver.js
	* License: https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
	* FileSaver.js
	* A saveAs() FileSaver implementation.
	* 1.1.20160328
	*
	* By Eli Grey, http://eligrey.com
	* License: MIT
	*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
	*/
	
	'use strict';
	
	var fileSaver = function(url, name) {
	    var saveLink = document.createElement('a');
	    var canUseSaveLink = 'download' in saveLink;
	    var isSafari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
	    var promise = new Promise(function(resolve, reject) {
	        // IE <10 is explicitly unsupported
	        if(typeof navigator !== 'undefined' && /MSIE [1-9]\./.test(navigator.userAgent)) {
	            reject(new Error('IE < 10 unsupported'));
	        }
	
	        // First try a.download, then web filesystem, then object URLs
	        if(isSafari) {
	            // Safari doesn't allow downloading of blob urls
	            document.location.href = 'data:application/octet-stream' + url.slice(url.search(/[,;]/));
	            resolve(name);
	        }
	
	        if(!name) {
	            name = 'download';
	        }
	
	        if(canUseSaveLink) {
	            saveLink.href = url;
	            saveLink.download = name;
	            document.body.appendChild(saveLink);
	            saveLink.click();
	            document.body.removeChild(saveLink);
	            resolve(name);
	        }
	
	        // IE 10+ (native saveAs)
	        if(typeof navigator !== 'undefined' && navigator.msSaveBlob) {
	            navigator.msSaveBlob(new Blob([url]), name);
	            resolve(name);
	        }
	
	        reject(new Error('download error'));
	    });
	
	    return promise;
	};
	
	module.exports = fileSaver;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var Plots = __webpack_require__(332);
	var Lib = __webpack_require__(309);
	
	var extendFlat = Lib.extendFlat;
	var extendDeep = Lib.extendDeep;
	var extendDeepAll = Lib.extendDeepAll;
	
	var NESTED_MODULE = '_nestedModules',
	    COMPOSED_MODULE = '_composedModules',
	    IS_SUBPLOT_OBJ = '_isSubplotObj',
	    IS_LINKED_TO_ARRAY = '_isLinkedToArray',
	    DEPRECATED = '_deprecated';
	
	// list of underscore attributes to keep in schema as is
	var UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, DEPRECATED];
	
	var plotSchema = {
	    traces: {},
	    layout: {},
	    defs: {}
	};
	
	// FIXME polar attribute are not part of Plotly yet
	var polarAreaAttrs = __webpack_require__(461),
	    polarAxisAttrs = __webpack_require__(462);
	
	var PlotSchema = module.exports = {};
	
	
	PlotSchema.get = function() {
	    Plots.allTypes
	        .concat('area')  // FIXME polar 'area' attributes
	        .forEach(getTraceAttributes);
	
	    getLayoutAttributes();
	    getDefs();
	    return plotSchema;
	};
	
	PlotSchema.crawl = function(attrs, callback) {
	    Object.keys(attrs).forEach(function(attrName) {
	        var attr = attrs[attrName];
	
	        if(UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;
	
	        callback(attr, attrName, attrs);
	
	        if(PlotSchema.isValObject(attr)) return;
	        if(Lib.isPlainObject(attr)) PlotSchema.crawl(attr, callback);
	    });
	};
	
	PlotSchema.isValObject = function(obj) {
	    return obj && obj.valType !== undefined;
	};
	
	function getTraceAttributes(type) {
	    var globalAttributes = Plots.attributes,
	        _module = getModule({type: type}),
	        meta = getMeta(type),
	        subplotRegistry = getSubplotRegistry(type);
	
	    var attributes = {},
	        layoutAttributes = {};
	
	    // make 'type' the first attribute in the object
	    attributes.type = null;
	
	    // global attributes (same for all trace types)
	    extendDeep(attributes, globalAttributes);
	
	    // module attributes (+ nested + composed)
	    attributes = coupleAttrs(
	        _module.attributes, attributes, 'attributes', type
	    );
	
	    // subplot attributes
	    if(subplotRegistry.attributes !== undefined) {
	        extendDeep(attributes, subplotRegistry.attributes);
	    }
	
	    // 'type' gets overwritten by globalAttributes; reset it here
	    attributes.type = type;
	
	    attributes = removeUnderscoreAttrs(attributes);
	    mergeValTypeAndRole(attributes);
	    plotSchema.traces[type] = extendFlat({},
	        meta,
	        { attributes: attributes }
	    );
	
	    // trace-specific layout attributes
	    if(_module.layoutAttributes !== undefined) {
	        layoutAttributes = coupleAttrs(
	            _module.layoutAttributes, layoutAttributes, 'layoutAttributes', type
	        );
	
	        mergeValTypeAndRole(layoutAttributes);
	        plotSchema.traces[type].layoutAttributes = layoutAttributes;
	    }
	}
	
	function getLayoutAttributes() {
	    var globalLayoutAttributes = Plots.layoutAttributes,
	        layoutAttributes = {};
	
	    // layout module attributes (+ nested + composed)
	    layoutAttributes = coupleAttrs(
	        globalLayoutAttributes, layoutAttributes, 'layoutAttributes', '*'
	    );
	
	    // FIXME polar layout attributes
	    layoutAttributes = assignPolarLayoutAttrs(layoutAttributes);
	
	    // add IS_SUBPLOT_OBJ attribute
	    layoutAttributes = handleSubplotObjs(layoutAttributes);
	
	    layoutAttributes = removeUnderscoreAttrs(layoutAttributes);
	    mergeValTypeAndRole(layoutAttributes);
	
	    // generate IS_LINKED_TO_ARRAY structure
	    handleLinkedToArray(layoutAttributes);
	
	    plotSchema.layout = { layoutAttributes: layoutAttributes };
	}
	
	function getDefs() {
	    plotSchema.defs = {
	        valObjects: Lib.valObjects,
	        metaKeys: UNDERSCORE_ATTRS.concat(['description', 'role'])
	    };
	}
	
	function coupleAttrs(attrsIn, attrsOut, whichAttrs, type) {
	    var nestedModule, nestedAttrs, nestedReference,
	        composedModule, composedAttrs;
	
	    Object.keys(attrsIn).forEach(function(k) {
	
	        if(k === NESTED_MODULE) {
	            Object.keys(attrsIn[k]).forEach(function(kk) {
	                nestedModule = getModule({module: attrsIn[k][kk]});
	                if(nestedModule === undefined) return;
	
	                nestedAttrs = nestedModule[whichAttrs];
	                nestedReference = coupleAttrs(
	                    nestedAttrs, {}, whichAttrs, type
	                );
	
	                Lib.nestedProperty(attrsOut, kk)
	                    .set(extendDeep({}, nestedReference));
	            });
	            return;
	        }
	
	        if(k === COMPOSED_MODULE) {
	            Object.keys(attrsIn[k]).forEach(function(kk) {
	                if(kk !== type) return;
	
	                composedModule = getModule({module: attrsIn[k][kk]});
	                if(composedModule === undefined) return;
	
	                composedAttrs = composedModule[whichAttrs];
	                composedAttrs = coupleAttrs(
	                    composedAttrs, {}, whichAttrs, type
	                );
	
	                extendDeepAll(attrsOut, composedAttrs);
	            });
	            return;
	        }
	
	        attrsOut[k] = Lib.isPlainObject(attrsIn[k]) ?
	            extendDeepAll({}, attrsIn[k]) :
	            attrsIn[k];
	    });
	
	    return attrsOut;
	}
	
	function mergeValTypeAndRole(attrs) {
	
	    function makeSrcAttr(attrName) {
	        return {
	            valType: 'string',
	            role: 'info',
	            description: [
	                'Sets the source reference on plot.ly for ',
	                attrName, '.'
	            ].join(' ')
	        };
	    }
	
	    function callback(attr, attrName, attrs) {
	        if(PlotSchema.isValObject(attr)) {
	            if(attr.valType === 'data_array') {
	                // all 'data_array' attrs have role 'data'
	                attr.role = 'data';
	                // all 'data_array' attrs have a corresponding 'src' attr
	                attrs[attrName + 'src'] = makeSrcAttr(attrName);
	            }
	            else if(attr.arrayOk === true) {
	                // all 'arrayOk' attrs have a corresponding 'src' attr
	                attrs[attrName + 'src'] = makeSrcAttr(attrName);
	            }
	        }
	        else if(Lib.isPlainObject(attr)) {
	            // all attrs container objects get role 'object'
	            attr.role = 'object';
	        }
	    }
	
	    PlotSchema.crawl(attrs, callback);
	}
	
	// helper methods
	
	function getModule(arg) {
	    if('type' in arg) {
	        return (arg.type === 'area') ?  // FIXME
	            { attributes: polarAreaAttrs } :
	            Plots.getModule({type: arg.type});
	    }
	
	    var subplotsRegistry = Plots.subplotsRegistry,
	        _module = arg.module;
	
	    if(subplotsRegistry[_module]) return subplotsRegistry[_module];
	    else if('module' in arg) return Plotly[_module];
	}
	
	function removeUnderscoreAttrs(attributes) {
	    Object.keys(attributes).forEach(function(k) {
	        if(k.charAt(0) === '_' &&
	            UNDERSCORE_ATTRS.indexOf(k) === -1) delete attributes[k];
	    });
	    return attributes;
	}
	
	function getMeta(type) {
	    if(type === 'area') return {};  // FIXME
	    return Plots.modules[type].meta || {};
	}
	
	function assignPolarLayoutAttrs(layoutAttributes) {
	    extendFlat(layoutAttributes, {
	        radialaxis: polarAxisAttrs.radialaxis,
	        angularaxis: polarAxisAttrs.angularaxis
	    });
	
	    extendFlat(layoutAttributes, polarAxisAttrs.layout);
	
	    return layoutAttributes;  // FIXME
	}
	
	function getSubplotRegistry(traceType) {
	    if(traceType === 'area') return {};  // FIXME
	
	    var subplotsRegistry = Plots.subplotsRegistry,
	        subplotType = Object.keys(subplotsRegistry).filter(function(subplotType) {
	            return Plots.traceIs({type: traceType}, subplotType);
	        })[0];
	
	    if(subplotType === undefined) return {};
	
	    return subplotsRegistry[subplotType];
	}
	
	function handleSubplotObjs(layoutAttributes) {
	    var subplotsRegistry = Plots.subplotsRegistry;
	
	    Object.keys(layoutAttributes).forEach(function(k) {
	        Object.keys(subplotsRegistry).forEach(function(subplotType) {
	            var subplotRegistry = subplotsRegistry[subplotType],
	                isSubplotObj;
	
	            if(!subplotRegistry.attrRegex) return;
	
	            if(subplotType === 'cartesian' || subplotType === 'gl2d') {
	                isSubplotObj = (
	                    subplotRegistry.attrRegex.x.test(k) ||
	                    subplotRegistry.attrRegex.y.test(k)
	                );
	            }
	            else {
	                isSubplotObj = subplotRegistry.attrRegex.test(k);
	            }
	
	            if(isSubplotObj) layoutAttributes[k][IS_SUBPLOT_OBJ] = true;
	        });
	    });
	
	    return layoutAttributes;
	}
	
	function handleLinkedToArray(layoutAttributes) {
	
	    function callback(attr, attrName, attrs) {
	        if(attr[IS_LINKED_TO_ARRAY] !== true) return;
	
	        // TODO more robust logic
	        var itemName = attrName.substr(0, attrName.length - 1);
	
	        delete attr[IS_LINKED_TO_ARRAY];
	
	        attrs[attrName] = { items: {} };
	        attrs[attrName].items[itemName] = attr;
	        attrs[attrName].role = 'object';
	    }
	
	    PlotSchema.crawl(layoutAttributes, callback);
	}


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var scatterAttrs = __webpack_require__(410);
	var scatterMarkerAttrs = scatterAttrs.marker;
	
	module.exports = {
	    r: scatterAttrs.r,
	    t: scatterAttrs.t,
	    marker: {
	        color: scatterMarkerAttrs.color,
	        size: scatterMarkerAttrs.size,
	        symbol: scatterMarkerAttrs.symbol,
	        opacity: scatterMarkerAttrs.opacity
	    }
	};


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var axesAttrs = __webpack_require__(348);
	var extendFlat = __webpack_require__(324).extendFlat;
	
	var domainAttr = extendFlat({}, axesAttrs.domain, {
	    description: [
	        'Polar chart subplots are not supported yet.',
	        'This key has currently no effect.'
	    ].join(' ')
	});
	
	function mergeAttrs(axisName, nonCommonAttrs) {
	    var commonAttrs = {
	        showline: {
	            valType: 'boolean',
	            role: 'style',
	            description: [
	                'Determines whether or not the line bounding this',
	                axisName, 'axis',
	                'will be shown on the figure.'
	            ].join(' ')
	        },
	        showticklabels: {
	            valType: 'boolean',
	            role: 'style',
	            description: [
	                'Determines whether or not the',
	                axisName, 'axis ticks',
	                'will feature tick labels.'
	            ].join(' ')
	        },
	        tickorientation: {
	            valType: 'enumerated',
	            values: ['horizontal', 'vertical'],
	            role: 'style',
	            description: [
	                'Sets the orientation (from the paper perspective)',
	                'of the', axisName, 'axis tick labels.'
	            ].join(' ')
	        },
	        ticklen: {
	            valType: 'number',
	            min: 0,
	            role: 'style',
	            description: [
	                'Sets the length of the tick lines on this', axisName, 'axis.'
	            ].join(' ')
	        },
	        tickcolor: {
	            valType: 'color',
	            role: 'style',
	            description: [
	                'Sets the color of the tick lines on this', axisName, 'axis.'
	            ].join(' ')
	        },
	        ticksuffix: {
	            valType: 'string',
	            role: 'style',
	            description: [
	                'Sets the length of the tick lines on this', axisName, 'axis.'
	            ].join(' ')
	        },
	        endpadding: {
	            valType: 'number',
	            role: 'style'
	        },
	        visible: {
	            valType: 'boolean',
	            role: 'info',
	            description: [
	                'Determines whether or not this axis will be visible.'
	            ].join(' ')
	        }
	    };
	
	    return extendFlat({}, nonCommonAttrs, commonAttrs);
	}
	
	module.exports = {
	    radialaxis: mergeAttrs('radial', {
	        range: {
	            valType: 'info_array',
	            role: 'info',
	            items: [
	                { valType: 'number' },
	                { valType: 'number' }
	            ],
	            description: [
	                'Defines the start and end point of this radial axis.'
	            ].join(' ')
	        },
	        domain: domainAttr,
	        orientation: {
	            valType: 'number',
	            role: 'style',
	            description: [
	                'Sets the orientation (an angle with respect to the origin)',
	                'of the radial axis.'
	            ].join(' ')
	        }
	    }),
	
	    angularaxis: mergeAttrs('angular', {
	        range: {
	            valType: 'info_array',
	            role: 'info',
	            items: [
	                { valType: 'number', dflt: 0 },
	                { valType: 'number', dflt: 360 }
	            ],
	            description: [
	                'Defines the start and end point of this angular axis.'
	            ].join(' ')
	        },
	        domain: domainAttr
	    }),
	
	    // attributes that appear at layout root
	    layout: {
	        direction: {
	            valType: 'enumerated',
	            values: ['clockwise', 'counterclockwise'],
	            role: 'info',
	            description: [
	                'For polar plots only.',
	                'Sets the direction corresponding to positive angles.'
	            ].join(' ')
	        },
	        orientation: {
	            valType: 'angle',
	            role: 'info',
	            description: [
	                'For polar plots only.',
	                'Rotates the entire polar by the given angle.'
	            ].join(' ')
	        }
	    }
	};


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plotly = __webpack_require__(304);
	var Lib = __webpack_require__(309);
	
	/**
	 * Extends the plot config
	 *
	 * @param {object} configObj partial plot configuration object
	 *      to extend the current plot configuration.
	 *
	 */
	module.exports = function setPlotConfig(configObj) {
	    return Lib.extendFlat(Plotly.defaultConfig, configObj);
	};


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	module.exports = __webpack_require__(465);


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Bar = {};
	
	Bar.attributes = __webpack_require__(466);
	Bar.layoutAttributes = __webpack_require__(467);
	Bar.supplyDefaults = __webpack_require__(468);
	Bar.supplyLayoutDefaults = __webpack_require__(470);
	Bar.calc = __webpack_require__(471);
	Bar.setPositions = __webpack_require__(472);
	Bar.colorbar = __webpack_require__(441);
	Bar.arraysToCalcdata = __webpack_require__(473);
	Bar.plot = __webpack_require__(474);
	Bar.style = __webpack_require__(475);
	Bar.hoverPoints = __webpack_require__(476);
	
	Bar.moduleType = 'trace';
	Bar.name = 'bar';
	Bar.basePlotModule = __webpack_require__(446);
	Bar.categories = ['cartesian', 'bar', 'oriented', 'markerColorscale', 'errorBarsOK', 'showLegend'];
	Bar.meta = {
	    description: [
	        'The data visualized by the span of the bars is set in `y`',
	        'if `orientation` is set th *v* (the default)',
	        'and the labels are set in `x`.',
	        'By setting `orientation` to *h*, the roles are interchanged.'
	    ].join(' ')
	};
	
	module.exports = Bar;


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	var scatterAttrs = __webpack_require__(410),
	    scatterMarkerAttrs = scatterAttrs.marker,
	    scatterMarkerLineAttrs = scatterMarkerAttrs.line;
	
	
	module.exports = {
	    x: scatterAttrs.x,
	    x0: scatterAttrs.x0,
	    dx: scatterAttrs.dx,
	    y: scatterAttrs.y,
	    y0: scatterAttrs.y0,
	    dy: scatterAttrs.dy,
	    text: scatterAttrs.text,
	    orientation: {
	        valType: 'enumerated',
	        role: 'info',
	        values: ['v', 'h'],
	        description: [
	            'Sets the orientation of the bars.',
	            'With *v* (*h*), the value of the each bar spans',
	            'along the vertical (horizontal).'
	        ].join(' ')
	    },
	    marker: {
	        color: scatterMarkerAttrs.color,
	        colorscale: scatterMarkerAttrs.colorscale,
	        cauto: scatterMarkerAttrs.cauto,
	        cmax: scatterMarkerAttrs.cmax,
	        cmin: scatterMarkerAttrs.cmin,
	        autocolorscale: scatterMarkerAttrs.autocolorscale,
	        reversescale: scatterMarkerAttrs.reversescale,
	        showscale: scatterMarkerAttrs.showscale,
	        line: {
	            color: scatterMarkerLineAttrs.color,
	            colorscale: scatterMarkerLineAttrs.colorscale,
	            cauto: scatterMarkerLineAttrs.cauto,
	            cmax: scatterMarkerLineAttrs.cmax,
	            cmin: scatterMarkerLineAttrs.cmin,
	            width: scatterMarkerLineAttrs.width,
	            autocolorscale: scatterMarkerLineAttrs.autocolorscale,
	            reversescale: scatterMarkerLineAttrs.reversescale
	        }
	    },
	
	    r: scatterAttrs.r,
	    t: scatterAttrs.t,
	
	    _nestedModules: {  // nested module coupling
	        'error_y': 'ErrorBars',
	        'error_x': 'ErrorBars',
	        'marker.colorbar': 'Colorbar'
	    },
	
	    _deprecated: {
	        bardir: {
	            valType: 'enumerated',
	            role: 'info',
	            values: ['v', 'h'],
	            description: 'Renamed to `orientation`.'
	        }
	    }
	};


/***/ },
/* 467 */
/***/ function(module, exports) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	'use strict';
	
	
	module.exports = {
	    barmode: {
	        valType: 'enumerated',
	        values: ['stack', 'group', 'overlay', 'relative'],
	        dflt: 'group',
	        role: 'info',
	        description: [
	            'Determines how bars at the same location coordinate',
	            'are displayed on the graph.',
	            'With *stack*, the bars are stacked on top of one another',
	            'With *relative*, the bars are stacked on top of one another,',
	            'with negative values below the axis, positive values above',
	            'With *group*, the bars are plotted next to one another',
	            'centered around the shared location.',
	            'With *overlay*, the bars are plotted over one another,',
	            'you might need to an *opacity* to see multiple bars.'
	        ].join(' ')
	    },
	    barnorm: {
	        valType: 'enumerated',
	        values: ['', 'fraction', 'percent'],
	        dflt: '',
	        role: 'info',
	        description: [
	            'Sets the normalization for bar traces on the graph.',
	            'With *fraction*, the value of each bar is divide by the sum of the',
	            'values at the location coordinate.',
	            'With *percent*, the results form *fraction* are presented in percents.'
	        ].join(' ')
	    },
	    bargap: {
	        valType: 'number',
	        min: 0,
	        max: 1,
	        role: 'style',
	        description: [
	            'Sets the gap (in plot fraction) between bars of',
	            'adjacent location coordinates.'
	        ].join(' ')
	    },
	    bargroupgap: {
	        valType: 'number',
	        min: 0,
	        max: 1,
	        dflt: 0,
	        role: 'style',
	        description: [
	            'Sets the gap (in plot fraction) between bars of',
	            'the same location coordinate.'
	        ].join(' ')
	    }
	};


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Lib = __webpack_require__(309);
	var Color = __webpack_require__(333);
	
	var handleXYDefaults = __webpack_require__(429);
	var handleStyleDefaults = __webpack_require__(469);
	var errorBarsSupplyDefaults = __webpack_require__(400);
	var attributes = __webpack_require__(466);
	
	
	module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
	    function coerce(attr, dflt) {
	        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
	    }
	
	    var len = handleXYDefaults(traceIn, traceOut, coerce);
	    if(!len) {
	        traceOut.visible = false;
	        return;
	    }
	
	    coerce('orientation', (traceOut.x && !traceOut.y) ? 'h' : 'v');
	    coerce('text');
	
	    handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout);
	
	    // override defaultColor for error bars with defaultLine
	    errorBarsSupplyDefaults(traceIn, traceOut, Color.defaultLine, {axis: 'y'});
	    errorBarsSupplyDefaults(traceIn, traceOut, Color.defaultLine, {axis: 'x', inherit: 'y'});
	};


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Color = __webpack_require__(333);
	var hasColorscale = __webpack_require__(358);
	var colorscaleDefaults = __webpack_require__(343);
	
	
	module.exports = function handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout) {
	    coerce('marker.color', defaultColor);
	
	    if(hasColorscale(traceIn, 'marker')) {
	        colorscaleDefaults(
	            traceIn, traceOut, layout, coerce, {prefix: 'marker.', cLetter: 'c'}
	        );
	    }
	
	    coerce('marker.line.color', Color.defaultLine);
	
	    if(hasColorscale(traceIn, 'marker.line')) {
	        colorscaleDefaults(
	            traceIn, traceOut, layout, coerce, {prefix: 'marker.line.', cLetter: 'c'}
	        );
	    }
	
	    coerce('marker.line.width');
	};


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Plots = __webpack_require__(332);
	var Axes = __webpack_require__(338);
	var Lib = __webpack_require__(309);
	
	var layoutAttributes = __webpack_require__(467);
	
	
	module.exports = function(layoutIn, layoutOut, fullData) {
	    function coerce(attr, dflt) {
	        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
	    }
	
	    var hasBars = false,
	        shouldBeGapless = false,
	        gappedAnyway = false,
	        usedSubplots = {};
	
	    for(var i = 0; i < fullData.length; i++) {
	        var trace = fullData[i];
	        if(Plots.traceIs(trace, 'bar')) hasBars = true;
	        else continue;
	
	        // if we have at least 2 grouped bar traces on the same subplot,
	        // we should default to a gap anyway, even if the data is histograms
	        if(layoutIn.barmode !== 'overlay' && layoutIn.barmode !== 'stack') {
	            var subploti = trace.xaxis + trace.yaxis;
	            if(usedSubplots[subploti]) gappedAnyway = true;
	            usedSubplots[subploti] = true;
	        }
	
	        if(trace.visible && trace.type === 'histogram') {
	            var pa = Axes.getFromId({_fullLayout: layoutOut},
	                        trace[trace.orientation === 'v' ? 'xaxis' : 'yaxis']);
	            if(pa.type !== 'category') shouldBeGapless = true;
	        }
	    }
	
	    if(!hasBars) return;
	
	    var mode = coerce('barmode');
	    if(mode !== 'overlay') coerce('barnorm');
	
	    coerce('bargap', (shouldBeGapless && !gappedAnyway) ? 0 : 0.2);
	    coerce('bargroupgap');
	};


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Axes = __webpack_require__(338);
	var hasColorscale = __webpack_require__(358);
	var colorscaleCalc = __webpack_require__(357);
	
	
	module.exports = function calc(gd, trace) {
	    // depending on bar direction, set position and size axes
	    // and data ranges
	    // note: this logic for choosing orientation is
	    // duplicated in graph_obj->setstyles
	
	    var xa = Axes.getFromId(gd, trace.xaxis||'x'),
	        ya = Axes.getFromId(gd, trace.yaxis||'y'),
	        orientation = trace.orientation || ((trace.x && !trace.y) ? 'h' : 'v'),
	        pos, size, i;
	
	    if(orientation==='h') {
	        size = xa.makeCalcdata(trace, 'x');
	        pos = ya.makeCalcdata(trace, 'y');
	    }
	    else {
	        size = ya.makeCalcdata(trace, 'y');
	        pos = xa.makeCalcdata(trace, 'x');
	    }
	
	    // create the "calculated data" to plot
	    var serieslen = Math.min(pos.length, size.length),
	        cd = [];
	    for(i=0; i<serieslen; i++) {
	        if(isNumeric(pos[i])) {
	            cd.push({p: pos[i], s: size[i], b: 0});
	        }
	    }
	
	    // auto-z and autocolorscale if applicable
	    if(hasColorscale(trace, 'marker')) {
	        colorscaleCalc(trace, trace.marker.color, 'marker', 'c');
	    }
	    if(hasColorscale(trace, 'marker.line')) {
	        colorscaleCalc(trace, trace.marker.line.color, 'marker.line', 'c');
	    }
	
	    return cd;
	};


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var isNumeric = __webpack_require__(312);
	
	var Plots = __webpack_require__(332);
	var Axes = __webpack_require__(338);
	var Lib = __webpack_require__(309);
	
	/*
	 * Bar chart stacking/grouping positioning and autoscaling calculations
	 * for each direction separately calculate the ranges and positions
	 * note that this handles histograms too
	 * now doing this one subplot at a time
	 */
	
	module.exports = function setPositions(gd, plotinfo) {
	    var fullLayout = gd._fullLayout,
	        xa = plotinfo.x(),
	        ya = plotinfo.y(),
	        i, j;
	
	    ['v', 'h'].forEach(function(dir) {
	        var bl = [],
	            pLetter = {v: 'x', h: 'y'}[dir],
	            sLetter = {v: 'y', h: 'x'}[dir],
	            pa = plotinfo[pLetter](),
	            sa = plotinfo[sLetter]();
	
	        gd._fullData.forEach(function(trace,i) {
	            if(trace.visible === true &&
	                    Plots.traceIs(trace, 'bar') &&
	                    trace.orientation === dir &&
	                    trace.xaxis === xa._id &&
	                    trace.yaxis === ya._id) {
	                bl.push(i);
	            }
	        });
	
	        if(!bl.length) return;
	
	        // bar position offset and width calculation
	        // bl1 is a list of traces (in calcdata) to look at together
	        // to find the maximum size bars that won't overlap
	        // for stacked or grouped bars, this is all vertical or horizontal
	        // bars for overlaid bars, call this individually on each trace.
	        function barposition(bl1) {
	            // find the min. difference between any points
	            // in any traces in bl1
	            var pvals = [];
	            bl1.forEach(function(i) {
	                gd.calcdata[i].forEach(function(v) { pvals.push(v.p); });
	            });
	            var dv = Lib.distinctVals(pvals),
	                pv2 = dv.vals,
	                barDiff = dv.minDiff;
	
	            // check if all the traces have only independent positions
	            // if so, let them have full width even if mode is group
	            var overlap = false,
	                comparelist = [];
	
	            if(fullLayout.barmode === 'group') {
	                bl1.forEach(function(i) {
	                    if(overlap) return;
	                    gd.calcdata[i].forEach(function(v) {
	                        if(overlap) return;
	                        comparelist.forEach(function(cp) {
	                            if(Math.abs(v.p-cp) < barDiff) overlap = true;
	                        });
	                    });
	                    if(overlap) return;
	                    gd.calcdata[i].forEach(function(v) {
	                        comparelist.push(v.p);
	                    });
	                });
	            }
	
	            // check forced minimum dtick
	            Axes.minDtick(pa, barDiff, pv2[0], overlap);
	
	            // position axis autorange - always tight fitting
	            Axes.expand(pa, pv2, {vpad: barDiff / 2});
	
	            // bar widths and position offsets
	            barDiff *= 1 - fullLayout.bargap;
	            if(overlap) barDiff /= bl.length;
	
	            var barCenter;
	            function setBarCenter(v) { v[pLetter] = v.p + barCenter; }
	
	            for(var i = 0; i < bl1.length; i++) {
	                var t = gd.calcdata[bl1[i]][0].t;
	                t.barwidth = barDiff * (1 - fullLayout.bargroupgap);
	                t.poffset = ((overlap ? (2 * i + 1 - bl1.length) * barDiff : 0) -
	                    t.barwidth) / 2;
	                t.dbar = dv.minDiff;
	
	                // store the bar center in each calcdata item
	                barCenter = t.poffset + t.barwidth / 2;
	                gd.calcdata[bl1[i]].forEach(setBarCenter);
	            }
	        }
	
	        if(fullLayout.barmode === 'overlay') {
	            bl.forEach(function(bli) { barposition([bli]); });
	        }
	        else barposition(bl);
	
	        var stack = (fullLayout.barmode === 'stack'),
	            relative = (fullLayout.barmode ==='relative'),
	            norm = fullLayout.barnorm;
	
	        // bar size range and stacking calculation
	        if(stack || relative || norm) {
	            // for stacked bars, we need to evaluate every step in every
	            // stack, because negative bars mean the extremes could be
	            // anywhere
	            // also stores the base (b) of each bar in calcdata
	            // so we don't have to redo this later
	            var sMax = sa.l2c(sa.c2l(0)),
	                sMin = sMax,
	                sums={},
	
	                // make sure if p is different only by rounding,
	                // we still stack
	                sumround = gd.calcdata[bl[0]][0].t.barwidth / 100,
	                sv = 0,
	                padded = true,
	                barEnd,
	                ti,
	                scale;
	
	            for(i = 0; i < bl.length; i++) { // trace index
	                ti = gd.calcdata[bl[i]];
	                for(j = 0; j < ti.length; j++) {
	                    sv = Math.round(ti[j].p / sumround);
	                    // store the negative sum value for p at the same key, with sign flipped
	                    if(relative && ti[j].s < 0) sv = -sv;
	                    var previousSum = sums[sv] || 0;
	                    if(stack || relative) ti[j].b = previousSum;
	                    barEnd = ti[j].b + ti[j].s;
	                    sums[sv] = previousSum + ti[j].s;
	
	                    // store the bar top in each calcdata item
	                    if(stack || relative) {
	                        ti[j][sLetter] = barEnd;
	                        if(!norm && isNumeric(sa.c2l(barEnd))) {
	                            sMax = Math.max(sMax,barEnd);
	                            sMin = Math.min(sMin,barEnd);
	                        }
	                    }
	                }
	            }
	
	            if(norm) {
	                padded = false;
	                var top = norm==='fraction' ? 1 : 100,
	                    relAndNegative = false,
	                    tiny = top/1e9; // in case of rounding error in sum
	                sMin = 0;
	                sMax = stack ? top : 0;
	                for(i = 0; i < bl.length; i++) { // trace index
	                    ti = gd.calcdata[bl[i]];
	                    for(j = 0; j < ti.length; j++) {
	                        relAndNegative = relative && ti[j].s < 0;
	                        sv = Math.round(ti[j].p / sumround);
	                        if(relAndNegative) sv = -sv;  // locate negative sum amount for this p val
	                        scale = top / sums[sv];
	                        if(relAndNegative) scale *= -1; // preserve sign if negative
	                        ti[j].b *= scale;
	                        ti[j].s *= scale;
	                        barEnd = ti[j].b + ti[j].s;
	                        ti[j][sLetter] = barEnd;
	
	                        if(isNumeric(sa.c2l(barEnd))) {
	                            if(barEnd < sMin - tiny) {
	                                padded = true;
	                                sMin = barEnd;
	                            }
	                            if(barEnd > sMax + tiny) {
	                                padded = true;
	                                sMax = barEnd;
	                            }
	                        }
	                    }
	                }
	            }
	
	            Axes.expand(sa, [sMin, sMax], {tozero: true, padded: padded});
	        }
	        else {
	            // for grouped or overlaid bars, just make sure zero is
	            // included, along with the tops of each bar, and store
	            // these bar tops in calcdata
	            var fs = function(v) { v[sLetter] = v.s; return v.s; };
	
	            for(i = 0; i < bl.length; i++) {
	                Axes.expand(sa, gd.calcdata[bl[i]].map(fs),
	                    {tozero: true, padded: true});
	            }
	        }
	    });
	};


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var mergeArray = __webpack_require__(309).mergeArray;
	
	
	// arrayOk attributes, merge them into calcdata array
	module.exports = function arraysToCalcdata(cd) {
	    var trace = cd[0].trace,
	        marker = trace.marker,
	        markerLine = marker.line;
	
	    mergeArray(trace.text, cd, 'tx');
	    mergeArray(marker.opacity, cd, 'mo');
	    mergeArray(marker.color, cd, 'mc');
	    mergeArray(markerLine.color, cd, 'mlc');
	    mergeArray(markerLine.width, cd, 'mlw');
	};


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	var isNumeric = __webpack_require__(312);
	
	var Lib = __webpack_require__(309);
	var Color = __webpack_require__(333);
	var ErrorBars = __webpack_require__(398);
	
	var arraysToCalcdata = __webpack_require__(473);
	
	
	module.exports = function plot(gd, plotinfo, cdbar) {
	    var xa = plotinfo.x(),
	        ya = plotinfo.y(),
	        fullLayout = gd._fullLayout;
	
	    var bartraces = plotinfo.plot.select('.barlayer')
	        .selectAll('g.trace.bars')
	            .data(cdbar)
	      .enter().append('g')
	        .attr('class','trace bars');
	
	    bartraces.append('g')
	        .attr('class','points')
	        .each(function(d) {
	            var t = d[0].t,
	                trace = d[0].trace;
	
	            arraysToCalcdata(d);
	
	            d3.select(this).selectAll('path')
	                .data(Lib.identity)
	              .enter().append('path')
	                .each(function(di) {
	                    // now display the bar
	                    // clipped xf/yf (2nd arg true): non-positive
	                    // log values go off-screen by plotwidth
	                    // so you see them continue if you drag the plot
	                    var x0,x1,y0,y1;
	                    if(trace.orientation==='h') {
	                        y0 = ya.c2p(t.poffset+di.p, true);
	                        y1 = ya.c2p(t.poffset+di.p+t.barwidth, true);
	                        x0 = xa.c2p(di.b, true);
	                        x1 = xa.c2p(di.s+di.b, true);
	                    }
	                    else {
	                        x0 = xa.c2p(t.poffset+di.p, true);
	                        x1 = xa.c2p(t.poffset+di.p+t.barwidth, true);
	                        y1 = ya.c2p(di.s+di.b, true);
	                        y0 = ya.c2p(di.b, true);
	                    }
	
	                    if(!isNumeric(x0) || !isNumeric(x1) ||
	                            !isNumeric(y0) || !isNumeric(y1) ||
	                            x0===x1 || y0===y1) {
	                        d3.select(this).remove();
	                        return;
	                    }
	                    var lw = (di.mlw+1 || trace.marker.line.width+1 ||
	                            (di.trace ? di.trace.marker.line.width : 0)+1)-1,
	                        offset = d3.round((lw/2)%1,2);
	                    function roundWithLine(v) {
	                        // if there are explicit gaps, don't round,
	                        // it can make the gaps look crappy
	                        return (fullLayout.bargap===0 && fullLayout.bargroupgap===0) ?
	                            d3.round(Math.round(v)-offset, 2) : v;
	                    }
	                    function expandToVisible(v,vc) {
	                        // if it's not in danger of disappearing entirely,
	                        // round more precisely
	                        return Math.abs(v-vc)>=2 ? roundWithLine(v) :
	                        // but if it's very thin, expand it so it's
	                        // necessarily visible, even if it might overlap
	                        // its neighbor
	                        (v>vc ? Math.ceil(v) : Math.floor(v));
	                    }
	                    if(!gd._context.staticPlot) {
	                        // if bars are not fully opaque or they have a line
	                        // around them, round to integer pixels, mainly for
	                        // safari so we prevent overlaps from its expansive
	                        // pixelation. if the bars ARE fully opaque and have
	                        // no line, expand to a full pixel to make sure we
	                        // can see them
	                        var op = Color.opacity(di.mc || trace.marker.color),
	                            fixpx = (op<1 || lw>0.01) ?
	                                roundWithLine : expandToVisible;
	                        x0 = fixpx(x0,x1);
	                        x1 = fixpx(x1,x0);
	                        y0 = fixpx(y0,y1);
	                        y1 = fixpx(y1,y0);
	                    }
	                    d3.select(this).attr('d',
	                        'M'+x0+','+y0+'V'+y1+'H'+x1+'V'+y0+'Z');
	                });
	        });
	
	    // error bars are on the top
	    bartraces.call(ErrorBars.plot, plotinfo);
	
	};


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var d3 = __webpack_require__(310);
	
	var Color = __webpack_require__(333);
	var Drawing = __webpack_require__(340);
	var ErrorBars = __webpack_require__(398);
	
	
	module.exports = function style(gd) {
	    var s = d3.select(gd).selectAll('g.trace.bars'),
	        barcount = s.size(),
	        fullLayout = gd._fullLayout;
	
	    // trace styling
	    s.style('opacity', function(d) { return d[0].trace.opacity; })
	
	    // for gapless (either stacked or neighboring grouped) bars use
	    // crispEdges to turn off antialiasing so an artificial gap
	    // isn't introduced.
	    .each(function(d) {
	        if((fullLayout.barmode==='stack' && barcount>1) ||
	                (fullLayout.bargap===0 &&
	                 fullLayout.bargroupgap===0 &&
	                 !d[0].trace.marker.line.width)) {
	            d3.select(this).attr('shape-rendering','crispEdges');
	        }
	    });
	
	    // then style the individual bars
	    s.selectAll('g.points').each(function(d) {
	        var trace = d[0].trace,
	            marker = trace.marker,
	            markerLine = marker.line,
	            markerIn = (trace._input||{}).marker||{},
	            markerScale = Drawing.tryColorscale(marker, markerIn, ''),
	            lineScale = Drawing.tryColorscale(marker, markerIn, 'line.');
	
	        d3.select(this).selectAll('path').each(function(d) {
	            // allow all marker and marker line colors to be scaled
	            // by given max and min to colorscales
	            var fillColor,
	                lineColor,
	                lineWidth = (d.mlw+1 || markerLine.width+1) - 1,
	                p = d3.select(this);
	
	            if('mc' in d) fillColor = d.mcc = markerScale(d.mc);
	            else if(Array.isArray(marker.color)) fillColor = Color.defaultLine;
	            else fillColor = marker.color;
	
	            p.style('stroke-width', lineWidth + 'px')
	                .call(Color.fill, fillColor);
	            if(lineWidth) {
	                if('mlc' in d) lineColor = d.mlcc = lineScale(d.mlc);
	                // weird case: array wasn't long enough to apply to every point
	                else if(Array.isArray(markerLine.color)) lineColor = Color.defaultLine;
	                else lineColor = markerLine.color;
	
	                p.call(Color.stroke, lineColor);
	            }
	        });
	        // TODO: text markers on bars, either extra text or just bar values
	        // d3.select(this).selectAll('text')
	        //     .call(Plotly.Drawing.textPointStyle,d.t||d[0].t);
	    });
	
	    s.call(ErrorBars.style);
	};


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Copyright 2012-2016, Plotly, Inc.
	* All rights reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	
	
	'use strict';
	
	var Fx = __webpack_require__(382);
	var ErrorBars = __webpack_require__(398);
	var Color = __webpack_require__(333);
	
	
	module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
	    var cd = pointData.cd,
	        trace = cd[0].trace,
	        t = cd[0].t,
	        xa = pointData.xa,
	        ya = pointData.ya,
	        barDelta = (hovermode==='closest') ?
	            t.barwidth/2 : t.dbar*(1-xa._gd._fullLayout.bargap)/2,
	        barPos;
	
	    if(hovermode!=='closest') barPos = function(di) { return di.p; };
	    else if(trace.orientation==='h') barPos = function(di) { return di.y; };
	    else barPos = function(di) { return di.x; };
	
	    var dx, dy;
	    if(trace.orientation==='h') {
	        dx = function(di) {
	            // add a gradient so hovering near the end of a
	            // bar makes it a little closer match
	            return Fx.inbox(di.b-xval, di.x-xval) + (di.x-xval)/(di.x-di.b);
	        };
	        dy = function(di) {
	            var centerPos = barPos(di) - yval;
	            return Fx.inbox(centerPos - barDelta, centerPos + barDelta);
	        };
	    }
	    else {
	        dy = function(di) {
	            return Fx.inbox(di.b-yval, di.y-yval) + (di.y-yval)/(di.y-di.b);
	        };
	        dx = function(di) {
	            var centerPos = barPos(di) - xval;
	            return Fx.inbox(centerPos - barDelta, centerPos + barDelta);
	        };
	    }
	
	    var distfn = Fx.getDistanceFunction(hovermode, dx, dy);
	    Fx.getClosest(cd, distfn, pointData);
	
	    // skip the rest (for this trace) if we didn't find a close point
	    if(pointData.index===false) return;
	
	    // the closest data point
	    var di = cd[pointData.index],
	        mc = di.mcc || trace.marker.color,
	        mlc = di.mlcc || trace.marker.line.color,
	        mlw = di.mlw || trace.marker.line.width;
	    if(Color.opacity(mc)) pointData.color = mc;
	    else if(Color.opacity(mlc) && mlw) pointData.color = mlc;
	
	    if(trace.orientation==='h') {
	        pointData.x0 = pointData.x1 = xa.c2p(di.x, true);
	        pointData.xLabelVal = di.s;
	
	        pointData.y0 = ya.c2p(barPos(di) - barDelta, true);
	        pointData.y1 = ya.c2p(barPos(di) + barDelta, true);
	        pointData.yLabelVal = di.p;
	    }
	    else {
	        pointData.y0 = pointData.y1 = ya.c2p(di.y,true);
	        pointData.yLabelVal = di.s;
	
	        pointData.x0 = xa.c2p(barPos(di) - barDelta, true);
	        pointData.x1 = xa.c2p(barPos(di) + barDelta, true);
	        pointData.xLabelVal = di.p;
	    }
	
	    if(di.tx) pointData.text = di.tx;
	
	    ErrorBars.hoverInfo(di, trace, pointData);
	
	    return [pointData];
	};


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];
	
	var document = window.document;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		version = "2.2.4",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},
	
		isPlainObject: function( obj ) {
			var key;
	
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}
	
			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}
	
			return key === undefined || hasOwn.call( obj, key );
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;
	
			code = jQuery.trim( code );
	
			if ( code ) {
	
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
	
					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval
	
					indirect( code );
				}
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
	
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
	
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add( function() {
	
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}
	
			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	} );
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
	
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );
	
			} else {
	
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};
	
	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		register: function( owner, initial ) {
			var value = initial || {};
	
			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;
	
			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {
	
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				stored = this.get( owner, key );
	
				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key === undefined ) {
				this.register( owner );
	
			} else {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
	
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
	
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}
	
				i = name.length;
	
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data, camelKey;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||
	
						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );
	
					if ( data !== undefined ) {
						return data;
					}
	
					camelKey = jQuery.camelCase( key );
	
					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {
	
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );
	
					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );
	
					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
	
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([\w:-]+)/ );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE9
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}
	
			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
	
		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
	
		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,
	
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	
	
	var iframe,
		elemdisplay = {
	
			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			display = jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var documentElement = document.documentElement;
	
	
	
	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =
	
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
		}
	
		jQuery.extend( support, {
			pixelPosition: function() {
	
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
	
				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
	
				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {
	
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );
	
				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
	
					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );
	
				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );
	
				documentElement.removeChild( container );
				div.removeChild( marginDiv );
	
				return ret;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
	
		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}
	
		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
	
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
	
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}
	
			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;
	
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		window.clearInterval( timerId );
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
	
						// Set corresponding property to false
						elem[ propName ] = false;
					}
	
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace( rreturn, "" ) :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// The jqXHR state
				state = 0,
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
	
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
	
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}
	
			if ( this[ 0 ] ) {
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {
	
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
	
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	return jQuery;
	}));


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;/*!
	 * Select2 4.0.3
	 * https://select2.github.io
	 *
	 * Released under the MIT license
	 * https://github.com/select2/select2/blob/master/LICENSE.md
	 */
	(function (factory) {
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(477)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node/CommonJS
	    factory(require('jquery'));
	  } else {
	    // Browser globals
	    factory(jQuery);
	  }
	}(function (jQuery) {
	  // This is needed so we can catch the AMD loader configuration and use it
	  // The inner file should be wrapped (by `banner.start.js`) in a function that
	  // returns the AMD loader references.
	  var S2 =
	(function () {
	  // Restore the Select2 AMD loader so it can be used
	  // Needed mostly in the language files, where the loader is not inserted
	  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
	    var S2 = jQuery.fn.select2.amd;
	  }
	var S2;(function () { if (!S2 || !S2.requirejs) {
	if (!S2) { S2 = {}; } else { require = S2; }
	/**
	 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
	 * Available via the MIT or new BSD license.
	 * see: http://github.com/jrburke/almond for details
	 */
	//Going sloppy to avoid 'use strict' string cost, but strict practices should
	//be followed.
	/*jslint sloppy: true */
	/*global setTimeout: false */
	
	var requirejs, require, define;
	(function (undef) {
	    var main, req, makeMap, handlers,
	        defined = {},
	        waiting = {},
	        config = {},
	        defining = {},
	        hasOwn = Object.prototype.hasOwnProperty,
	        aps = [].slice,
	        jsSuffixRegExp = /\.js$/;
	
	    function hasProp(obj, prop) {
	        return hasOwn.call(obj, prop);
	    }
	
	    /**
	     * Given a relative module name, like ./something, normalize it to
	     * a real name that can be mapped to a path.
	     * @param {String} name the relative name
	     * @param {String} baseName a real name that the name arg is relative
	     * to.
	     * @returns {String} normalized name
	     */
	    function normalize(name, baseName) {
	        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
	            foundI, foundStarMap, starI, i, j, part,
	            baseParts = baseName && baseName.split("/"),
	            map = config.map,
	            starMap = (map && map['*']) || {};
	
	        //Adjust any relative paths.
	        if (name && name.charAt(0) === ".") {
	            //If have a base name, try to normalize against it,
	            //otherwise, assume it is a top-level require that will
	            //be relative to baseUrl in the end.
	            if (baseName) {
	                name = name.split('/');
	                lastIndex = name.length - 1;
	
	                // Node .js allowance:
	                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
	                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
	                }
	
	                //Lop off the last part of baseParts, so that . matches the
	                //"directory" and not name of the baseName's module. For instance,
	                //baseName of "one/two/three", maps to "one/two/three.js", but we
	                //want the directory, "one/two" for this normalization.
	                name = baseParts.slice(0, baseParts.length - 1).concat(name);
	
	                //start trimDots
	                for (i = 0; i < name.length; i += 1) {
	                    part = name[i];
	                    if (part === ".") {
	                        name.splice(i, 1);
	                        i -= 1;
	                    } else if (part === "..") {
	                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
	                            //End of the line. Keep at least one non-dot
	                            //path segment at the front so it can be mapped
	                            //correctly to disk. Otherwise, there is likely
	                            //no path mapping for a path starting with '..'.
	                            //This can still fail, but catches the most reasonable
	                            //uses of ..
	                            break;
	                        } else if (i > 0) {
	                            name.splice(i - 1, 2);
	                            i -= 2;
	                        }
	                    }
	                }
	                //end trimDots
	
	                name = name.join("/");
	            } else if (name.indexOf('./') === 0) {
	                // No baseName, so this is ID is resolved relative
	                // to baseUrl, pull off the leading dot.
	                name = name.substring(2);
	            }
	        }
	
	        //Apply map config if available.
	        if ((baseParts || starMap) && map) {
	            nameParts = name.split('/');
	
	            for (i = nameParts.length; i > 0; i -= 1) {
	                nameSegment = nameParts.slice(0, i).join("/");
	
	                if (baseParts) {
	                    //Find the longest baseName segment match in the config.
	                    //So, do joins on the biggest to smallest lengths of baseParts.
	                    for (j = baseParts.length; j > 0; j -= 1) {
	                        mapValue = map[baseParts.slice(0, j).join('/')];
	
	                        //baseName segment has  config, find if it has one for
	                        //this name.
	                        if (mapValue) {
	                            mapValue = mapValue[nameSegment];
	                            if (mapValue) {
	                                //Match, update name to the new value.
	                                foundMap = mapValue;
	                                foundI = i;
	                                break;
	                            }
	                        }
	                    }
	                }
	
	                if (foundMap) {
	                    break;
	                }
	
	                //Check for a star map match, but just hold on to it,
	                //if there is a shorter segment match later in a matching
	                //config, then favor over this star map.
	                if (!foundStarMap && starMap && starMap[nameSegment]) {
	                    foundStarMap = starMap[nameSegment];
	                    starI = i;
	                }
	            }
	
	            if (!foundMap && foundStarMap) {
	                foundMap = foundStarMap;
	                foundI = starI;
	            }
	
	            if (foundMap) {
	                nameParts.splice(0, foundI, foundMap);
	                name = nameParts.join('/');
	            }
	        }
	
	        return name;
	    }
	
	    function makeRequire(relName, forceSync) {
	        return function () {
	            //A version of a require function that passes a moduleName
	            //value for items that may need to
	            //look up paths relative to the moduleName
	            var args = aps.call(arguments, 0);
	
	            //If first arg is not require('string'), and there is only
	            //one arg, it is the array form without a callback. Insert
	            //a null so that the following concat is correct.
	            if (typeof args[0] !== 'string' && args.length === 1) {
	                args.push(null);
	            }
	            return req.apply(undef, args.concat([relName, forceSync]));
	        };
	    }
	
	    function makeNormalize(relName) {
	        return function (name) {
	            return normalize(name, relName);
	        };
	    }
	
	    function makeLoad(depName) {
	        return function (value) {
	            defined[depName] = value;
	        };
	    }
	
	    function callDep(name) {
	        if (hasProp(waiting, name)) {
	            var args = waiting[name];
	            delete waiting[name];
	            defining[name] = true;
	            main.apply(undef, args);
	        }
	
	        if (!hasProp(defined, name) && !hasProp(defining, name)) {
	            throw new Error('No ' + name);
	        }
	        return defined[name];
	    }
	
	    //Turns a plugin!resource to [plugin, resource]
	    //with the plugin being undefined if the name
	    //did not have a plugin prefix.
	    function splitPrefix(name) {
	        var prefix,
	            index = name ? name.indexOf('!') : -1;
	        if (index > -1) {
	            prefix = name.substring(0, index);
	            name = name.substring(index + 1, name.length);
	        }
	        return [prefix, name];
	    }
	
	    /**
	     * Makes a name map, normalizing the name, and using a plugin
	     * for normalization if necessary. Grabs a ref to plugin
	     * too, as an optimization.
	     */
	    makeMap = function (name, relName) {
	        var plugin,
	            parts = splitPrefix(name),
	            prefix = parts[0];
	
	        name = parts[1];
	
	        if (prefix) {
	            prefix = normalize(prefix, relName);
	            plugin = callDep(prefix);
	        }
	
	        //Normalize according
	        if (prefix) {
	            if (plugin && plugin.normalize) {
	                name = plugin.normalize(name, makeNormalize(relName));
	            } else {
	                name = normalize(name, relName);
	            }
	        } else {
	            name = normalize(name, relName);
	            parts = splitPrefix(name);
	            prefix = parts[0];
	            name = parts[1];
	            if (prefix) {
	                plugin = callDep(prefix);
	            }
	        }
	
	        //Using ridiculous property names for space reasons
	        return {
	            f: prefix ? prefix + '!' + name : name, //fullName
	            n: name,
	            pr: prefix,
	            p: plugin
	        };
	    };
	
	    function makeConfig(name) {
	        return function () {
	            return (config && config.config && config.config[name]) || {};
	        };
	    }
	
	    handlers = {
	        require: function (name) {
	            return makeRequire(name);
	        },
	        exports: function (name) {
	            var e = defined[name];
	            if (typeof e !== 'undefined') {
	                return e;
	            } else {
	                return (defined[name] = {});
	            }
	        },
	        module: function (name) {
	            return {
	                id: name,
	                uri: '',
	                exports: defined[name],
	                config: makeConfig(name)
	            };
	        }
	    };
	
	    main = function (name, deps, callback, relName) {
	        var cjsModule, depName, ret, map, i,
	            args = [],
	            callbackType = typeof callback,
	            usingExports;
	
	        //Use name if no relName
	        relName = relName || name;
	
	        //Call the callback to define the module, if necessary.
	        if (callbackType === 'undefined' || callbackType === 'function') {
	            //Pull out the defined dependencies and pass the ordered
	            //values to the callback.
	            //Default to [require, exports, module] if no deps
	            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
	            for (i = 0; i < deps.length; i += 1) {
	                map = makeMap(deps[i], relName);
	                depName = map.f;
	
	                //Fast path CommonJS standard dependencies.
	                if (depName === "require") {
	                    args[i] = handlers.require(name);
	                } else if (depName === "exports") {
	                    //CommonJS module spec 1.1
	                    args[i] = handlers.exports(name);
	                    usingExports = true;
	                } else if (depName === "module") {
	                    //CommonJS module spec 1.1
	                    cjsModule = args[i] = handlers.module(name);
	                } else if (hasProp(defined, depName) ||
	                           hasProp(waiting, depName) ||
	                           hasProp(defining, depName)) {
	                    args[i] = callDep(depName);
	                } else if (map.p) {
	                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
	                    args[i] = defined[depName];
	                } else {
	                    throw new Error(name + ' missing ' + depName);
	                }
	            }
	
	            ret = callback ? callback.apply(defined[name], args) : undefined;
	
	            if (name) {
	                //If setting exports via "module" is in play,
	                //favor that over return value and exports. After that,
	                //favor a non-undefined return value over exports use.
	                if (cjsModule && cjsModule.exports !== undef &&
	                        cjsModule.exports !== defined[name]) {
	                    defined[name] = cjsModule.exports;
	                } else if (ret !== undef || !usingExports) {
	                    //Use the return value from the function.
	                    defined[name] = ret;
	                }
	            }
	        } else if (name) {
	            //May just be an object definition for the module. Only
	            //worry about defining if have a module name.
	            defined[name] = callback;
	        }
	    };
	
	    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
	        if (typeof deps === "string") {
	            if (handlers[deps]) {
	                //callback in this case is really relName
	                return handlers[deps](callback);
	            }
	            //Just return the module wanted. In this scenario, the
	            //deps arg is the module name, and second arg (if passed)
	            //is just the relName.
	            //Normalize module name, if it contains . or ..
	            return callDep(makeMap(deps, callback).f);
	        } else if (!deps.splice) {
	            //deps is a config object, not an array.
	            config = deps;
	            if (config.deps) {
	                req(config.deps, config.callback);
	            }
	            if (!callback) {
	                return;
	            }
	
	            if (callback.splice) {
	                //callback is an array, which means it is a dependency list.
	                //Adjust args if there are dependencies
	                deps = callback;
	                callback = relName;
	                relName = null;
	            } else {
	                deps = undef;
	            }
	        }
	
	        //Support require(['a'])
	        callback = callback || function () {};
	
	        //If relName is a function, it is an errback handler,
	        //so remove it.
	        if (typeof relName === 'function') {
	            relName = forceSync;
	            forceSync = alt;
	        }
	
	        //Simulate async callback;
	        if (forceSync) {
	            main(undef, deps, callback, relName);
	        } else {
	            //Using a non-zero value because of concern for what old browsers
	            //do, and latest browsers "upgrade" to 4 if lower value is used:
	            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
	            //If want a value immediately, use require('id') instead -- something
	            //that works in almond on the global level, but not guaranteed and
	            //unlikely to work in other AMD implementations.
	            setTimeout(function () {
	                main(undef, deps, callback, relName);
	            }, 4);
	        }
	
	        return req;
	    };
	
	    /**
	     * Just drops the config on the floor, but returns req in case
	     * the config return value is used.
	     */
	    req.config = function (cfg) {
	        return req(cfg);
	    };
	
	    /**
	     * Expose module registry for debugging and tooling
	     */
	    requirejs._defined = defined;
	
	    define = function (name, deps, callback) {
	        if (typeof name !== 'string') {
	            throw new Error('See almond README: incorrect module build, no module name');
	        }
	
	        //This module may not have dependencies
	        if (!deps.splice) {
	            //deps is not an array, so probably means
	            //an object literal or factory function for
	            //the value. Adjust args.
	            callback = deps;
	            deps = [];
	        }
	
	        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
	            waiting[name] = [name, deps, callback];
	        }
	    };
	
	    define.amd = {
	        jQuery: true
	    };
	}());
	
	S2.requirejs = requirejs;S2.require = require;S2.define = define;
	}
	}());
	S2.define("almond", function(){});
	
	/* global jQuery:false, $:false */
	S2.define('jquery',[],function () {
	  var _$ = jQuery || $;
	
	  if (_$ == null && console && console.error) {
	    console.error(
	      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
	      'found. Make sure that you are including jQuery before Select2 on your ' +
	      'web page.'
	    );
	  }
	
	  return _$;
	});
	
	S2.define('select2/utils',[
	  'jquery'
	], function ($) {
	  var Utils = {};
	
	  Utils.Extend = function (ChildClass, SuperClass) {
	    var __hasProp = {}.hasOwnProperty;
	
	    function BaseConstructor () {
	      this.constructor = ChildClass;
	    }
	
	    for (var key in SuperClass) {
	      if (__hasProp.call(SuperClass, key)) {
	        ChildClass[key] = SuperClass[key];
	      }
	    }
	
	    BaseConstructor.prototype = SuperClass.prototype;
	    ChildClass.prototype = new BaseConstructor();
	    ChildClass.__super__ = SuperClass.prototype;
	
	    return ChildClass;
	  };
	
	  function getMethods (theClass) {
	    var proto = theClass.prototype;
	
	    var methods = [];
	
	    for (var methodName in proto) {
	      var m = proto[methodName];
	
	      if (typeof m !== 'function') {
	        continue;
	      }
	
	      if (methodName === 'constructor') {
	        continue;
	      }
	
	      methods.push(methodName);
	    }
	
	    return methods;
	  }
	
	  Utils.Decorate = function (SuperClass, DecoratorClass) {
	    var decoratedMethods = getMethods(DecoratorClass);
	    var superMethods = getMethods(SuperClass);
	
	    function DecoratedClass () {
	      var unshift = Array.prototype.unshift;
	
	      var argCount = DecoratorClass.prototype.constructor.length;
	
	      var calledConstructor = SuperClass.prototype.constructor;
	
	      if (argCount > 0) {
	        unshift.call(arguments, SuperClass.prototype.constructor);
	
	        calledConstructor = DecoratorClass.prototype.constructor;
	      }
	
	      calledConstructor.apply(this, arguments);
	    }
	
	    DecoratorClass.displayName = SuperClass.displayName;
	
	    function ctr () {
	      this.constructor = DecoratedClass;
	    }
	
	    DecoratedClass.prototype = new ctr();
	
	    for (var m = 0; m < superMethods.length; m++) {
	        var superMethod = superMethods[m];
	
	        DecoratedClass.prototype[superMethod] =
	          SuperClass.prototype[superMethod];
	    }
	
	    var calledMethod = function (methodName) {
	      // Stub out the original method if it's not decorating an actual method
	      var originalMethod = function () {};
	
	      if (methodName in DecoratedClass.prototype) {
	        originalMethod = DecoratedClass.prototype[methodName];
	      }
	
	      var decoratedMethod = DecoratorClass.prototype[methodName];
	
	      return function () {
	        var unshift = Array.prototype.unshift;
	
	        unshift.call(arguments, originalMethod);
	
	        return decoratedMethod.apply(this, arguments);
	      };
	    };
	
	    for (var d = 0; d < decoratedMethods.length; d++) {
	      var decoratedMethod = decoratedMethods[d];
	
	      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
	    }
	
	    return DecoratedClass;
	  };
	
	  var Observable = function () {
	    this.listeners = {};
	  };
	
	  Observable.prototype.on = function (event, callback) {
	    this.listeners = this.listeners || {};
	
	    if (event in this.listeners) {
	      this.listeners[event].push(callback);
	    } else {
	      this.listeners[event] = [callback];
	    }
	  };
	
	  Observable.prototype.trigger = function (event) {
	    var slice = Array.prototype.slice;
	    var params = slice.call(arguments, 1);
	
	    this.listeners = this.listeners || {};
	
	    // Params should always come in as an array
	    if (params == null) {
	      params = [];
	    }
	
	    // If there are no arguments to the event, use a temporary object
	    if (params.length === 0) {
	      params.push({});
	    }
	
	    // Set the `_type` of the first object to the event
	    params[0]._type = event;
	
	    if (event in this.listeners) {
	      this.invoke(this.listeners[event], slice.call(arguments, 1));
	    }
	
	    if ('*' in this.listeners) {
	      this.invoke(this.listeners['*'], arguments);
	    }
	  };
	
	  Observable.prototype.invoke = function (listeners, params) {
	    for (var i = 0, len = listeners.length; i < len; i++) {
	      listeners[i].apply(this, params);
	    }
	  };
	
	  Utils.Observable = Observable;
	
	  Utils.generateChars = function (length) {
	    var chars = '';
	
	    for (var i = 0; i < length; i++) {
	      var randomChar = Math.floor(Math.random() * 36);
	      chars += randomChar.toString(36);
	    }
	
	    return chars;
	  };
	
	  Utils.bind = function (func, context) {
	    return function () {
	      func.apply(context, arguments);
	    };
	  };
	
	  Utils._convertData = function (data) {
	    for (var originalKey in data) {
	      var keys = originalKey.split('-');
	
	      var dataLevel = data;
	
	      if (keys.length === 1) {
	        continue;
	      }
	
	      for (var k = 0; k < keys.length; k++) {
	        var key = keys[k];
	
	        // Lowercase the first letter
	        // By default, dash-separated becomes camelCase
	        key = key.substring(0, 1).toLowerCase() + key.substring(1);
	
	        if (!(key in dataLevel)) {
	          dataLevel[key] = {};
	        }
	
	        if (k == keys.length - 1) {
	          dataLevel[key] = data[originalKey];
	        }
	
	        dataLevel = dataLevel[key];
	      }
	
	      delete data[originalKey];
	    }
	
	    return data;
	  };
	
	  Utils.hasScroll = function (index, el) {
	    // Adapted from the function created by @ShadowScripter
	    // and adapted by @BillBarry on the Stack Exchange Code Review website.
	    // The original code can be found at
	    // http://codereview.stackexchange.com/q/13338
	    // and was designed to be used with the Sizzle selector engine.
	
	    var $el = $(el);
	    var overflowX = el.style.overflowX;
	    var overflowY = el.style.overflowY;
	
	    //Check both x and y declarations
	    if (overflowX === overflowY &&
	        (overflowY === 'hidden' || overflowY === 'visible')) {
	      return false;
	    }
	
	    if (overflowX === 'scroll' || overflowY === 'scroll') {
	      return true;
	    }
	
	    return ($el.innerHeight() < el.scrollHeight ||
	      $el.innerWidth() < el.scrollWidth);
	  };
	
	  Utils.escapeMarkup = function (markup) {
	    var replaceMap = {
	      '\\': '&#92;',
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      '\'': '&#39;',
	      '/': '&#47;'
	    };
	
	    // Do not try to escape the markup if it's not a string
	    if (typeof markup !== 'string') {
	      return markup;
	    }
	
	    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
	      return replaceMap[match];
	    });
	  };
	
	  // Append an array of jQuery nodes to a given element.
	  Utils.appendMany = function ($element, $nodes) {
	    // jQuery 1.7.x does not support $.fn.append() with an array
	    // Fall back to a jQuery object collection using $.fn.add()
	    if ($.fn.jquery.substr(0, 3) === '1.7') {
	      var $jqNodes = $();
	
	      $.map($nodes, function (node) {
	        $jqNodes = $jqNodes.add(node);
	      });
	
	      $nodes = $jqNodes;
	    }
	
	    $element.append($nodes);
	  };
	
	  return Utils;
	});
	
	S2.define('select2/results',[
	  'jquery',
	  './utils'
	], function ($, Utils) {
	  function Results ($element, options, dataAdapter) {
	    this.$element = $element;
	    this.data = dataAdapter;
	    this.options = options;
	
	    Results.__super__.constructor.call(this);
	  }
	
	  Utils.Extend(Results, Utils.Observable);
	
	  Results.prototype.render = function () {
	    var $results = $(
	      '<ul class="select2-results__options" role="tree"></ul>'
	    );
	
	    if (this.options.get('multiple')) {
	      $results.attr('aria-multiselectable', 'true');
	    }
	
	    this.$results = $results;
	
	    return $results;
	  };
	
	  Results.prototype.clear = function () {
	    this.$results.empty();
	  };
	
	  Results.prototype.displayMessage = function (params) {
	    var escapeMarkup = this.options.get('escapeMarkup');
	
	    this.clear();
	    this.hideLoading();
	
	    var $message = $(
	      '<li role="treeitem" aria-live="assertive"' +
	      ' class="select2-results__option"></li>'
	    );
	
	    var message = this.options.get('translations').get(params.message);
	
	    $message.append(
	      escapeMarkup(
	        message(params.args)
	      )
	    );
	
	    $message[0].className += ' select2-results__message';
	
	    this.$results.append($message);
	  };
	
	  Results.prototype.hideMessages = function () {
	    this.$results.find('.select2-results__message').remove();
	  };
	
	  Results.prototype.append = function (data) {
	    this.hideLoading();
	
	    var $options = [];
	
	    if (data.results == null || data.results.length === 0) {
	      if (this.$results.children().length === 0) {
	        this.trigger('results:message', {
	          message: 'noResults'
	        });
	      }
	
	      return;
	    }
	
	    data.results = this.sort(data.results);
	
	    for (var d = 0; d < data.results.length; d++) {
	      var item = data.results[d];
	
	      var $option = this.option(item);
	
	      $options.push($option);
	    }
	
	    this.$results.append($options);
	  };
	
	  Results.prototype.position = function ($results, $dropdown) {
	    var $resultsContainer = $dropdown.find('.select2-results');
	    $resultsContainer.append($results);
	  };
	
	  Results.prototype.sort = function (data) {
	    var sorter = this.options.get('sorter');
	
	    return sorter(data);
	  };
	
	  Results.prototype.highlightFirstItem = function () {
	    var $options = this.$results
	      .find('.select2-results__option[aria-selected]');
	
	    var $selected = $options.filter('[aria-selected=true]');
	
	    // Check if there are any selected options
	    if ($selected.length > 0) {
	      // If there are selected options, highlight the first
	      $selected.first().trigger('mouseenter');
	    } else {
	      // If there are no selected options, highlight the first option
	      // in the dropdown
	      $options.first().trigger('mouseenter');
	    }
	
	    this.ensureHighlightVisible();
	  };
	
	  Results.prototype.setClasses = function () {
	    var self = this;
	
	    this.data.current(function (selected) {
	      var selectedIds = $.map(selected, function (s) {
	        return s.id.toString();
	      });
	
	      var $options = self.$results
	        .find('.select2-results__option[aria-selected]');
	
	      $options.each(function () {
	        var $option = $(this);
	
	        var item = $.data(this, 'data');
	
	        // id needs to be converted to a string when comparing
	        var id = '' + item.id;
	
	        if ((item.element != null && item.element.selected) ||
	            (item.element == null && $.inArray(id, selectedIds) > -1)) {
	          $option.attr('aria-selected', 'true');
	        } else {
	          $option.attr('aria-selected', 'false');
	        }
	      });
	
	    });
	  };
	
	  Results.prototype.showLoading = function (params) {
	    this.hideLoading();
	
	    var loadingMore = this.options.get('translations').get('searching');
	
	    var loading = {
	      disabled: true,
	      loading: true,
	      text: loadingMore(params)
	    };
	    var $loading = this.option(loading);
	    $loading.className += ' loading-results';
	
	    this.$results.prepend($loading);
	  };
	
	  Results.prototype.hideLoading = function () {
	    this.$results.find('.loading-results').remove();
	  };
	
	  Results.prototype.option = function (data) {
	    var option = document.createElement('li');
	    option.className = 'select2-results__option';
	
	    var attrs = {
	      'role': 'treeitem',
	      'aria-selected': 'false'
	    };
	
	    if (data.disabled) {
	      delete attrs['aria-selected'];
	      attrs['aria-disabled'] = 'true';
	    }
	
	    if (data.id == null) {
	      delete attrs['aria-selected'];
	    }
	
	    if (data._resultId != null) {
	      option.id = data._resultId;
	    }
	
	    if (data.title) {
	      option.title = data.title;
	    }
	
	    if (data.children) {
	      attrs.role = 'group';
	      attrs['aria-label'] = data.text;
	      delete attrs['aria-selected'];
	    }
	
	    for (var attr in attrs) {
	      var val = attrs[attr];
	
	      option.setAttribute(attr, val);
	    }
	
	    if (data.children) {
	      var $option = $(option);
	
	      var label = document.createElement('strong');
	      label.className = 'select2-results__group';
	
	      var $label = $(label);
	      this.template(data, label);
	
	      var $children = [];
	
	      for (var c = 0; c < data.children.length; c++) {
	        var child = data.children[c];
	
	        var $child = this.option(child);
	
	        $children.push($child);
	      }
	
	      var $childrenContainer = $('<ul></ul>', {
	        'class': 'select2-results__options select2-results__options--nested'
	      });
	
	      $childrenContainer.append($children);
	
	      $option.append(label);
	      $option.append($childrenContainer);
	    } else {
	      this.template(data, option);
	    }
	
	    $.data(option, 'data', data);
	
	    return option;
	  };
	
	  Results.prototype.bind = function (container, $container) {
	    var self = this;
	
	    var id = container.id + '-results';
	
	    this.$results.attr('id', id);
	
	    container.on('results:all', function (params) {
	      self.clear();
	      self.append(params.data);
	
	      if (container.isOpen()) {
	        self.setClasses();
	        self.highlightFirstItem();
	      }
	    });
	
	    container.on('results:append', function (params) {
	      self.append(params.data);
	
	      if (container.isOpen()) {
	        self.setClasses();
	      }
	    });
	
	    container.on('query', function (params) {
	      self.hideMessages();
	      self.showLoading(params);
	    });
	
	    container.on('select', function () {
	      if (!container.isOpen()) {
	        return;
	      }
	
	      self.setClasses();
	      self.highlightFirstItem();
	    });
	
	    container.on('unselect', function () {
	      if (!container.isOpen()) {
	        return;
	      }
	
	      self.setClasses();
	      self.highlightFirstItem();
	    });
	
	    container.on('open', function () {
	      // When the dropdown is open, aria-expended="true"
	      self.$results.attr('aria-expanded', 'true');
	      self.$results.attr('aria-hidden', 'false');
	
	      self.setClasses();
	      self.ensureHighlightVisible();
	    });
	
	    container.on('close', function () {
	      // When the dropdown is closed, aria-expended="false"
	      self.$results.attr('aria-expanded', 'false');
	      self.$results.attr('aria-hidden', 'true');
	      self.$results.removeAttr('aria-activedescendant');
	    });
	
	    container.on('results:toggle', function () {
	      var $highlighted = self.getHighlightedResults();
	
	      if ($highlighted.length === 0) {
	        return;
	      }
	
	      $highlighted.trigger('mouseup');
	    });
	
	    container.on('results:select', function () {
	      var $highlighted = self.getHighlightedResults();
	
	      if ($highlighted.length === 0) {
	        return;
	      }
	
	      var data = $highlighted.data('data');
	
	      if ($highlighted.attr('aria-selected') == 'true') {
	        self.trigger('close', {});
	      } else {
	        self.trigger('select', {
	          data: data
	        });
	      }
	    });
	
	    container.on('results:previous', function () {
	      var $highlighted = self.getHighlightedResults();
	
	      var $options = self.$results.find('[aria-selected]');
	
	      var currentIndex = $options.index($highlighted);
	
	      // If we are already at te top, don't move further
	      if (currentIndex === 0) {
	        return;
	      }
	
	      var nextIndex = currentIndex - 1;
	
	      // If none are highlighted, highlight the first
	      if ($highlighted.length === 0) {
	        nextIndex = 0;
	      }
	
	      var $next = $options.eq(nextIndex);
	
	      $next.trigger('mouseenter');
	
	      var currentOffset = self.$results.offset().top;
	      var nextTop = $next.offset().top;
	      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
	
	      if (nextIndex === 0) {
	        self.$results.scrollTop(0);
	      } else if (nextTop - currentOffset < 0) {
	        self.$results.scrollTop(nextOffset);
	      }
	    });
	
	    container.on('results:next', function () {
	      var $highlighted = self.getHighlightedResults();
	
	      var $options = self.$results.find('[aria-selected]');
	
	      var currentIndex = $options.index($highlighted);
	
	      var nextIndex = currentIndex + 1;
	
	      // If we are at the last option, stay there
	      if (nextIndex >= $options.length) {
	        return;
	      }
	
	      var $next = $options.eq(nextIndex);
	
	      $next.trigger('mouseenter');
	
	      var currentOffset = self.$results.offset().top +
	        self.$results.outerHeight(false);
	      var nextBottom = $next.offset().top + $next.outerHeight(false);
	      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
	
	      if (nextIndex === 0) {
	        self.$results.scrollTop(0);
	      } else if (nextBottom > currentOffset) {
	        self.$results.scrollTop(nextOffset);
	      }
	    });
	
	    container.on('results:focus', function (params) {
	      params.element.addClass('select2-results__option--highlighted');
	    });
	
	    container.on('results:message', function (params) {
	      self.displayMessage(params);
	    });
	
	    if ($.fn.mousewheel) {
	      this.$results.on('mousewheel', function (e) {
	        var top = self.$results.scrollTop();
	
	        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
	
	        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
	        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
	
	        if (isAtTop) {
	          self.$results.scrollTop(0);
	
	          e.preventDefault();
	          e.stopPropagation();
	        } else if (isAtBottom) {
	          self.$results.scrollTop(
	            self.$results.get(0).scrollHeight - self.$results.height()
	          );
	
	          e.preventDefault();
	          e.stopPropagation();
	        }
	      });
	    }
	
	    this.$results.on('mouseup', '.select2-results__option[aria-selected]',
	      function (evt) {
	      var $this = $(this);
	
	      var data = $this.data('data');
	
	      if ($this.attr('aria-selected') === 'true') {
	        if (self.options.get('multiple')) {
	          self.trigger('unselect', {
	            originalEvent: evt,
	            data: data
	          });
	        } else {
	          self.trigger('close', {});
	        }
	
	        return;
	      }
	
	      self.trigger('select', {
	        originalEvent: evt,
	        data: data
	      });
	    });
	
	    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
	      function (evt) {
	      var data = $(this).data('data');
	
	      self.getHighlightedResults()
	          .removeClass('select2-results__option--highlighted');
	
	      self.trigger('results:focus', {
	        data: data,
	        element: $(this)
	      });
	    });
	  };
	
	  Results.prototype.getHighlightedResults = function () {
	    var $highlighted = this.$results
	    .find('.select2-results__option--highlighted');
	
	    return $highlighted;
	  };
	
	  Results.prototype.destroy = function () {
	    this.$results.remove();
	  };
	
	  Results.prototype.ensureHighlightVisible = function () {
	    var $highlighted = this.getHighlightedResults();
	
	    if ($highlighted.length === 0) {
	      return;
	    }
	
	    var $options = this.$results.find('[aria-selected]');
	
	    var currentIndex = $options.index($highlighted);
	
	    var currentOffset = this.$results.offset().top;
	    var nextTop = $highlighted.offset().top;
	    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
	
	    var offsetDelta = nextTop - currentOffset;
	    nextOffset -= $highlighted.outerHeight(false) * 2;
	
	    if (currentIndex <= 2) {
	      this.$results.scrollTop(0);
	    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
	      this.$results.scrollTop(nextOffset);
	    }
	  };
	
	  Results.prototype.template = function (result, container) {
	    var template = this.options.get('templateResult');
	    var escapeMarkup = this.options.get('escapeMarkup');
	
	    var content = template(result, container);
	
	    if (content == null) {
	      container.style.display = 'none';
	    } else if (typeof content === 'string') {
	      container.innerHTML = escapeMarkup(content);
	    } else {
	      $(container).append(content);
	    }
	  };
	
	  return Results;
	});
	
	S2.define('select2/keys',[
	
	], function () {
	  var KEYS = {
	    BACKSPACE: 8,
	    TAB: 9,
	    ENTER: 13,
	    SHIFT: 16,
	    CTRL: 17,
	    ALT: 18,
	    ESC: 27,
	    SPACE: 32,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    END: 35,
	    HOME: 36,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    DELETE: 46
	  };
	
	  return KEYS;
	});
	
	S2.define('select2/selection/base',[
	  'jquery',
	  '../utils',
	  '../keys'
	], function ($, Utils, KEYS) {
	  function BaseSelection ($element, options) {
	    this.$element = $element;
	    this.options = options;
	
	    BaseSelection.__super__.constructor.call(this);
	  }
	
	  Utils.Extend(BaseSelection, Utils.Observable);
	
	  BaseSelection.prototype.render = function () {
	    var $selection = $(
	      '<span class="select2-selection" role="combobox" ' +
	      ' aria-haspopup="true" aria-expanded="false">' +
	      '</span>'
	    );
	
	    this._tabindex = 0;
	
	    if (this.$element.data('old-tabindex') != null) {
	      this._tabindex = this.$element.data('old-tabindex');
	    } else if (this.$element.attr('tabindex') != null) {
	      this._tabindex = this.$element.attr('tabindex');
	    }
	
	    $selection.attr('title', this.$element.attr('title'));
	    $selection.attr('tabindex', this._tabindex);
	
	    this.$selection = $selection;
	
	    return $selection;
	  };
	
	  BaseSelection.prototype.bind = function (container, $container) {
	    var self = this;
	
	    var id = container.id + '-container';
	    var resultsId = container.id + '-results';
	
	    this.container = container;
	
	    this.$selection.on('focus', function (evt) {
	      self.trigger('focus', evt);
	    });
	
	    this.$selection.on('blur', function (evt) {
	      self._handleBlur(evt);
	    });
	
	    this.$selection.on('keydown', function (evt) {
	      self.trigger('keypress', evt);
	
	      if (evt.which === KEYS.SPACE) {
	        evt.preventDefault();
	      }
	    });
	
	    container.on('results:focus', function (params) {
	      self.$selection.attr('aria-activedescendant', params.data._resultId);
	    });
	
	    container.on('selection:update', function (params) {
	      self.update(params.data);
	    });
	
	    container.on('open', function () {
	      // When the dropdown is open, aria-expanded="true"
	      self.$selection.attr('aria-expanded', 'true');
	      self.$selection.attr('aria-owns', resultsId);
	
	      self._attachCloseHandler(container);
	    });
	
	    container.on('close', function () {
	      // When the dropdown is closed, aria-expanded="false"
	      self.$selection.attr('aria-expanded', 'false');
	      self.$selection.removeAttr('aria-activedescendant');
	      self.$selection.removeAttr('aria-owns');
	
	      self.$selection.focus();
	
	      self._detachCloseHandler(container);
	    });
	
	    container.on('enable', function () {
	      self.$selection.attr('tabindex', self._tabindex);
	    });
	
	    container.on('disable', function () {
	      self.$selection.attr('tabindex', '-1');
	    });
	  };
	
	  BaseSelection.prototype._handleBlur = function (evt) {
	    var self = this;
	
	    // This needs to be delayed as the active element is the body when the tab
	    // key is pressed, possibly along with others.
	    window.setTimeout(function () {
	      // Don't trigger `blur` if the focus is still in the selection
	      if (
	        (document.activeElement == self.$selection[0]) ||
	        ($.contains(self.$selection[0], document.activeElement))
	      ) {
	        return;
	      }
	
	      self.trigger('blur', evt);
	    }, 1);
	  };
	
	  BaseSelection.prototype._attachCloseHandler = function (container) {
	    var self = this;
	
	    $(document.body).on('mousedown.select2.' + container.id, function (e) {
	      var $target = $(e.target);
	
	      var $select = $target.closest('.select2');
	
	      var $all = $('.select2.select2-container--open');
	
	      $all.each(function () {
	        var $this = $(this);
	
	        if (this == $select[0]) {
	          return;
	        }
	
	        var $element = $this.data('element');
	
	        $element.select2('close');
	      });
	    });
	  };
	
	  BaseSelection.prototype._detachCloseHandler = function (container) {
	    $(document.body).off('mousedown.select2.' + container.id);
	  };
	
	  BaseSelection.prototype.position = function ($selection, $container) {
	    var $selectionContainer = $container.find('.selection');
	    $selectionContainer.append($selection);
	  };
	
	  BaseSelection.prototype.destroy = function () {
	    this._detachCloseHandler(this.container);
	  };
	
	  BaseSelection.prototype.update = function (data) {
	    throw new Error('The `update` method must be defined in child classes.');
	  };
	
	  return BaseSelection;
	});
	
	S2.define('select2/selection/single',[
	  'jquery',
	  './base',
	  '../utils',
	  '../keys'
	], function ($, BaseSelection, Utils, KEYS) {
	  function SingleSelection () {
	    SingleSelection.__super__.constructor.apply(this, arguments);
	  }
	
	  Utils.Extend(SingleSelection, BaseSelection);
	
	  SingleSelection.prototype.render = function () {
	    var $selection = SingleSelection.__super__.render.call(this);
	
	    $selection.addClass('select2-selection--single');
	
	    $selection.html(
	      '<span class="select2-selection__rendered"></span>' +
	      '<span class="select2-selection__arrow" role="presentation">' +
	        '<b role="presentation"></b>' +
	      '</span>'
	    );
	
	    return $selection;
	  };
	
	  SingleSelection.prototype.bind = function (container, $container) {
	    var self = this;
	
	    SingleSelection.__super__.bind.apply(this, arguments);
	
	    var id = container.id + '-container';
	
	    this.$selection.find('.select2-selection__rendered').attr('id', id);
	    this.$selection.attr('aria-labelledby', id);
	
	    this.$selection.on('mousedown', function (evt) {
	      // Only respond to left clicks
	      if (evt.which !== 1) {
	        return;
	      }
	
	      self.trigger('toggle', {
	        originalEvent: evt
	      });
	    });
	
	    this.$selection.on('focus', function (evt) {
	      // User focuses on the container
	    });
	
	    this.$selection.on('blur', function (evt) {
	      // User exits the container
	    });
	
	    container.on('focus', function (evt) {
	      if (!container.isOpen()) {
	        self.$selection.focus();
	      }
	    });
	
	    container.on('selection:update', function (params) {
	      self.update(params.data);
	    });
	  };
	
	  SingleSelection.prototype.clear = function () {
	    this.$selection.find('.select2-selection__rendered').empty();
	  };
	
	  SingleSelection.prototype.display = function (data, container) {
	    var template = this.options.get('templateSelection');
	    var escapeMarkup = this.options.get('escapeMarkup');
	
	    return escapeMarkup(template(data, container));
	  };
	
	  SingleSelection.prototype.selectionContainer = function () {
	    return $('<span></span>');
	  };
	
	  SingleSelection.prototype.update = function (data) {
	    if (data.length === 0) {
	      this.clear();
	      return;
	    }
	
	    var selection = data[0];
	
	    var $rendered = this.$selection.find('.select2-selection__rendered');
	    var formatted = this.display(selection, $rendered);
	
	    $rendered.empty().append(formatted);
	    $rendered.prop('title', selection.title || selection.text);
	  };
	
	  return SingleSelection;
	});
	
	S2.define('select2/selection/multiple',[
	  'jquery',
	  './base',
	  '../utils'
	], function ($, BaseSelection, Utils) {
	  function MultipleSelection ($element, options) {
	    MultipleSelection.__super__.constructor.apply(this, arguments);
	  }
	
	  Utils.Extend(MultipleSelection, BaseSelection);
	
	  MultipleSelection.prototype.render = function () {
	    var $selection = MultipleSelection.__super__.render.call(this);
	
	    $selection.addClass('select2-selection--multiple');
	
	    $selection.html(
	      '<ul class="select2-selection__rendered"></ul>'
	    );
	
	    return $selection;
	  };
	
	  MultipleSelection.prototype.bind = function (container, $container) {
	    var self = this;
	
	    MultipleSelection.__super__.bind.apply(this, arguments);
	
	    this.$selection.on('click', function (evt) {
	      self.trigger('toggle', {
	        originalEvent: evt
	      });
	    });
	
	    this.$selection.on(
	      'click',
	      '.select2-selection__choice__remove',
	      function (evt) {
	        // Ignore the event if it is disabled
	        if (self.options.get('disabled')) {
	          return;
	        }
	
	        var $remove = $(this);
	        var $selection = $remove.parent();
	
	        var data = $selection.data('data');
	
	        self.trigger('unselect', {
	          originalEvent: evt,
	          data: data
	        });
	      }
	    );
	  };
	
	  MultipleSelection.prototype.clear = function () {
	    this.$selection.find('.select2-selection__rendered').empty();
	  };
	
	  MultipleSelection.prototype.display = function (data, container) {
	    var template = this.options.get('templateSelection');
	    var escapeMarkup = this.options.get('escapeMarkup');
	
	    return escapeMarkup(template(data, container));
	  };
	
	  MultipleSelection.prototype.selectionContainer = function () {
	    var $container = $(
	      '<li class="select2-selection__choice">' +
	        '<span class="select2-selection__choice__remove" role="presentation">' +
	          '&times;' +
	        '</span>' +
	      '</li>'
	    );
	
	    return $container;
	  };
	
	  MultipleSelection.prototype.update = function (data) {
	    this.clear();
	
	    if (data.length === 0) {
	      return;
	    }
	
	    var $selections = [];
	
	    for (var d = 0; d < data.length; d++) {
	      var selection = data[d];
	
	      var $selection = this.selectionContainer();
	      var formatted = this.display(selection, $selection);
	
	      $selection.append(formatted);
	      $selection.prop('title', selection.title || selection.text);
	
	      $selection.data('data', selection);
	
	      $selections.push($selection);
	    }
	
	    var $rendered = this.$selection.find('.select2-selection__rendered');
	
	    Utils.appendMany($rendered, $selections);
	  };
	
	  return MultipleSelection;
	});
	
	S2.define('select2/selection/placeholder',[
	  '../utils'
	], function (Utils) {
	  function Placeholder (decorated, $element, options) {
	    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
	
	    decorated.call(this, $element, options);
	  }
	
	  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
	    if (typeof placeholder === 'string') {
	      placeholder = {
	        id: '',
	        text: placeholder
	      };
	    }
	
	    return placeholder;
	  };
	
	  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
	    var $placeholder = this.selectionContainer();
	
	    $placeholder.html(this.display(placeholder));
	    $placeholder.addClass('select2-selection__placeholder')
	                .removeClass('select2-selection__choice');
	
	    return $placeholder;
	  };
	
	  Placeholder.prototype.update = function (decorated, data) {
	    var singlePlaceholder = (
	      data.length == 1 && data[0].id != this.placeholder.id
	    );
	    var multipleSelections = data.length > 1;
	
	    if (multipleSelections || singlePlaceholder) {
	      return decorated.call(this, data);
	    }
	
	    this.clear();
	
	    var $placeholder = this.createPlaceholder(this.placeholder);
	
	    this.$selection.find('.select2-selection__rendered').append($placeholder);
	  };
	
	  return Placeholder;
	});
	
	S2.define('select2/selection/allowClear',[
	  'jquery',
	  '../keys'
	], function ($, KEYS) {
	  function AllowClear () { }
	
	  AllowClear.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    if (this.placeholder == null) {
	      if (this.options.get('debug') && window.console && console.error) {
	        console.error(
	          'Select2: The `allowClear` option should be used in combination ' +
	          'with the `placeholder` option.'
	        );
	      }
	    }
	
	    this.$selection.on('mousedown', '.select2-selection__clear',
	      function (evt) {
	        self._handleClear(evt);
	    });
	
	    container.on('keypress', function (evt) {
	      self._handleKeyboardClear(evt, container);
	    });
	  };
	
	  AllowClear.prototype._handleClear = function (_, evt) {
	    // Ignore the event if it is disabled
	    if (this.options.get('disabled')) {
	      return;
	    }
	
	    var $clear = this.$selection.find('.select2-selection__clear');
	
	    // Ignore the event if nothing has been selected
	    if ($clear.length === 0) {
	      return;
	    }
	
	    evt.stopPropagation();
	
	    var data = $clear.data('data');
	
	    for (var d = 0; d < data.length; d++) {
	      var unselectData = {
	        data: data[d]
	      };
	
	      // Trigger the `unselect` event, so people can prevent it from being
	      // cleared.
	      this.trigger('unselect', unselectData);
	
	      // If the event was prevented, don't clear it out.
	      if (unselectData.prevented) {
	        return;
	      }
	    }
	
	    this.$element.val(this.placeholder.id).trigger('change');
	
	    this.trigger('toggle', {});
	  };
	
	  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
	    if (container.isOpen()) {
	      return;
	    }
	
	    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
	      this._handleClear(evt);
	    }
	  };
	
	  AllowClear.prototype.update = function (decorated, data) {
	    decorated.call(this, data);
	
	    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
	        data.length === 0) {
	      return;
	    }
	
	    var $remove = $(
	      '<span class="select2-selection__clear">' +
	        '&times;' +
	      '</span>'
	    );
	    $remove.data('data', data);
	
	    this.$selection.find('.select2-selection__rendered').prepend($remove);
	  };
	
	  return AllowClear;
	});
	
	S2.define('select2/selection/search',[
	  'jquery',
	  '../utils',
	  '../keys'
	], function ($, Utils, KEYS) {
	  function Search (decorated, $element, options) {
	    decorated.call(this, $element, options);
	  }
	
	  Search.prototype.render = function (decorated) {
	    var $search = $(
	      '<li class="select2-search select2-search--inline">' +
	        '<input class="select2-search__field" type="search" tabindex="-1"' +
	        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
	        ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
	      '</li>'
	    );
	
	    this.$searchContainer = $search;
	    this.$search = $search.find('input');
	
	    var $rendered = decorated.call(this);
	
	    this._transferTabIndex();
	
	    return $rendered;
	  };
	
	  Search.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    container.on('open', function () {
	      self.$search.trigger('focus');
	    });
	
	    container.on('close', function () {
	      self.$search.val('');
	      self.$search.removeAttr('aria-activedescendant');
	      self.$search.trigger('focus');
	    });
	
	    container.on('enable', function () {
	      self.$search.prop('disabled', false);
	
	      self._transferTabIndex();
	    });
	
	    container.on('disable', function () {
	      self.$search.prop('disabled', true);
	    });
	
	    container.on('focus', function (evt) {
	      self.$search.trigger('focus');
	    });
	
	    container.on('results:focus', function (params) {
	      self.$search.attr('aria-activedescendant', params.id);
	    });
	
	    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
	      self.trigger('focus', evt);
	    });
	
	    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
	      self._handleBlur(evt);
	    });
	
	    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
	      evt.stopPropagation();
	
	      self.trigger('keypress', evt);
	
	      self._keyUpPrevented = evt.isDefaultPrevented();
	
	      var key = evt.which;
	
	      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
	        var $previousChoice = self.$searchContainer
	          .prev('.select2-selection__choice');
	
	        if ($previousChoice.length > 0) {
	          var item = $previousChoice.data('data');
	
	          self.searchRemoveChoice(item);
	
	          evt.preventDefault();
	        }
	      }
	    });
	
	    // Try to detect the IE version should the `documentMode` property that
	    // is stored on the document. This is only implemented in IE and is
	    // slightly cleaner than doing a user agent check.
	    // This property is not available in Edge, but Edge also doesn't have
	    // this bug.
	    var msie = document.documentMode;
	    var disableInputEvents = msie && msie <= 11;
	
	    // Workaround for browsers which do not support the `input` event
	    // This will prevent double-triggering of events for browsers which support
	    // both the `keyup` and `input` events.
	    this.$selection.on(
	      'input.searchcheck',
	      '.select2-search--inline',
	      function (evt) {
	        // IE will trigger the `input` event when a placeholder is used on a
	        // search box. To get around this issue, we are forced to ignore all
	        // `input` events in IE and keep using `keyup`.
	        if (disableInputEvents) {
	          self.$selection.off('input.search input.searchcheck');
	          return;
	        }
	
	        // Unbind the duplicated `keyup` event
	        self.$selection.off('keyup.search');
	      }
	    );
	
	    this.$selection.on(
	      'keyup.search input.search',
	      '.select2-search--inline',
	      function (evt) {
	        // IE will trigger the `input` event when a placeholder is used on a
	        // search box. To get around this issue, we are forced to ignore all
	        // `input` events in IE and keep using `keyup`.
	        if (disableInputEvents && evt.type === 'input') {
	          self.$selection.off('input.search input.searchcheck');
	          return;
	        }
	
	        var key = evt.which;
	
	        // We can freely ignore events from modifier keys
	        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
	          return;
	        }
	
	        // Tabbing will be handled during the `keydown` phase
	        if (key == KEYS.TAB) {
	          return;
	        }
	
	        self.handleSearch(evt);
	      }
	    );
	  };
	
	  /**
	   * This method will transfer the tabindex attribute from the rendered
	   * selection to the search box. This allows for the search box to be used as
	   * the primary focus instead of the selection container.
	   *
	   * @private
	   */
	  Search.prototype._transferTabIndex = function (decorated) {
	    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
	    this.$selection.attr('tabindex', '-1');
	  };
	
	  Search.prototype.createPlaceholder = function (decorated, placeholder) {
	    this.$search.attr('placeholder', placeholder.text);
	  };
	
	  Search.prototype.update = function (decorated, data) {
	    var searchHadFocus = this.$search[0] == document.activeElement;
	
	    this.$search.attr('placeholder', '');
	
	    decorated.call(this, data);
	
	    this.$selection.find('.select2-selection__rendered')
	                   .append(this.$searchContainer);
	
	    this.resizeSearch();
	    if (searchHadFocus) {
	      this.$search.focus();
	    }
	  };
	
	  Search.prototype.handleSearch = function () {
	    this.resizeSearch();
	
	    if (!this._keyUpPrevented) {
	      var input = this.$search.val();
	
	      this.trigger('query', {
	        term: input
	      });
	    }
	
	    this._keyUpPrevented = false;
	  };
	
	  Search.prototype.searchRemoveChoice = function (decorated, item) {
	    this.trigger('unselect', {
	      data: item
	    });
	
	    this.$search.val(item.text);
	    this.handleSearch();
	  };
	
	  Search.prototype.resizeSearch = function () {
	    this.$search.css('width', '25px');
	
	    var width = '';
	
	    if (this.$search.attr('placeholder') !== '') {
	      width = this.$selection.find('.select2-selection__rendered').innerWidth();
	    } else {
	      var minimumWidth = this.$search.val().length + 1;
	
	      width = (minimumWidth * 0.75) + 'em';
	    }
	
	    this.$search.css('width', width);
	  };
	
	  return Search;
	});
	
	S2.define('select2/selection/eventRelay',[
	  'jquery'
	], function ($) {
	  function EventRelay () { }
	
	  EventRelay.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	    var relayEvents = [
	      'open', 'opening',
	      'close', 'closing',
	      'select', 'selecting',
	      'unselect', 'unselecting'
	    ];
	
	    var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];
	
	    decorated.call(this, container, $container);
	
	    container.on('*', function (name, params) {
	      // Ignore events that should not be relayed
	      if ($.inArray(name, relayEvents) === -1) {
	        return;
	      }
	
	      // The parameters should always be an object
	      params = params || {};
	
	      // Generate the jQuery event for the Select2 event
	      var evt = $.Event('select2:' + name, {
	        params: params
	      });
	
	      self.$element.trigger(evt);
	
	      // Only handle preventable events if it was one
	      if ($.inArray(name, preventableEvents) === -1) {
	        return;
	      }
	
	      params.prevented = evt.isDefaultPrevented();
	    });
	  };
	
	  return EventRelay;
	});
	
	S2.define('select2/translation',[
	  'jquery',
	  'require'
	], function ($, require) {
	  function Translation (dict) {
	    this.dict = dict || {};
	  }
	
	  Translation.prototype.all = function () {
	    return this.dict;
	  };
	
	  Translation.prototype.get = function (key) {
	    return this.dict[key];
	  };
	
	  Translation.prototype.extend = function (translation) {
	    this.dict = $.extend({}, translation.all(), this.dict);
	  };
	
	  // Static functions
	
	  Translation._cache = {};
	
	  Translation.loadPath = function (path) {
	    if (!(path in Translation._cache)) {
	      var translations = require(path);
	
	      Translation._cache[path] = translations;
	    }
	
	    return new Translation(Translation._cache[path]);
	  };
	
	  return Translation;
	});
	
	S2.define('select2/diacritics',[
	
	], function () {
	  var diacritics = {
	    '\u24B6': 'A',
	    '\uFF21': 'A',
	    '\u00C0': 'A',
	    '\u00C1': 'A',
	    '\u00C2': 'A',
	    '\u1EA6': 'A',
	    '\u1EA4': 'A',
	    '\u1EAA': 'A',
	    '\u1EA8': 'A',
	    '\u00C3': 'A',
	    '\u0100': 'A',
	    '\u0102': 'A',
	    '\u1EB0': 'A',
	    '\u1EAE': 'A',
	    '\u1EB4': 'A',
	    '\u1EB2': 'A',
	    '\u0226': 'A',
	    '\u01E0': 'A',
	    '\u00C4': 'A',
	    '\u01DE': 'A',
	    '\u1EA2': 'A',
	    '\u00C5': 'A',
	    '\u01FA': 'A',
	    '\u01CD': 'A',
	    '\u0200': 'A',
	    '\u0202': 'A',
	    '\u1EA0': 'A',
	    '\u1EAC': 'A',
	    '\u1EB6': 'A',
	    '\u1E00': 'A',
	    '\u0104': 'A',
	    '\u023A': 'A',
	    '\u2C6F': 'A',
	    '\uA732': 'AA',
	    '\u00C6': 'AE',
	    '\u01FC': 'AE',
	    '\u01E2': 'AE',
	    '\uA734': 'AO',
	    '\uA736': 'AU',
	    '\uA738': 'AV',
	    '\uA73A': 'AV',
	    '\uA73C': 'AY',
	    '\u24B7': 'B',
	    '\uFF22': 'B',
	    '\u1E02': 'B',
	    '\u1E04': 'B',
	    '\u1E06': 'B',
	    '\u0243': 'B',
	    '\u0182': 'B',
	    '\u0181': 'B',
	    '\u24B8': 'C',
	    '\uFF23': 'C',
	    '\u0106': 'C',
	    '\u0108': 'C',
	    '\u010A': 'C',
	    '\u010C': 'C',
	    '\u00C7': 'C',
	    '\u1E08': 'C',
	    '\u0187': 'C',
	    '\u023B': 'C',
	    '\uA73E': 'C',
	    '\u24B9': 'D',
	    '\uFF24': 'D',
	    '\u1E0A': 'D',
	    '\u010E': 'D',
	    '\u1E0C': 'D',
	    '\u1E10': 'D',
	    '\u1E12': 'D',
	    '\u1E0E': 'D',
	    '\u0110': 'D',
	    '\u018B': 'D',
	    '\u018A': 'D',
	    '\u0189': 'D',
	    '\uA779': 'D',
	    '\u01F1': 'DZ',
	    '\u01C4': 'DZ',
	    '\u01F2': 'Dz',
	    '\u01C5': 'Dz',
	    '\u24BA': 'E',
	    '\uFF25': 'E',
	    '\u00C8': 'E',
	    '\u00C9': 'E',
	    '\u00CA': 'E',
	    '\u1EC0': 'E',
	    '\u1EBE': 'E',
	    '\u1EC4': 'E',
	    '\u1EC2': 'E',
	    '\u1EBC': 'E',
	    '\u0112': 'E',
	    '\u1E14': 'E',
	    '\u1E16': 'E',
	    '\u0114': 'E',
	    '\u0116': 'E',
	    '\u00CB': 'E',
	    '\u1EBA': 'E',
	    '\u011A': 'E',
	    '\u0204': 'E',
	    '\u0206': 'E',
	    '\u1EB8': 'E',
	    '\u1EC6': 'E',
	    '\u0228': 'E',
	    '\u1E1C': 'E',
	    '\u0118': 'E',
	    '\u1E18': 'E',
	    '\u1E1A': 'E',
	    '\u0190': 'E',
	    '\u018E': 'E',
	    '\u24BB': 'F',
	    '\uFF26': 'F',
	    '\u1E1E': 'F',
	    '\u0191': 'F',
	    '\uA77B': 'F',
	    '\u24BC': 'G',
	    '\uFF27': 'G',
	    '\u01F4': 'G',
	    '\u011C': 'G',
	    '\u1E20': 'G',
	    '\u011E': 'G',
	    '\u0120': 'G',
	    '\u01E6': 'G',
	    '\u0122': 'G',
	    '\u01E4': 'G',
	    '\u0193': 'G',
	    '\uA7A0': 'G',
	    '\uA77D': 'G',
	    '\uA77E': 'G',
	    '\u24BD': 'H',
	    '\uFF28': 'H',
	    '\u0124': 'H',
	    '\u1E22': 'H',
	    '\u1E26': 'H',
	    '\u021E': 'H',
	    '\u1E24': 'H',
	    '\u1E28': 'H',
	    '\u1E2A': 'H',
	    '\u0126': 'H',
	    '\u2C67': 'H',
	    '\u2C75': 'H',
	    '\uA78D': 'H',
	    '\u24BE': 'I',
	    '\uFF29': 'I',
	    '\u00CC': 'I',
	    '\u00CD': 'I',
	    '\u00CE': 'I',
	    '\u0128': 'I',
	    '\u012A': 'I',
	    '\u012C': 'I',
	    '\u0130': 'I',
	    '\u00CF': 'I',
	    '\u1E2E': 'I',
	    '\u1EC8': 'I',
	    '\u01CF': 'I',
	    '\u0208': 'I',
	    '\u020A': 'I',
	    '\u1ECA': 'I',
	    '\u012E': 'I',
	    '\u1E2C': 'I',
	    '\u0197': 'I',
	    '\u24BF': 'J',
	    '\uFF2A': 'J',
	    '\u0134': 'J',
	    '\u0248': 'J',
	    '\u24C0': 'K',
	    '\uFF2B': 'K',
	    '\u1E30': 'K',
	    '\u01E8': 'K',
	    '\u1E32': 'K',
	    '\u0136': 'K',
	    '\u1E34': 'K',
	    '\u0198': 'K',
	    '\u2C69': 'K',
	    '\uA740': 'K',
	    '\uA742': 'K',
	    '\uA744': 'K',
	    '\uA7A2': 'K',
	    '\u24C1': 'L',
	    '\uFF2C': 'L',
	    '\u013F': 'L',
	    '\u0139': 'L',
	    '\u013D': 'L',
	    '\u1E36': 'L',
	    '\u1E38': 'L',
	    '\u013B': 'L',
	    '\u1E3C': 'L',
	    '\u1E3A': 'L',
	    '\u0141': 'L',
	    '\u023D': 'L',
	    '\u2C62': 'L',
	    '\u2C60': 'L',
	    '\uA748': 'L',
	    '\uA746': 'L',
	    '\uA780': 'L',
	    '\u01C7': 'LJ',
	    '\u01C8': 'Lj',
	    '\u24C2': 'M',
	    '\uFF2D': 'M',
	    '\u1E3E': 'M',
	    '\u1E40': 'M',
	    '\u1E42': 'M',
	    '\u2C6E': 'M',
	    '\u019C': 'M',
	    '\u24C3': 'N',
	    '\uFF2E': 'N',
	    '\u01F8': 'N',
	    '\u0143': 'N',
	    '\u00D1': 'N',
	    '\u1E44': 'N',
	    '\u0147': 'N',
	    '\u1E46': 'N',
	    '\u0145': 'N',
	    '\u1E4A': 'N',
	    '\u1E48': 'N',
	    '\u0220': 'N',
	    '\u019D': 'N',
	    '\uA790': 'N',
	    '\uA7A4': 'N',
	    '\u01CA': 'NJ',
	    '\u01CB': 'Nj',
	    '\u24C4': 'O',
	    '\uFF2F': 'O',
	    '\u00D2': 'O',
	    '\u00D3': 'O',
	    '\u00D4': 'O',
	    '\u1ED2': 'O',
	    '\u1ED0': 'O',
	    '\u1ED6': 'O',
	    '\u1ED4': 'O',
	    '\u00D5': 'O',
	    '\u1E4C': 'O',
	    '\u022C': 'O',
	    '\u1E4E': 'O',
	    '\u014C': 'O',
	    '\u1E50': 'O',
	    '\u1E52': 'O',
	    '\u014E': 'O',
	    '\u022E': 'O',
	    '\u0230': 'O',
	    '\u00D6': 'O',
	    '\u022A': 'O',
	    '\u1ECE': 'O',
	    '\u0150': 'O',
	    '\u01D1': 'O',
	    '\u020C': 'O',
	    '\u020E': 'O',
	    '\u01A0': 'O',
	    '\u1EDC': 'O',
	    '\u1EDA': 'O',
	    '\u1EE0': 'O',
	    '\u1EDE': 'O',
	    '\u1EE2': 'O',
	    '\u1ECC': 'O',
	    '\u1ED8': 'O',
	    '\u01EA': 'O',
	    '\u01EC': 'O',
	    '\u00D8': 'O',
	    '\u01FE': 'O',
	    '\u0186': 'O',
	    '\u019F': 'O',
	    '\uA74A': 'O',
	    '\uA74C': 'O',
	    '\u01A2': 'OI',
	    '\uA74E': 'OO',
	    '\u0222': 'OU',
	    '\u24C5': 'P',
	    '\uFF30': 'P',
	    '\u1E54': 'P',
	    '\u1E56': 'P',
	    '\u01A4': 'P',
	    '\u2C63': 'P',
	    '\uA750': 'P',
	    '\uA752': 'P',
	    '\uA754': 'P',
	    '\u24C6': 'Q',
	    '\uFF31': 'Q',
	    '\uA756': 'Q',
	    '\uA758': 'Q',
	    '\u024A': 'Q',
	    '\u24C7': 'R',
	    '\uFF32': 'R',
	    '\u0154': 'R',
	    '\u1E58': 'R',
	    '\u0158': 'R',
	    '\u0210': 'R',
	    '\u0212': 'R',
	    '\u1E5A': 'R',
	    '\u1E5C': 'R',
	    '\u0156': 'R',
	    '\u1E5E': 'R',
	    '\u024C': 'R',
	    '\u2C64': 'R',
	    '\uA75A': 'R',
	    '\uA7A6': 'R',
	    '\uA782': 'R',
	    '\u24C8': 'S',
	    '\uFF33': 'S',
	    '\u1E9E': 'S',
	    '\u015A': 'S',
	    '\u1E64': 'S',
	    '\u015C': 'S',
	    '\u1E60': 'S',
	    '\u0160': 'S',
	    '\u1E66': 'S',
	    '\u1E62': 'S',
	    '\u1E68': 'S',
	    '\u0218': 'S',
	    '\u015E': 'S',
	    '\u2C7E': 'S',
	    '\uA7A8': 'S',
	    '\uA784': 'S',
	    '\u24C9': 'T',
	    '\uFF34': 'T',
	    '\u1E6A': 'T',
	    '\u0164': 'T',
	    '\u1E6C': 'T',
	    '\u021A': 'T',
	    '\u0162': 'T',
	    '\u1E70': 'T',
	    '\u1E6E': 'T',
	    '\u0166': 'T',
	    '\u01AC': 'T',
	    '\u01AE': 'T',
	    '\u023E': 'T',
	    '\uA786': 'T',
	    '\uA728': 'TZ',
	    '\u24CA': 'U',
	    '\uFF35': 'U',
	    '\u00D9': 'U',
	    '\u00DA': 'U',
	    '\u00DB': 'U',
	    '\u0168': 'U',
	    '\u1E78': 'U',
	    '\u016A': 'U',
	    '\u1E7A': 'U',
	    '\u016C': 'U',
	    '\u00DC': 'U',
	    '\u01DB': 'U',
	    '\u01D7': 'U',
	    '\u01D5': 'U',
	    '\u01D9': 'U',
	    '\u1EE6': 'U',
	    '\u016E': 'U',
	    '\u0170': 'U',
	    '\u01D3': 'U',
	    '\u0214': 'U',
	    '\u0216': 'U',
	    '\u01AF': 'U',
	    '\u1EEA': 'U',
	    '\u1EE8': 'U',
	    '\u1EEE': 'U',
	    '\u1EEC': 'U',
	    '\u1EF0': 'U',
	    '\u1EE4': 'U',
	    '\u1E72': 'U',
	    '\u0172': 'U',
	    '\u1E76': 'U',
	    '\u1E74': 'U',
	    '\u0244': 'U',
	    '\u24CB': 'V',
	    '\uFF36': 'V',
	    '\u1E7C': 'V',
	    '\u1E7E': 'V',
	    '\u01B2': 'V',
	    '\uA75E': 'V',
	    '\u0245': 'V',
	    '\uA760': 'VY',
	    '\u24CC': 'W',
	    '\uFF37': 'W',
	    '\u1E80': 'W',
	    '\u1E82': 'W',
	    '\u0174': 'W',
	    '\u1E86': 'W',
	    '\u1E84': 'W',
	    '\u1E88': 'W',
	    '\u2C72': 'W',
	    '\u24CD': 'X',
	    '\uFF38': 'X',
	    '\u1E8A': 'X',
	    '\u1E8C': 'X',
	    '\u24CE': 'Y',
	    '\uFF39': 'Y',
	    '\u1EF2': 'Y',
	    '\u00DD': 'Y',
	    '\u0176': 'Y',
	    '\u1EF8': 'Y',
	    '\u0232': 'Y',
	    '\u1E8E': 'Y',
	    '\u0178': 'Y',
	    '\u1EF6': 'Y',
	    '\u1EF4': 'Y',
	    '\u01B3': 'Y',
	    '\u024E': 'Y',
	    '\u1EFE': 'Y',
	    '\u24CF': 'Z',
	    '\uFF3A': 'Z',
	    '\u0179': 'Z',
	    '\u1E90': 'Z',
	    '\u017B': 'Z',
	    '\u017D': 'Z',
	    '\u1E92': 'Z',
	    '\u1E94': 'Z',
	    '\u01B5': 'Z',
	    '\u0224': 'Z',
	    '\u2C7F': 'Z',
	    '\u2C6B': 'Z',
	    '\uA762': 'Z',
	    '\u24D0': 'a',
	    '\uFF41': 'a',
	    '\u1E9A': 'a',
	    '\u00E0': 'a',
	    '\u00E1': 'a',
	    '\u00E2': 'a',
	    '\u1EA7': 'a',
	    '\u1EA5': 'a',
	    '\u1EAB': 'a',
	    '\u1EA9': 'a',
	    '\u00E3': 'a',
	    '\u0101': 'a',
	    '\u0103': 'a',
	    '\u1EB1': 'a',
	    '\u1EAF': 'a',
	    '\u1EB5': 'a',
	    '\u1EB3': 'a',
	    '\u0227': 'a',
	    '\u01E1': 'a',
	    '\u00E4': 'a',
	    '\u01DF': 'a',
	    '\u1EA3': 'a',
	    '\u00E5': 'a',
	    '\u01FB': 'a',
	    '\u01CE': 'a',
	    '\u0201': 'a',
	    '\u0203': 'a',
	    '\u1EA1': 'a',
	    '\u1EAD': 'a',
	    '\u1EB7': 'a',
	    '\u1E01': 'a',
	    '\u0105': 'a',
	    '\u2C65': 'a',
	    '\u0250': 'a',
	    '\uA733': 'aa',
	    '\u00E6': 'ae',
	    '\u01FD': 'ae',
	    '\u01E3': 'ae',
	    '\uA735': 'ao',
	    '\uA737': 'au',
	    '\uA739': 'av',
	    '\uA73B': 'av',
	    '\uA73D': 'ay',
	    '\u24D1': 'b',
	    '\uFF42': 'b',
	    '\u1E03': 'b',
	    '\u1E05': 'b',
	    '\u1E07': 'b',
	    '\u0180': 'b',
	    '\u0183': 'b',
	    '\u0253': 'b',
	    '\u24D2': 'c',
	    '\uFF43': 'c',
	    '\u0107': 'c',
	    '\u0109': 'c',
	    '\u010B': 'c',
	    '\u010D': 'c',
	    '\u00E7': 'c',
	    '\u1E09': 'c',
	    '\u0188': 'c',
	    '\u023C': 'c',
	    '\uA73F': 'c',
	    '\u2184': 'c',
	    '\u24D3': 'd',
	    '\uFF44': 'd',
	    '\u1E0B': 'd',
	    '\u010F': 'd',
	    '\u1E0D': 'd',
	    '\u1E11': 'd',
	    '\u1E13': 'd',
	    '\u1E0F': 'd',
	    '\u0111': 'd',
	    '\u018C': 'd',
	    '\u0256': 'd',
	    '\u0257': 'd',
	    '\uA77A': 'd',
	    '\u01F3': 'dz',
	    '\u01C6': 'dz',
	    '\u24D4': 'e',
	    '\uFF45': 'e',
	    '\u00E8': 'e',
	    '\u00E9': 'e',
	    '\u00EA': 'e',
	    '\u1EC1': 'e',
	    '\u1EBF': 'e',
	    '\u1EC5': 'e',
	    '\u1EC3': 'e',
	    '\u1EBD': 'e',
	    '\u0113': 'e',
	    '\u1E15': 'e',
	    '\u1E17': 'e',
	    '\u0115': 'e',
	    '\u0117': 'e',
	    '\u00EB': 'e',
	    '\u1EBB': 'e',
	    '\u011B': 'e',
	    '\u0205': 'e',
	    '\u0207': 'e',
	    '\u1EB9': 'e',
	    '\u1EC7': 'e',
	    '\u0229': 'e',
	    '\u1E1D': 'e',
	    '\u0119': 'e',
	    '\u1E19': 'e',
	    '\u1E1B': 'e',
	    '\u0247': 'e',
	    '\u025B': 'e',
	    '\u01DD': 'e',
	    '\u24D5': 'f',
	    '\uFF46': 'f',
	    '\u1E1F': 'f',
	    '\u0192': 'f',
	    '\uA77C': 'f',
	    '\u24D6': 'g',
	    '\uFF47': 'g',
	    '\u01F5': 'g',
	    '\u011D': 'g',
	    '\u1E21': 'g',
	    '\u011F': 'g',
	    '\u0121': 'g',
	    '\u01E7': 'g',
	    '\u0123': 'g',
	    '\u01E5': 'g',
	    '\u0260': 'g',
	    '\uA7A1': 'g',
	    '\u1D79': 'g',
	    '\uA77F': 'g',
	    '\u24D7': 'h',
	    '\uFF48': 'h',
	    '\u0125': 'h',
	    '\u1E23': 'h',
	    '\u1E27': 'h',
	    '\u021F': 'h',
	    '\u1E25': 'h',
	    '\u1E29': 'h',
	    '\u1E2B': 'h',
	    '\u1E96': 'h',
	    '\u0127': 'h',
	    '\u2C68': 'h',
	    '\u2C76': 'h',
	    '\u0265': 'h',
	    '\u0195': 'hv',
	    '\u24D8': 'i',
	    '\uFF49': 'i',
	    '\u00EC': 'i',
	    '\u00ED': 'i',
	    '\u00EE': 'i',
	    '\u0129': 'i',
	    '\u012B': 'i',
	    '\u012D': 'i',
	    '\u00EF': 'i',
	    '\u1E2F': 'i',
	    '\u1EC9': 'i',
	    '\u01D0': 'i',
	    '\u0209': 'i',
	    '\u020B': 'i',
	    '\u1ECB': 'i',
	    '\u012F': 'i',
	    '\u1E2D': 'i',
	    '\u0268': 'i',
	    '\u0131': 'i',
	    '\u24D9': 'j',
	    '\uFF4A': 'j',
	    '\u0135': 'j',
	    '\u01F0': 'j',
	    '\u0249': 'j',
	    '\u24DA': 'k',
	    '\uFF4B': 'k',
	    '\u1E31': 'k',
	    '\u01E9': 'k',
	    '\u1E33': 'k',
	    '\u0137': 'k',
	    '\u1E35': 'k',
	    '\u0199': 'k',
	    '\u2C6A': 'k',
	    '\uA741': 'k',
	    '\uA743': 'k',
	    '\uA745': 'k',
	    '\uA7A3': 'k',
	    '\u24DB': 'l',
	    '\uFF4C': 'l',
	    '\u0140': 'l',
	    '\u013A': 'l',
	    '\u013E': 'l',
	    '\u1E37': 'l',
	    '\u1E39': 'l',
	    '\u013C': 'l',
	    '\u1E3D': 'l',
	    '\u1E3B': 'l',
	    '\u017F': 'l',
	    '\u0142': 'l',
	    '\u019A': 'l',
	    '\u026B': 'l',
	    '\u2C61': 'l',
	    '\uA749': 'l',
	    '\uA781': 'l',
	    '\uA747': 'l',
	    '\u01C9': 'lj',
	    '\u24DC': 'm',
	    '\uFF4D': 'm',
	    '\u1E3F': 'm',
	    '\u1E41': 'm',
	    '\u1E43': 'm',
	    '\u0271': 'm',
	    '\u026F': 'm',
	    '\u24DD': 'n',
	    '\uFF4E': 'n',
	    '\u01F9': 'n',
	    '\u0144': 'n',
	    '\u00F1': 'n',
	    '\u1E45': 'n',
	    '\u0148': 'n',
	    '\u1E47': 'n',
	    '\u0146': 'n',
	    '\u1E4B': 'n',
	    '\u1E49': 'n',
	    '\u019E': 'n',
	    '\u0272': 'n',
	    '\u0149': 'n',
	    '\uA791': 'n',
	    '\uA7A5': 'n',
	    '\u01CC': 'nj',
	    '\u24DE': 'o',
	    '\uFF4F': 'o',
	    '\u00F2': 'o',
	    '\u00F3': 'o',
	    '\u00F4': 'o',
	    '\u1ED3': 'o',
	    '\u1ED1': 'o',
	    '\u1ED7': 'o',
	    '\u1ED5': 'o',
	    '\u00F5': 'o',
	    '\u1E4D': 'o',
	    '\u022D': 'o',
	    '\u1E4F': 'o',
	    '\u014D': 'o',
	    '\u1E51': 'o',
	    '\u1E53': 'o',
	    '\u014F': 'o',
	    '\u022F': 'o',
	    '\u0231': 'o',
	    '\u00F6': 'o',
	    '\u022B': 'o',
	    '\u1ECF': 'o',
	    '\u0151': 'o',
	    '\u01D2': 'o',
	    '\u020D': 'o',
	    '\u020F': 'o',
	    '\u01A1': 'o',
	    '\u1EDD': 'o',
	    '\u1EDB': 'o',
	    '\u1EE1': 'o',
	    '\u1EDF': 'o',
	    '\u1EE3': 'o',
	    '\u1ECD': 'o',
	    '\u1ED9': 'o',
	    '\u01EB': 'o',
	    '\u01ED': 'o',
	    '\u00F8': 'o',
	    '\u01FF': 'o',
	    '\u0254': 'o',
	    '\uA74B': 'o',
	    '\uA74D': 'o',
	    '\u0275': 'o',
	    '\u01A3': 'oi',
	    '\u0223': 'ou',
	    '\uA74F': 'oo',
	    '\u24DF': 'p',
	    '\uFF50': 'p',
	    '\u1E55': 'p',
	    '\u1E57': 'p',
	    '\u01A5': 'p',
	    '\u1D7D': 'p',
	    '\uA751': 'p',
	    '\uA753': 'p',
	    '\uA755': 'p',
	    '\u24E0': 'q',
	    '\uFF51': 'q',
	    '\u024B': 'q',
	    '\uA757': 'q',
	    '\uA759': 'q',
	    '\u24E1': 'r',
	    '\uFF52': 'r',
	    '\u0155': 'r',
	    '\u1E59': 'r',
	    '\u0159': 'r',
	    '\u0211': 'r',
	    '\u0213': 'r',
	    '\u1E5B': 'r',
	    '\u1E5D': 'r',
	    '\u0157': 'r',
	    '\u1E5F': 'r',
	    '\u024D': 'r',
	    '\u027D': 'r',
	    '\uA75B': 'r',
	    '\uA7A7': 'r',
	    '\uA783': 'r',
	    '\u24E2': 's',
	    '\uFF53': 's',
	    '\u00DF': 's',
	    '\u015B': 's',
	    '\u1E65': 's',
	    '\u015D': 's',
	    '\u1E61': 's',
	    '\u0161': 's',
	    '\u1E67': 's',
	    '\u1E63': 's',
	    '\u1E69': 's',
	    '\u0219': 's',
	    '\u015F': 's',
	    '\u023F': 's',
	    '\uA7A9': 's',
	    '\uA785': 's',
	    '\u1E9B': 's',
	    '\u24E3': 't',
	    '\uFF54': 't',
	    '\u1E6B': 't',
	    '\u1E97': 't',
	    '\u0165': 't',
	    '\u1E6D': 't',
	    '\u021B': 't',
	    '\u0163': 't',
	    '\u1E71': 't',
	    '\u1E6F': 't',
	    '\u0167': 't',
	    '\u01AD': 't',
	    '\u0288': 't',
	    '\u2C66': 't',
	    '\uA787': 't',
	    '\uA729': 'tz',
	    '\u24E4': 'u',
	    '\uFF55': 'u',
	    '\u00F9': 'u',
	    '\u00FA': 'u',
	    '\u00FB': 'u',
	    '\u0169': 'u',
	    '\u1E79': 'u',
	    '\u016B': 'u',
	    '\u1E7B': 'u',
	    '\u016D': 'u',
	    '\u00FC': 'u',
	    '\u01DC': 'u',
	    '\u01D8': 'u',
	    '\u01D6': 'u',
	    '\u01DA': 'u',
	    '\u1EE7': 'u',
	    '\u016F': 'u',
	    '\u0171': 'u',
	    '\u01D4': 'u',
	    '\u0215': 'u',
	    '\u0217': 'u',
	    '\u01B0': 'u',
	    '\u1EEB': 'u',
	    '\u1EE9': 'u',
	    '\u1EEF': 'u',
	    '\u1EED': 'u',
	    '\u1EF1': 'u',
	    '\u1EE5': 'u',
	    '\u1E73': 'u',
	    '\u0173': 'u',
	    '\u1E77': 'u',
	    '\u1E75': 'u',
	    '\u0289': 'u',
	    '\u24E5': 'v',
	    '\uFF56': 'v',
	    '\u1E7D': 'v',
	    '\u1E7F': 'v',
	    '\u028B': 'v',
	    '\uA75F': 'v',
	    '\u028C': 'v',
	    '\uA761': 'vy',
	    '\u24E6': 'w',
	    '\uFF57': 'w',
	    '\u1E81': 'w',
	    '\u1E83': 'w',
	    '\u0175': 'w',
	    '\u1E87': 'w',
	    '\u1E85': 'w',
	    '\u1E98': 'w',
	    '\u1E89': 'w',
	    '\u2C73': 'w',
	    '\u24E7': 'x',
	    '\uFF58': 'x',
	    '\u1E8B': 'x',
	    '\u1E8D': 'x',
	    '\u24E8': 'y',
	    '\uFF59': 'y',
	    '\u1EF3': 'y',
	    '\u00FD': 'y',
	    '\u0177': 'y',
	    '\u1EF9': 'y',
	    '\u0233': 'y',
	    '\u1E8F': 'y',
	    '\u00FF': 'y',
	    '\u1EF7': 'y',
	    '\u1E99': 'y',
	    '\u1EF5': 'y',
	    '\u01B4': 'y',
	    '\u024F': 'y',
	    '\u1EFF': 'y',
	    '\u24E9': 'z',
	    '\uFF5A': 'z',
	    '\u017A': 'z',
	    '\u1E91': 'z',
	    '\u017C': 'z',
	    '\u017E': 'z',
	    '\u1E93': 'z',
	    '\u1E95': 'z',
	    '\u01B6': 'z',
	    '\u0225': 'z',
	    '\u0240': 'z',
	    '\u2C6C': 'z',
	    '\uA763': 'z',
	    '\u0386': '\u0391',
	    '\u0388': '\u0395',
	    '\u0389': '\u0397',
	    '\u038A': '\u0399',
	    '\u03AA': '\u0399',
	    '\u038C': '\u039F',
	    '\u038E': '\u03A5',
	    '\u03AB': '\u03A5',
	    '\u038F': '\u03A9',
	    '\u03AC': '\u03B1',
	    '\u03AD': '\u03B5',
	    '\u03AE': '\u03B7',
	    '\u03AF': '\u03B9',
	    '\u03CA': '\u03B9',
	    '\u0390': '\u03B9',
	    '\u03CC': '\u03BF',
	    '\u03CD': '\u03C5',
	    '\u03CB': '\u03C5',
	    '\u03B0': '\u03C5',
	    '\u03C9': '\u03C9',
	    '\u03C2': '\u03C3'
	  };
	
	  return diacritics;
	});
	
	S2.define('select2/data/base',[
	  '../utils'
	], function (Utils) {
	  function BaseAdapter ($element, options) {
	    BaseAdapter.__super__.constructor.call(this);
	  }
	
	  Utils.Extend(BaseAdapter, Utils.Observable);
	
	  BaseAdapter.prototype.current = function (callback) {
	    throw new Error('The `current` method must be defined in child classes.');
	  };
	
	  BaseAdapter.prototype.query = function (params, callback) {
	    throw new Error('The `query` method must be defined in child classes.');
	  };
	
	  BaseAdapter.prototype.bind = function (container, $container) {
	    // Can be implemented in subclasses
	  };
	
	  BaseAdapter.prototype.destroy = function () {
	    // Can be implemented in subclasses
	  };
	
	  BaseAdapter.prototype.generateResultId = function (container, data) {
	    var id = container.id + '-result-';
	
	    id += Utils.generateChars(4);
	
	    if (data.id != null) {
	      id += '-' + data.id.toString();
	    } else {
	      id += '-' + Utils.generateChars(4);
	    }
	    return id;
	  };
	
	  return BaseAdapter;
	});
	
	S2.define('select2/data/select',[
	  './base',
	  '../utils',
	  'jquery'
	], function (BaseAdapter, Utils, $) {
	  function SelectAdapter ($element, options) {
	    this.$element = $element;
	    this.options = options;
	
	    SelectAdapter.__super__.constructor.call(this);
	  }
	
	  Utils.Extend(SelectAdapter, BaseAdapter);
	
	  SelectAdapter.prototype.current = function (callback) {
	    var data = [];
	    var self = this;
	
	    this.$element.find(':selected').each(function () {
	      var $option = $(this);
	
	      var option = self.item($option);
	
	      data.push(option);
	    });
	
	    callback(data);
	  };
	
	  SelectAdapter.prototype.select = function (data) {
	    var self = this;
	
	    data.selected = true;
	
	    // If data.element is a DOM node, use it instead
	    if ($(data.element).is('option')) {
	      data.element.selected = true;
	
	      this.$element.trigger('change');
	
	      return;
	    }
	
	    if (this.$element.prop('multiple')) {
	      this.current(function (currentData) {
	        var val = [];
	
	        data = [data];
	        data.push.apply(data, currentData);
	
	        for (var d = 0; d < data.length; d++) {
	          var id = data[d].id;
	
	          if ($.inArray(id, val) === -1) {
	            val.push(id);
	          }
	        }
	
	        self.$element.val(val);
	        self.$element.trigger('change');
	      });
	    } else {
	      var val = data.id;
	
	      this.$element.val(val);
	      this.$element.trigger('change');
	    }
	  };
	
	  SelectAdapter.prototype.unselect = function (data) {
	    var self = this;
	
	    if (!this.$element.prop('multiple')) {
	      return;
	    }
	
	    data.selected = false;
	
	    if ($(data.element).is('option')) {
	      data.element.selected = false;
	
	      this.$element.trigger('change');
	
	      return;
	    }
	
	    this.current(function (currentData) {
	      var val = [];
	
	      for (var d = 0; d < currentData.length; d++) {
	        var id = currentData[d].id;
	
	        if (id !== data.id && $.inArray(id, val) === -1) {
	          val.push(id);
	        }
	      }
	
	      self.$element.val(val);
	
	      self.$element.trigger('change');
	    });
	  };
	
	  SelectAdapter.prototype.bind = function (container, $container) {
	    var self = this;
	
	    this.container = container;
	
	    container.on('select', function (params) {
	      self.select(params.data);
	    });
	
	    container.on('unselect', function (params) {
	      self.unselect(params.data);
	    });
	  };
	
	  SelectAdapter.prototype.destroy = function () {
	    // Remove anything added to child elements
	    this.$element.find('*').each(function () {
	      // Remove any custom data set by Select2
	      $.removeData(this, 'data');
	    });
	  };
	
	  SelectAdapter.prototype.query = function (params, callback) {
	    var data = [];
	    var self = this;
	
	    var $options = this.$element.children();
	
	    $options.each(function () {
	      var $option = $(this);
	
	      if (!$option.is('option') && !$option.is('optgroup')) {
	        return;
	      }
	
	      var option = self.item($option);
	
	      var matches = self.matches(params, option);
	
	      if (matches !== null) {
	        data.push(matches);
	      }
	    });
	
	    callback({
	      results: data
	    });
	  };
	
	  SelectAdapter.prototype.addOptions = function ($options) {
	    Utils.appendMany(this.$element, $options);
	  };
	
	  SelectAdapter.prototype.option = function (data) {
	    var option;
	
	    if (data.children) {
	      option = document.createElement('optgroup');
	      option.label = data.text;
	    } else {
	      option = document.createElement('option');
	
	      if (option.textContent !== undefined) {
	        option.textContent = data.text;
	      } else {
	        option.innerText = data.text;
	      }
	    }
	
	    if (data.id) {
	      option.value = data.id;
	    }
	
	    if (data.disabled) {
	      option.disabled = true;
	    }
	
	    if (data.selected) {
	      option.selected = true;
	    }
	
	    if (data.title) {
	      option.title = data.title;
	    }
	
	    var $option = $(option);
	
	    var normalizedData = this._normalizeItem(data);
	    normalizedData.element = option;
	
	    // Override the option's data with the combined data
	    $.data(option, 'data', normalizedData);
	
	    return $option;
	  };
	
	  SelectAdapter.prototype.item = function ($option) {
	    var data = {};
	
	    data = $.data($option[0], 'data');
	
	    if (data != null) {
	      return data;
	    }
	
	    if ($option.is('option')) {
	      data = {
	        id: $option.val(),
	        text: $option.text(),
	        disabled: $option.prop('disabled'),
	        selected: $option.prop('selected'),
	        title: $option.prop('title')
	      };
	    } else if ($option.is('optgroup')) {
	      data = {
	        text: $option.prop('label'),
	        children: [],
	        title: $option.prop('title')
	      };
	
	      var $children = $option.children('option');
	      var children = [];
	
	      for (var c = 0; c < $children.length; c++) {
	        var $child = $($children[c]);
	
	        var child = this.item($child);
	
	        children.push(child);
	      }
	
	      data.children = children;
	    }
	
	    data = this._normalizeItem(data);
	    data.element = $option[0];
	
	    $.data($option[0], 'data', data);
	
	    return data;
	  };
	
	  SelectAdapter.prototype._normalizeItem = function (item) {
	    if (!$.isPlainObject(item)) {
	      item = {
	        id: item,
	        text: item
	      };
	    }
	
	    item = $.extend({}, {
	      text: ''
	    }, item);
	
	    var defaults = {
	      selected: false,
	      disabled: false
	    };
	
	    if (item.id != null) {
	      item.id = item.id.toString();
	    }
	
	    if (item.text != null) {
	      item.text = item.text.toString();
	    }
	
	    if (item._resultId == null && item.id && this.container != null) {
	      item._resultId = this.generateResultId(this.container, item);
	    }
	
	    return $.extend({}, defaults, item);
	  };
	
	  SelectAdapter.prototype.matches = function (params, data) {
	    var matcher = this.options.get('matcher');
	
	    return matcher(params, data);
	  };
	
	  return SelectAdapter;
	});
	
	S2.define('select2/data/array',[
	  './select',
	  '../utils',
	  'jquery'
	], function (SelectAdapter, Utils, $) {
	  function ArrayAdapter ($element, options) {
	    var data = options.get('data') || [];
	
	    ArrayAdapter.__super__.constructor.call(this, $element, options);
	
	    this.addOptions(this.convertToOptions(data));
	  }
	
	  Utils.Extend(ArrayAdapter, SelectAdapter);
	
	  ArrayAdapter.prototype.select = function (data) {
	    var $option = this.$element.find('option').filter(function (i, elm) {
	      return elm.value == data.id.toString();
	    });
	
	    if ($option.length === 0) {
	      $option = this.option(data);
	
	      this.addOptions($option);
	    }
	
	    ArrayAdapter.__super__.select.call(this, data);
	  };
	
	  ArrayAdapter.prototype.convertToOptions = function (data) {
	    var self = this;
	
	    var $existing = this.$element.find('option');
	    var existingIds = $existing.map(function () {
	      return self.item($(this)).id;
	    }).get();
	
	    var $options = [];
	
	    // Filter out all items except for the one passed in the argument
	    function onlyItem (item) {
	      return function () {
	        return $(this).val() == item.id;
	      };
	    }
	
	    for (var d = 0; d < data.length; d++) {
	      var item = this._normalizeItem(data[d]);
	
	      // Skip items which were pre-loaded, only merge the data
	      if ($.inArray(item.id, existingIds) >= 0) {
	        var $existingOption = $existing.filter(onlyItem(item));
	
	        var existingData = this.item($existingOption);
	        var newData = $.extend(true, {}, item, existingData);
	
	        var $newOption = this.option(newData);
	
	        $existingOption.replaceWith($newOption);
	
	        continue;
	      }
	
	      var $option = this.option(item);
	
	      if (item.children) {
	        var $children = this.convertToOptions(item.children);
	
	        Utils.appendMany($option, $children);
	      }
	
	      $options.push($option);
	    }
	
	    return $options;
	  };
	
	  return ArrayAdapter;
	});
	
	S2.define('select2/data/ajax',[
	  './array',
	  '../utils',
	  'jquery'
	], function (ArrayAdapter, Utils, $) {
	  function AjaxAdapter ($element, options) {
	    this.ajaxOptions = this._applyDefaults(options.get('ajax'));
	
	    if (this.ajaxOptions.processResults != null) {
	      this.processResults = this.ajaxOptions.processResults;
	    }
	
	    AjaxAdapter.__super__.constructor.call(this, $element, options);
	  }
	
	  Utils.Extend(AjaxAdapter, ArrayAdapter);
	
	  AjaxAdapter.prototype._applyDefaults = function (options) {
	    var defaults = {
	      data: function (params) {
	        return $.extend({}, params, {
	          q: params.term
	        });
	      },
	      transport: function (params, success, failure) {
	        var $request = $.ajax(params);
	
	        $request.then(success);
	        $request.fail(failure);
	
	        return $request;
	      }
	    };
	
	    return $.extend({}, defaults, options, true);
	  };
	
	  AjaxAdapter.prototype.processResults = function (results) {
	    return results;
	  };
	
	  AjaxAdapter.prototype.query = function (params, callback) {
	    var matches = [];
	    var self = this;
	
	    if (this._request != null) {
	      // JSONP requests cannot always be aborted
	      if ($.isFunction(this._request.abort)) {
	        this._request.abort();
	      }
	
	      this._request = null;
	    }
	
	    var options = $.extend({
	      type: 'GET'
	    }, this.ajaxOptions);
	
	    if (typeof options.url === 'function') {
	      options.url = options.url.call(this.$element, params);
	    }
	
	    if (typeof options.data === 'function') {
	      options.data = options.data.call(this.$element, params);
	    }
	
	    function request () {
	      var $request = options.transport(options, function (data) {
	        var results = self.processResults(data, params);
	
	        if (self.options.get('debug') && window.console && console.error) {
	          // Check to make sure that the response included a `results` key.
	          if (!results || !results.results || !$.isArray(results.results)) {
	            console.error(
	              'Select2: The AJAX results did not return an array in the ' +
	              '`results` key of the response.'
	            );
	          }
	        }
	
	        callback(results);
	      }, function () {
	        // Attempt to detect if a request was aborted
	        // Only works if the transport exposes a status property
	        if ($request.status && $request.status === '0') {
	          return;
	        }
	
	        self.trigger('results:message', {
	          message: 'errorLoading'
	        });
	      });
	
	      self._request = $request;
	    }
	
	    if (this.ajaxOptions.delay && params.term != null) {
	      if (this._queryTimeout) {
	        window.clearTimeout(this._queryTimeout);
	      }
	
	      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
	    } else {
	      request();
	    }
	  };
	
	  return AjaxAdapter;
	});
	
	S2.define('select2/data/tags',[
	  'jquery'
	], function ($) {
	  function Tags (decorated, $element, options) {
	    var tags = options.get('tags');
	
	    var createTag = options.get('createTag');
	
	    if (createTag !== undefined) {
	      this.createTag = createTag;
	    }
	
	    var insertTag = options.get('insertTag');
	
	    if (insertTag !== undefined) {
	        this.insertTag = insertTag;
	    }
	
	    decorated.call(this, $element, options);
	
	    if ($.isArray(tags)) {
	      for (var t = 0; t < tags.length; t++) {
	        var tag = tags[t];
	        var item = this._normalizeItem(tag);
	
	        var $option = this.option(item);
	
	        this.$element.append($option);
	      }
	    }
	  }
	
	  Tags.prototype.query = function (decorated, params, callback) {
	    var self = this;
	
	    this._removeOldTags();
	
	    if (params.term == null || params.page != null) {
	      decorated.call(this, params, callback);
	      return;
	    }
	
	    function wrapper (obj, child) {
	      var data = obj.results;
	
	      for (var i = 0; i < data.length; i++) {
	        var option = data[i];
	
	        var checkChildren = (
	          option.children != null &&
	          !wrapper({
	            results: option.children
	          }, true)
	        );
	
	        var checkText = option.text === params.term;
	
	        if (checkText || checkChildren) {
	          if (child) {
	            return false;
	          }
	
	          obj.data = data;
	          callback(obj);
	
	          return;
	        }
	      }
	
	      if (child) {
	        return true;
	      }
	
	      var tag = self.createTag(params);
	
	      if (tag != null) {
	        var $option = self.option(tag);
	        $option.attr('data-select2-tag', true);
	
	        self.addOptions([$option]);
	
	        self.insertTag(data, tag);
	      }
	
	      obj.results = data;
	
	      callback(obj);
	    }
	
	    decorated.call(this, params, wrapper);
	  };
	
	  Tags.prototype.createTag = function (decorated, params) {
	    var term = $.trim(params.term);
	
	    if (term === '') {
	      return null;
	    }
	
	    return {
	      id: term,
	      text: term
	    };
	  };
	
	  Tags.prototype.insertTag = function (_, data, tag) {
	    data.unshift(tag);
	  };
	
	  Tags.prototype._removeOldTags = function (_) {
	    var tag = this._lastTag;
	
	    var $options = this.$element.find('option[data-select2-tag]');
	
	    $options.each(function () {
	      if (this.selected) {
	        return;
	      }
	
	      $(this).remove();
	    });
	  };
	
	  return Tags;
	});
	
	S2.define('select2/data/tokenizer',[
	  'jquery'
	], function ($) {
	  function Tokenizer (decorated, $element, options) {
	    var tokenizer = options.get('tokenizer');
	
	    if (tokenizer !== undefined) {
	      this.tokenizer = tokenizer;
	    }
	
	    decorated.call(this, $element, options);
	  }
	
	  Tokenizer.prototype.bind = function (decorated, container, $container) {
	    decorated.call(this, container, $container);
	
	    this.$search =  container.dropdown.$search || container.selection.$search ||
	      $container.find('.select2-search__field');
	  };
	
	  Tokenizer.prototype.query = function (decorated, params, callback) {
	    var self = this;
	
	    function createAndSelect (data) {
	      // Normalize the data object so we can use it for checks
	      var item = self._normalizeItem(data);
	
	      // Check if the data object already exists as a tag
	      // Select it if it doesn't
	      var $existingOptions = self.$element.find('option').filter(function () {
	        return $(this).val() === item.id;
	      });
	
	      // If an existing option wasn't found for it, create the option
	      if (!$existingOptions.length) {
	        var $option = self.option(item);
	        $option.attr('data-select2-tag', true);
	
	        self._removeOldTags();
	        self.addOptions([$option]);
	      }
	
	      // Select the item, now that we know there is an option for it
	      select(item);
	    }
	
	    function select (data) {
	      self.trigger('select', {
	        data: data
	      });
	    }
	
	    params.term = params.term || '';
	
	    var tokenData = this.tokenizer(params, this.options, createAndSelect);
	
	    if (tokenData.term !== params.term) {
	      // Replace the search term if we have the search box
	      if (this.$search.length) {
	        this.$search.val(tokenData.term);
	        this.$search.focus();
	      }
	
	      params.term = tokenData.term;
	    }
	
	    decorated.call(this, params, callback);
	  };
	
	  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
	    var separators = options.get('tokenSeparators') || [];
	    var term = params.term;
	    var i = 0;
	
	    var createTag = this.createTag || function (params) {
	      return {
	        id: params.term,
	        text: params.term
	      };
	    };
	
	    while (i < term.length) {
	      var termChar = term[i];
	
	      if ($.inArray(termChar, separators) === -1) {
	        i++;
	
	        continue;
	      }
	
	      var part = term.substr(0, i);
	      var partParams = $.extend({}, params, {
	        term: part
	      });
	
	      var data = createTag(partParams);
	
	      if (data == null) {
	        i++;
	        continue;
	      }
	
	      callback(data);
	
	      // Reset the term to not include the tokenized portion
	      term = term.substr(i + 1) || '';
	      i = 0;
	    }
	
	    return {
	      term: term
	    };
	  };
	
	  return Tokenizer;
	});
	
	S2.define('select2/data/minimumInputLength',[
	
	], function () {
	  function MinimumInputLength (decorated, $e, options) {
	    this.minimumInputLength = options.get('minimumInputLength');
	
	    decorated.call(this, $e, options);
	  }
	
	  MinimumInputLength.prototype.query = function (decorated, params, callback) {
	    params.term = params.term || '';
	
	    if (params.term.length < this.minimumInputLength) {
	      this.trigger('results:message', {
	        message: 'inputTooShort',
	        args: {
	          minimum: this.minimumInputLength,
	          input: params.term,
	          params: params
	        }
	      });
	
	      return;
	    }
	
	    decorated.call(this, params, callback);
	  };
	
	  return MinimumInputLength;
	});
	
	S2.define('select2/data/maximumInputLength',[
	
	], function () {
	  function MaximumInputLength (decorated, $e, options) {
	    this.maximumInputLength = options.get('maximumInputLength');
	
	    decorated.call(this, $e, options);
	  }
	
	  MaximumInputLength.prototype.query = function (decorated, params, callback) {
	    params.term = params.term || '';
	
	    if (this.maximumInputLength > 0 &&
	        params.term.length > this.maximumInputLength) {
	      this.trigger('results:message', {
	        message: 'inputTooLong',
	        args: {
	          maximum: this.maximumInputLength,
	          input: params.term,
	          params: params
	        }
	      });
	
	      return;
	    }
	
	    decorated.call(this, params, callback);
	  };
	
	  return MaximumInputLength;
	});
	
	S2.define('select2/data/maximumSelectionLength',[
	
	], function (){
	  function MaximumSelectionLength (decorated, $e, options) {
	    this.maximumSelectionLength = options.get('maximumSelectionLength');
	
	    decorated.call(this, $e, options);
	  }
	
	  MaximumSelectionLength.prototype.query =
	    function (decorated, params, callback) {
	      var self = this;
	
	      this.current(function (currentData) {
	        var count = currentData != null ? currentData.length : 0;
	        if (self.maximumSelectionLength > 0 &&
	          count >= self.maximumSelectionLength) {
	          self.trigger('results:message', {
	            message: 'maximumSelected',
	            args: {
	              maximum: self.maximumSelectionLength
	            }
	          });
	          return;
	        }
	        decorated.call(self, params, callback);
	      });
	  };
	
	  return MaximumSelectionLength;
	});
	
	S2.define('select2/dropdown',[
	  'jquery',
	  './utils'
	], function ($, Utils) {
	  function Dropdown ($element, options) {
	    this.$element = $element;
	    this.options = options;
	
	    Dropdown.__super__.constructor.call(this);
	  }
	
	  Utils.Extend(Dropdown, Utils.Observable);
	
	  Dropdown.prototype.render = function () {
	    var $dropdown = $(
	      '<span class="select2-dropdown">' +
	        '<span class="select2-results"></span>' +
	      '</span>'
	    );
	
	    $dropdown.attr('dir', this.options.get('dir'));
	
	    this.$dropdown = $dropdown;
	
	    return $dropdown;
	  };
	
	  Dropdown.prototype.bind = function () {
	    // Should be implemented in subclasses
	  };
	
	  Dropdown.prototype.position = function ($dropdown, $container) {
	    // Should be implmented in subclasses
	  };
	
	  Dropdown.prototype.destroy = function () {
	    // Remove the dropdown from the DOM
	    this.$dropdown.remove();
	  };
	
	  return Dropdown;
	});
	
	S2.define('select2/dropdown/search',[
	  'jquery',
	  '../utils'
	], function ($, Utils) {
	  function Search () { }
	
	  Search.prototype.render = function (decorated) {
	    var $rendered = decorated.call(this);
	
	    var $search = $(
	      '<span class="select2-search select2-search--dropdown">' +
	        '<input class="select2-search__field" type="search" tabindex="-1"' +
	        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
	        ' spellcheck="false" role="textbox" />' +
	      '</span>'
	    );
	
	    this.$searchContainer = $search;
	    this.$search = $search.find('input');
	
	    $rendered.prepend($search);
	
	    return $rendered;
	  };
	
	  Search.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    this.$search.on('keydown', function (evt) {
	      self.trigger('keypress', evt);
	
	      self._keyUpPrevented = evt.isDefaultPrevented();
	    });
	
	    // Workaround for browsers which do not support the `input` event
	    // This will prevent double-triggering of events for browsers which support
	    // both the `keyup` and `input` events.
	    this.$search.on('input', function (evt) {
	      // Unbind the duplicated `keyup` event
	      $(this).off('keyup');
	    });
	
	    this.$search.on('keyup input', function (evt) {
	      self.handleSearch(evt);
	    });
	
	    container.on('open', function () {
	      self.$search.attr('tabindex', 0);
	
	      self.$search.focus();
	
	      window.setTimeout(function () {
	        self.$search.focus();
	      }, 0);
	    });
	
	    container.on('close', function () {
	      self.$search.attr('tabindex', -1);
	
	      self.$search.val('');
	    });
	
	    container.on('focus', function () {
	      if (container.isOpen()) {
	        self.$search.focus();
	      }
	    });
	
	    container.on('results:all', function (params) {
	      if (params.query.term == null || params.query.term === '') {
	        var showSearch = self.showSearch(params);
	
	        if (showSearch) {
	          self.$searchContainer.removeClass('select2-search--hide');
	        } else {
	          self.$searchContainer.addClass('select2-search--hide');
	        }
	      }
	    });
	  };
	
	  Search.prototype.handleSearch = function (evt) {
	    if (!this._keyUpPrevented) {
	      var input = this.$search.val();
	
	      this.trigger('query', {
	        term: input
	      });
	    }
	
	    this._keyUpPrevented = false;
	  };
	
	  Search.prototype.showSearch = function (_, params) {
	    return true;
	  };
	
	  return Search;
	});
	
	S2.define('select2/dropdown/hidePlaceholder',[
	
	], function () {
	  function HidePlaceholder (decorated, $element, options, dataAdapter) {
	    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
	
	    decorated.call(this, $element, options, dataAdapter);
	  }
	
	  HidePlaceholder.prototype.append = function (decorated, data) {
	    data.results = this.removePlaceholder(data.results);
	
	    decorated.call(this, data);
	  };
	
	  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
	    if (typeof placeholder === 'string') {
	      placeholder = {
	        id: '',
	        text: placeholder
	      };
	    }
	
	    return placeholder;
	  };
	
	  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
	    var modifiedData = data.slice(0);
	
	    for (var d = data.length - 1; d >= 0; d--) {
	      var item = data[d];
	
	      if (this.placeholder.id === item.id) {
	        modifiedData.splice(d, 1);
	      }
	    }
	
	    return modifiedData;
	  };
	
	  return HidePlaceholder;
	});
	
	S2.define('select2/dropdown/infiniteScroll',[
	  'jquery'
	], function ($) {
	  function InfiniteScroll (decorated, $element, options, dataAdapter) {
	    this.lastParams = {};
	
	    decorated.call(this, $element, options, dataAdapter);
	
	    this.$loadingMore = this.createLoadingMore();
	    this.loading = false;
	  }
	
	  InfiniteScroll.prototype.append = function (decorated, data) {
	    this.$loadingMore.remove();
	    this.loading = false;
	
	    decorated.call(this, data);
	
	    if (this.showLoadingMore(data)) {
	      this.$results.append(this.$loadingMore);
	    }
	  };
	
	  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    container.on('query', function (params) {
	      self.lastParams = params;
	      self.loading = true;
	    });
	
	    container.on('query:append', function (params) {
	      self.lastParams = params;
	      self.loading = true;
	    });
	
	    this.$results.on('scroll', function () {
	      var isLoadMoreVisible = $.contains(
	        document.documentElement,
	        self.$loadingMore[0]
	      );
	
	      if (self.loading || !isLoadMoreVisible) {
	        return;
	      }
	
	      var currentOffset = self.$results.offset().top +
	        self.$results.outerHeight(false);
	      var loadingMoreOffset = self.$loadingMore.offset().top +
	        self.$loadingMore.outerHeight(false);
	
	      if (currentOffset + 50 >= loadingMoreOffset) {
	        self.loadMore();
	      }
	    });
	  };
	
	  InfiniteScroll.prototype.loadMore = function () {
	    this.loading = true;
	
	    var params = $.extend({}, {page: 1}, this.lastParams);
	
	    params.page++;
	
	    this.trigger('query:append', params);
	  };
	
	  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
	    return data.pagination && data.pagination.more;
	  };
	
	  InfiniteScroll.prototype.createLoadingMore = function () {
	    var $option = $(
	      '<li ' +
	      'class="select2-results__option select2-results__option--load-more"' +
	      'role="treeitem" aria-disabled="true"></li>'
	    );
	
	    var message = this.options.get('translations').get('loadingMore');
	
	    $option.html(message(this.lastParams));
	
	    return $option;
	  };
	
	  return InfiniteScroll;
	});
	
	S2.define('select2/dropdown/attachBody',[
	  'jquery',
	  '../utils'
	], function ($, Utils) {
	  function AttachBody (decorated, $element, options) {
	    this.$dropdownParent = options.get('dropdownParent') || $(document.body);
	
	    decorated.call(this, $element, options);
	  }
	
	  AttachBody.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    var setupResultsEvents = false;
	
	    decorated.call(this, container, $container);
	
	    container.on('open', function () {
	      self._showDropdown();
	      self._attachPositioningHandler(container);
	
	      if (!setupResultsEvents) {
	        setupResultsEvents = true;
	
	        container.on('results:all', function () {
	          self._positionDropdown();
	          self._resizeDropdown();
	        });
	
	        container.on('results:append', function () {
	          self._positionDropdown();
	          self._resizeDropdown();
	        });
	      }
	    });
	
	    container.on('close', function () {
	      self._hideDropdown();
	      self._detachPositioningHandler(container);
	    });
	
	    this.$dropdownContainer.on('mousedown', function (evt) {
	      evt.stopPropagation();
	    });
	  };
	
	  AttachBody.prototype.destroy = function (decorated) {
	    decorated.call(this);
	
	    this.$dropdownContainer.remove();
	  };
	
	  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
	    // Clone all of the container classes
	    $dropdown.attr('class', $container.attr('class'));
	
	    $dropdown.removeClass('select2');
	    $dropdown.addClass('select2-container--open');
	
	    $dropdown.css({
	      position: 'absolute',
	      top: -999999
	    });
	
	    this.$container = $container;
	  };
	
	  AttachBody.prototype.render = function (decorated) {
	    var $container = $('<span></span>');
	
	    var $dropdown = decorated.call(this);
	    $container.append($dropdown);
	
	    this.$dropdownContainer = $container;
	
	    return $container;
	  };
	
	  AttachBody.prototype._hideDropdown = function (decorated) {
	    this.$dropdownContainer.detach();
	  };
	
	  AttachBody.prototype._attachPositioningHandler =
	      function (decorated, container) {
	    var self = this;
	
	    var scrollEvent = 'scroll.select2.' + container.id;
	    var resizeEvent = 'resize.select2.' + container.id;
	    var orientationEvent = 'orientationchange.select2.' + container.id;
	
	    var $watchers = this.$container.parents().filter(Utils.hasScroll);
	    $watchers.each(function () {
	      $(this).data('select2-scroll-position', {
	        x: $(this).scrollLeft(),
	        y: $(this).scrollTop()
	      });
	    });
	
	    $watchers.on(scrollEvent, function (ev) {
	      var position = $(this).data('select2-scroll-position');
	      $(this).scrollTop(position.y);
	    });
	
	    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
	      function (e) {
	      self._positionDropdown();
	      self._resizeDropdown();
	    });
	  };
	
	  AttachBody.prototype._detachPositioningHandler =
	      function (decorated, container) {
	    var scrollEvent = 'scroll.select2.' + container.id;
	    var resizeEvent = 'resize.select2.' + container.id;
	    var orientationEvent = 'orientationchange.select2.' + container.id;
	
	    var $watchers = this.$container.parents().filter(Utils.hasScroll);
	    $watchers.off(scrollEvent);
	
	    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
	  };
	
	  AttachBody.prototype._positionDropdown = function () {
	    var $window = $(window);
	
	    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
	    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');
	
	    var newDirection = null;
	
	    var offset = this.$container.offset();
	
	    offset.bottom = offset.top + this.$container.outerHeight(false);
	
	    var container = {
	      height: this.$container.outerHeight(false)
	    };
	
	    container.top = offset.top;
	    container.bottom = offset.top + container.height;
	
	    var dropdown = {
	      height: this.$dropdown.outerHeight(false)
	    };
	
	    var viewport = {
	      top: $window.scrollTop(),
	      bottom: $window.scrollTop() + $window.height()
	    };
	
	    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
	    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);
	
	    var css = {
	      left: offset.left,
	      top: container.bottom
	    };
	
	    // Determine what the parent element is to use for calciulating the offset
	    var $offsetParent = this.$dropdownParent;
	
	    // For statically positoned elements, we need to get the element
	    // that is determining the offset
	    if ($offsetParent.css('position') === 'static') {
	      $offsetParent = $offsetParent.offsetParent();
	    }
	
	    var parentOffset = $offsetParent.offset();
	
	    css.top -= parentOffset.top;
	    css.left -= parentOffset.left;
	
	    if (!isCurrentlyAbove && !isCurrentlyBelow) {
	      newDirection = 'below';
	    }
	
	    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
	      newDirection = 'above';
	    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
	      newDirection = 'below';
	    }
	
	    if (newDirection == 'above' ||
	      (isCurrentlyAbove && newDirection !== 'below')) {
	      css.top = container.top - parentOffset.top - dropdown.height;
	    }
	
	    if (newDirection != null) {
	      this.$dropdown
	        .removeClass('select2-dropdown--below select2-dropdown--above')
	        .addClass('select2-dropdown--' + newDirection);
	      this.$container
	        .removeClass('select2-container--below select2-container--above')
	        .addClass('select2-container--' + newDirection);
	    }
	
	    this.$dropdownContainer.css(css);
	  };
	
	  AttachBody.prototype._resizeDropdown = function () {
	    var css = {
	      width: this.$container.outerWidth(false) + 'px'
	    };
	
	    if (this.options.get('dropdownAutoWidth')) {
	      css.minWidth = css.width;
	      css.position = 'relative';
	      css.width = 'auto';
	    }
	
	    this.$dropdown.css(css);
	  };
	
	  AttachBody.prototype._showDropdown = function (decorated) {
	    this.$dropdownContainer.appendTo(this.$dropdownParent);
	
	    this._positionDropdown();
	    this._resizeDropdown();
	  };
	
	  return AttachBody;
	});
	
	S2.define('select2/dropdown/minimumResultsForSearch',[
	
	], function () {
	  function countResults (data) {
	    var count = 0;
	
	    for (var d = 0; d < data.length; d++) {
	      var item = data[d];
	
	      if (item.children) {
	        count += countResults(item.children);
	      } else {
	        count++;
	      }
	    }
	
	    return count;
	  }
	
	  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
	    this.minimumResultsForSearch = options.get('minimumResultsForSearch');
	
	    if (this.minimumResultsForSearch < 0) {
	      this.minimumResultsForSearch = Infinity;
	    }
	
	    decorated.call(this, $element, options, dataAdapter);
	  }
	
	  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
	    if (countResults(params.data.results) < this.minimumResultsForSearch) {
	      return false;
	    }
	
	    return decorated.call(this, params);
	  };
	
	  return MinimumResultsForSearch;
	});
	
	S2.define('select2/dropdown/selectOnClose',[
	
	], function () {
	  function SelectOnClose () { }
	
	  SelectOnClose.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    container.on('close', function (params) {
	      self._handleSelectOnClose(params);
	    });
	  };
	
	  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
	    if (params && params.originalSelect2Event != null) {
	      var event = params.originalSelect2Event;
	
	      // Don't select an item if the close event was triggered from a select or
	      // unselect event
	      if (event._type === 'select' || event._type === 'unselect') {
	        return;
	      }
	    }
	
	    var $highlightedResults = this.getHighlightedResults();
	
	    // Only select highlighted results
	    if ($highlightedResults.length < 1) {
	      return;
	    }
	
	    var data = $highlightedResults.data('data');
	
	    // Don't re-select already selected resulte
	    if (
	      (data.element != null && data.element.selected) ||
	      (data.element == null && data.selected)
	    ) {
	      return;
	    }
	
	    this.trigger('select', {
	        data: data
	    });
	  };
	
	  return SelectOnClose;
	});
	
	S2.define('select2/dropdown/closeOnSelect',[
	
	], function () {
	  function CloseOnSelect () { }
	
	  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	
	    decorated.call(this, container, $container);
	
	    container.on('select', function (evt) {
	      self._selectTriggered(evt);
	    });
	
	    container.on('unselect', function (evt) {
	      self._selectTriggered(evt);
	    });
	  };
	
	  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
	    var originalEvent = evt.originalEvent;
	
	    // Don't close if the control key is being held
	    if (originalEvent && originalEvent.ctrlKey) {
	      return;
	    }
	
	    this.trigger('close', {
	      originalEvent: originalEvent,
	      originalSelect2Event: evt
	    });
	  };
	
	  return CloseOnSelect;
	});
	
	S2.define('select2/i18n/en',[],function () {
	  // English
	  return {
	    errorLoading: function () {
	      return 'The results could not be loaded.';
	    },
	    inputTooLong: function (args) {
	      var overChars = args.input.length - args.maximum;
	
	      var message = 'Please delete ' + overChars + ' character';
	
	      if (overChars != 1) {
	        message += 's';
	      }
	
	      return message;
	    },
	    inputTooShort: function (args) {
	      var remainingChars = args.minimum - args.input.length;
	
	      var message = 'Please enter ' + remainingChars + ' or more characters';
	
	      return message;
	    },
	    loadingMore: function () {
	      return 'Loading more results…';
	    },
	    maximumSelected: function (args) {
	      var message = 'You can only select ' + args.maximum + ' item';
	
	      if (args.maximum != 1) {
	        message += 's';
	      }
	
	      return message;
	    },
	    noResults: function () {
	      return 'No results found';
	    },
	    searching: function () {
	      return 'Searching…';
	    }
	  };
	});
	
	S2.define('select2/defaults',[
	  'jquery',
	  'require',
	
	  './results',
	
	  './selection/single',
	  './selection/multiple',
	  './selection/placeholder',
	  './selection/allowClear',
	  './selection/search',
	  './selection/eventRelay',
	
	  './utils',
	  './translation',
	  './diacritics',
	
	  './data/select',
	  './data/array',
	  './data/ajax',
	  './data/tags',
	  './data/tokenizer',
	  './data/minimumInputLength',
	  './data/maximumInputLength',
	  './data/maximumSelectionLength',
	
	  './dropdown',
	  './dropdown/search',
	  './dropdown/hidePlaceholder',
	  './dropdown/infiniteScroll',
	  './dropdown/attachBody',
	  './dropdown/minimumResultsForSearch',
	  './dropdown/selectOnClose',
	  './dropdown/closeOnSelect',
	
	  './i18n/en'
	], function ($, require,
	
	             ResultsList,
	
	             SingleSelection, MultipleSelection, Placeholder, AllowClear,
	             SelectionSearch, EventRelay,
	
	             Utils, Translation, DIACRITICS,
	
	             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
	             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,
	
	             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
	             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,
	
	             EnglishTranslation) {
	  function Defaults () {
	    this.reset();
	  }
	
	  Defaults.prototype.apply = function (options) {
	    options = $.extend(true, {}, this.defaults, options);
	
	    if (options.dataAdapter == null) {
	      if (options.ajax != null) {
	        options.dataAdapter = AjaxData;
	      } else if (options.data != null) {
	        options.dataAdapter = ArrayData;
	      } else {
	        options.dataAdapter = SelectData;
	      }
	
	      if (options.minimumInputLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MinimumInputLength
	        );
	      }
	
	      if (options.maximumInputLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MaximumInputLength
	        );
	      }
	
	      if (options.maximumSelectionLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MaximumSelectionLength
	        );
	      }
	
	      if (options.tags) {
	        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
	      }
	
	      if (options.tokenSeparators != null || options.tokenizer != null) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          Tokenizer
	        );
	      }
	
	      if (options.query != null) {
	        var Query = require(options.amdBase + 'compat/query');
	
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          Query
	        );
	      }
	
	      if (options.initSelection != null) {
	        var InitSelection = require(options.amdBase + 'compat/initSelection');
	
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          InitSelection
	        );
	      }
	    }
	
	    if (options.resultsAdapter == null) {
	      options.resultsAdapter = ResultsList;
	
	      if (options.ajax != null) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          InfiniteScroll
	        );
	      }
	
	      if (options.placeholder != null) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          HidePlaceholder
	        );
	      }
	
	      if (options.selectOnClose) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          SelectOnClose
	        );
	      }
	    }
	
	    if (options.dropdownAdapter == null) {
	      if (options.multiple) {
	        options.dropdownAdapter = Dropdown;
	      } else {
	        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
	
	        options.dropdownAdapter = SearchableDropdown;
	      }
	
	      if (options.minimumResultsForSearch !== 0) {
	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          MinimumResultsForSearch
	        );
	      }
	
	      if (options.closeOnSelect) {
	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          CloseOnSelect
	        );
	      }
	
	      if (
	        options.dropdownCssClass != null ||
	        options.dropdownCss != null ||
	        options.adaptDropdownCssClass != null
	      ) {
	        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');
	
	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          DropdownCSS
	        );
	      }
	
	      options.dropdownAdapter = Utils.Decorate(
	        options.dropdownAdapter,
	        AttachBody
	      );
	    }
	
	    if (options.selectionAdapter == null) {
	      if (options.multiple) {
	        options.selectionAdapter = MultipleSelection;
	      } else {
	        options.selectionAdapter = SingleSelection;
	      }
	
	      // Add the placeholder mixin if a placeholder was specified
	      if (options.placeholder != null) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          Placeholder
	        );
	      }
	
	      if (options.allowClear) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          AllowClear
	        );
	      }
	
	      if (options.multiple) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          SelectionSearch
	        );
	      }
	
	      if (
	        options.containerCssClass != null ||
	        options.containerCss != null ||
	        options.adaptContainerCssClass != null
	      ) {
	        var ContainerCSS = require(options.amdBase + 'compat/containerCss');
	
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          ContainerCSS
	        );
	      }
	
	      options.selectionAdapter = Utils.Decorate(
	        options.selectionAdapter,
	        EventRelay
	      );
	    }
	
	    if (typeof options.language === 'string') {
	      // Check if the language is specified with a region
	      if (options.language.indexOf('-') > 0) {
	        // Extract the region information if it is included
	        var languageParts = options.language.split('-');
	        var baseLanguage = languageParts[0];
	
	        options.language = [options.language, baseLanguage];
	      } else {
	        options.language = [options.language];
	      }
	    }
	
	    if ($.isArray(options.language)) {
	      var languages = new Translation();
	      options.language.push('en');
	
	      var languageNames = options.language;
	
	      for (var l = 0; l < languageNames.length; l++) {
	        var name = languageNames[l];
	        var language = {};
	
	        try {
	          // Try to load it with the original name
	          language = Translation.loadPath(name);
	        } catch (e) {
	          try {
	            // If we couldn't load it, check if it wasn't the full path
	            name = this.defaults.amdLanguageBase + name;
	            language = Translation.loadPath(name);
	          } catch (ex) {
	            // The translation could not be loaded at all. Sometimes this is
	            // because of a configuration problem, other times this can be
	            // because of how Select2 helps load all possible translation files.
	            if (options.debug && window.console && console.warn) {
	              console.warn(
	                'Select2: The language file for "' + name + '" could not be ' +
	                'automatically loaded. A fallback will be used instead.'
	              );
	            }
	
	            continue;
	          }
	        }
	
	        languages.extend(language);
	      }
	
	      options.translations = languages;
	    } else {
	      var baseTranslation = Translation.loadPath(
	        this.defaults.amdLanguageBase + 'en'
	      );
	      var customTranslation = new Translation(options.language);
	
	      customTranslation.extend(baseTranslation);
	
	      options.translations = customTranslation;
	    }
	
	    return options;
	  };
	
	  Defaults.prototype.reset = function () {
	    function stripDiacritics (text) {
	      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
	      function match(a) {
	        return DIACRITICS[a] || a;
	      }
	
	      return text.replace(/[^\u0000-\u007E]/g, match);
	    }
	
	    function matcher (params, data) {
	      // Always return the object if there is nothing to compare
	      if ($.trim(params.term) === '') {
	        return data;
	      }
	
	      // Do a recursive check for options with children
	      if (data.children && data.children.length > 0) {
	        // Clone the data object if there are children
	        // This is required as we modify the object to remove any non-matches
	        var match = $.extend(true, {}, data);
	
	        // Check each child of the option
	        for (var c = data.children.length - 1; c >= 0; c--) {
	          var child = data.children[c];
	
	          var matches = matcher(params, child);
	
	          // If there wasn't a match, remove the object in the array
	          if (matches == null) {
	            match.children.splice(c, 1);
	          }
	        }
	
	        // If any children matched, return the new object
	        if (match.children.length > 0) {
	          return match;
	        }
	
	        // If there were no matching children, check just the plain object
	        return matcher(params, match);
	      }
	
	      var original = stripDiacritics(data.text).toUpperCase();
	      var term = stripDiacritics(params.term).toUpperCase();
	
	      // Check if the text contains the term
	      if (original.indexOf(term) > -1) {
	        return data;
	      }
	
	      // If it doesn't contain the term, don't return anything
	      return null;
	    }
	
	    this.defaults = {
	      amdBase: './',
	      amdLanguageBase: './i18n/',
	      closeOnSelect: true,
	      debug: false,
	      dropdownAutoWidth: false,
	      escapeMarkup: Utils.escapeMarkup,
	      language: EnglishTranslation,
	      matcher: matcher,
	      minimumInputLength: 0,
	      maximumInputLength: 0,
	      maximumSelectionLength: 0,
	      minimumResultsForSearch: 0,
	      selectOnClose: false,
	      sorter: function (data) {
	        return data;
	      },
	      templateResult: function (result) {
	        return result.text;
	      },
	      templateSelection: function (selection) {
	        return selection.text;
	      },
	      theme: 'default',
	      width: 'resolve'
	    };
	  };
	
	  Defaults.prototype.set = function (key, value) {
	    var camelKey = $.camelCase(key);
	
	    var data = {};
	    data[camelKey] = value;
	
	    var convertedData = Utils._convertData(data);
	
	    $.extend(this.defaults, convertedData);
	  };
	
	  var defaults = new Defaults();
	
	  return defaults;
	});
	
	S2.define('select2/options',[
	  'require',
	  'jquery',
	  './defaults',
	  './utils'
	], function (require, $, Defaults, Utils) {
	  function Options (options, $element) {
	    this.options = options;
	
	    if ($element != null) {
	      this.fromElement($element);
	    }
	
	    this.options = Defaults.apply(this.options);
	
	    if ($element && $element.is('input')) {
	      var InputCompat = require(this.get('amdBase') + 'compat/inputData');
	
	      this.options.dataAdapter = Utils.Decorate(
	        this.options.dataAdapter,
	        InputCompat
	      );
	    }
	  }
	
	  Options.prototype.fromElement = function ($e) {
	    var excludedData = ['select2'];
	
	    if (this.options.multiple == null) {
	      this.options.multiple = $e.prop('multiple');
	    }
	
	    if (this.options.disabled == null) {
	      this.options.disabled = $e.prop('disabled');
	    }
	
	    if (this.options.language == null) {
	      if ($e.prop('lang')) {
	        this.options.language = $e.prop('lang').toLowerCase();
	      } else if ($e.closest('[lang]').prop('lang')) {
	        this.options.language = $e.closest('[lang]').prop('lang');
	      }
	    }
	
	    if (this.options.dir == null) {
	      if ($e.prop('dir')) {
	        this.options.dir = $e.prop('dir');
	      } else if ($e.closest('[dir]').prop('dir')) {
	        this.options.dir = $e.closest('[dir]').prop('dir');
	      } else {
	        this.options.dir = 'ltr';
	      }
	    }
	
	    $e.prop('disabled', this.options.disabled);
	    $e.prop('multiple', this.options.multiple);
	
	    if ($e.data('select2Tags')) {
	      if (this.options.debug && window.console && console.warn) {
	        console.warn(
	          'Select2: The `data-select2-tags` attribute has been changed to ' +
	          'use the `data-data` and `data-tags="true"` attributes and will be ' +
	          'removed in future versions of Select2.'
	        );
	      }
	
	      $e.data('data', $e.data('select2Tags'));
	      $e.data('tags', true);
	    }
	
	    if ($e.data('ajaxUrl')) {
	      if (this.options.debug && window.console && console.warn) {
	        console.warn(
	          'Select2: The `data-ajax-url` attribute has been changed to ' +
	          '`data-ajax--url` and support for the old attribute will be removed' +
	          ' in future versions of Select2.'
	        );
	      }
	
	      $e.attr('ajax--url', $e.data('ajaxUrl'));
	      $e.data('ajax--url', $e.data('ajaxUrl'));
	    }
	
	    var dataset = {};
	
	    // Prefer the element's `dataset` attribute if it exists
	    // jQuery 1.x does not correctly handle data attributes with multiple dashes
	    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
	      dataset = $.extend(true, {}, $e[0].dataset, $e.data());
	    } else {
	      dataset = $e.data();
	    }
	
	    var data = $.extend(true, {}, dataset);
	
	    data = Utils._convertData(data);
	
	    for (var key in data) {
	      if ($.inArray(key, excludedData) > -1) {
	        continue;
	      }
	
	      if ($.isPlainObject(this.options[key])) {
	        $.extend(this.options[key], data[key]);
	      } else {
	        this.options[key] = data[key];
	      }
	    }
	
	    return this;
	  };
	
	  Options.prototype.get = function (key) {
	    return this.options[key];
	  };
	
	  Options.prototype.set = function (key, val) {
	    this.options[key] = val;
	  };
	
	  return Options;
	});
	
	S2.define('select2/core',[
	  'jquery',
	  './options',
	  './utils',
	  './keys'
	], function ($, Options, Utils, KEYS) {
	  var Select2 = function ($element, options) {
	    if ($element.data('select2') != null) {
	      $element.data('select2').destroy();
	    }
	
	    this.$element = $element;
	
	    this.id = this._generateId($element);
	
	    options = options || {};
	
	    this.options = new Options(options, $element);
	
	    Select2.__super__.constructor.call(this);
	
	    // Set up the tabindex
	
	    var tabindex = $element.attr('tabindex') || 0;
	    $element.data('old-tabindex', tabindex);
	    $element.attr('tabindex', '-1');
	
	    // Set up containers and adapters
	
	    var DataAdapter = this.options.get('dataAdapter');
	    this.dataAdapter = new DataAdapter($element, this.options);
	
	    var $container = this.render();
	
	    this._placeContainer($container);
	
	    var SelectionAdapter = this.options.get('selectionAdapter');
	    this.selection = new SelectionAdapter($element, this.options);
	    this.$selection = this.selection.render();
	
	    this.selection.position(this.$selection, $container);
	
	    var DropdownAdapter = this.options.get('dropdownAdapter');
	    this.dropdown = new DropdownAdapter($element, this.options);
	    this.$dropdown = this.dropdown.render();
	
	    this.dropdown.position(this.$dropdown, $container);
	
	    var ResultsAdapter = this.options.get('resultsAdapter');
	    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
	    this.$results = this.results.render();
	
	    this.results.position(this.$results, this.$dropdown);
	
	    // Bind events
	
	    var self = this;
	
	    // Bind the container to all of the adapters
	    this._bindAdapters();
	
	    // Register any DOM event handlers
	    this._registerDomEvents();
	
	    // Register any internal event handlers
	    this._registerDataEvents();
	    this._registerSelectionEvents();
	    this._registerDropdownEvents();
	    this._registerResultsEvents();
	    this._registerEvents();
	
	    // Set the initial state
	    this.dataAdapter.current(function (initialData) {
	      self.trigger('selection:update', {
	        data: initialData
	      });
	    });
	
	    // Hide the original select
	    $element.addClass('select2-hidden-accessible');
	    $element.attr('aria-hidden', 'true');
	
	    // Synchronize any monitored attributes
	    this._syncAttributes();
	
	    $element.data('select2', this);
	  };
	
	  Utils.Extend(Select2, Utils.Observable);
	
	  Select2.prototype._generateId = function ($element) {
	    var id = '';
	
	    if ($element.attr('id') != null) {
	      id = $element.attr('id');
	    } else if ($element.attr('name') != null) {
	      id = $element.attr('name') + '-' + Utils.generateChars(2);
	    } else {
	      id = Utils.generateChars(4);
	    }
	
	    id = id.replace(/(:|\.|\[|\]|,)/g, '');
	    id = 'select2-' + id;
	
	    return id;
	  };
	
	  Select2.prototype._placeContainer = function ($container) {
	    $container.insertAfter(this.$element);
	
	    var width = this._resolveWidth(this.$element, this.options.get('width'));
	
	    if (width != null) {
	      $container.css('width', width);
	    }
	  };
	
	  Select2.prototype._resolveWidth = function ($element, method) {
	    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
	
	    if (method == 'resolve') {
	      var styleWidth = this._resolveWidth($element, 'style');
	
	      if (styleWidth != null) {
	        return styleWidth;
	      }
	
	      return this._resolveWidth($element, 'element');
	    }
	
	    if (method == 'element') {
	      var elementWidth = $element.outerWidth(false);
	
	      if (elementWidth <= 0) {
	        return 'auto';
	      }
	
	      return elementWidth + 'px';
	    }
	
	    if (method == 'style') {
	      var style = $element.attr('style');
	
	      if (typeof(style) !== 'string') {
	        return null;
	      }
	
	      var attrs = style.split(';');
	
	      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
	        var attr = attrs[i].replace(/\s/g, '');
	        var matches = attr.match(WIDTH);
	
	        if (matches !== null && matches.length >= 1) {
	          return matches[1];
	        }
	      }
	
	      return null;
	    }
	
	    return method;
	  };
	
	  Select2.prototype._bindAdapters = function () {
	    this.dataAdapter.bind(this, this.$container);
	    this.selection.bind(this, this.$container);
	
	    this.dropdown.bind(this, this.$container);
	    this.results.bind(this, this.$container);
	  };
	
	  Select2.prototype._registerDomEvents = function () {
	    var self = this;
	
	    this.$element.on('change.select2', function () {
	      self.dataAdapter.current(function (data) {
	        self.trigger('selection:update', {
	          data: data
	        });
	      });
	    });
	
	    this.$element.on('focus.select2', function (evt) {
	      self.trigger('focus', evt);
	    });
	
	    this._syncA = Utils.bind(this._syncAttributes, this);
	    this._syncS = Utils.bind(this._syncSubtree, this);
	
	    if (this.$element[0].attachEvent) {
	      this.$element[0].attachEvent('onpropertychange', this._syncA);
	    }
	
	    var observer = window.MutationObserver ||
	      window.WebKitMutationObserver ||
	      window.MozMutationObserver
	    ;
	
	    if (observer != null) {
	      this._observer = new observer(function (mutations) {
	        $.each(mutations, self._syncA);
	        $.each(mutations, self._syncS);
	      });
	      this._observer.observe(this.$element[0], {
	        attributes: true,
	        childList: true,
	        subtree: false
	      });
	    } else if (this.$element[0].addEventListener) {
	      this.$element[0].addEventListener(
	        'DOMAttrModified',
	        self._syncA,
	        false
	      );
	      this.$element[0].addEventListener(
	        'DOMNodeInserted',
	        self._syncS,
	        false
	      );
	      this.$element[0].addEventListener(
	        'DOMNodeRemoved',
	        self._syncS,
	        false
	      );
	    }
	  };
	
	  Select2.prototype._registerDataEvents = function () {
	    var self = this;
	
	    this.dataAdapter.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };
	
	  Select2.prototype._registerSelectionEvents = function () {
	    var self = this;
	    var nonRelayEvents = ['toggle', 'focus'];
	
	    this.selection.on('toggle', function () {
	      self.toggleDropdown();
	    });
	
	    this.selection.on('focus', function (params) {
	      self.focus(params);
	    });
	
	    this.selection.on('*', function (name, params) {
	      if ($.inArray(name, nonRelayEvents) !== -1) {
	        return;
	      }
	
	      self.trigger(name, params);
	    });
	  };
	
	  Select2.prototype._registerDropdownEvents = function () {
	    var self = this;
	
	    this.dropdown.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };
	
	  Select2.prototype._registerResultsEvents = function () {
	    var self = this;
	
	    this.results.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };
	
	  Select2.prototype._registerEvents = function () {
	    var self = this;
	
	    this.on('open', function () {
	      self.$container.addClass('select2-container--open');
	    });
	
	    this.on('close', function () {
	      self.$container.removeClass('select2-container--open');
	    });
	
	    this.on('enable', function () {
	      self.$container.removeClass('select2-container--disabled');
	    });
	
	    this.on('disable', function () {
	      self.$container.addClass('select2-container--disabled');
	    });
	
	    this.on('blur', function () {
	      self.$container.removeClass('select2-container--focus');
	    });
	
	    this.on('query', function (params) {
	      if (!self.isOpen()) {
	        self.trigger('open', {});
	      }
	
	      this.dataAdapter.query(params, function (data) {
	        self.trigger('results:all', {
	          data: data,
	          query: params
	        });
	      });
	    });
	
	    this.on('query:append', function (params) {
	      this.dataAdapter.query(params, function (data) {
	        self.trigger('results:append', {
	          data: data,
	          query: params
	        });
	      });
	    });
	
	    this.on('keypress', function (evt) {
	      var key = evt.which;
	
	      if (self.isOpen()) {
	        if (key === KEYS.ESC || key === KEYS.TAB ||
	            (key === KEYS.UP && evt.altKey)) {
	          self.close();
	
	          evt.preventDefault();
	        } else if (key === KEYS.ENTER) {
	          self.trigger('results:select', {});
	
	          evt.preventDefault();
	        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
	          self.trigger('results:toggle', {});
	
	          evt.preventDefault();
	        } else if (key === KEYS.UP) {
	          self.trigger('results:previous', {});
	
	          evt.preventDefault();
	        } else if (key === KEYS.DOWN) {
	          self.trigger('results:next', {});
	
	          evt.preventDefault();
	        }
	      } else {
	        if (key === KEYS.ENTER || key === KEYS.SPACE ||
	            (key === KEYS.DOWN && evt.altKey)) {
	          self.open();
	
	          evt.preventDefault();
	        }
	      }
	    });
	  };
	
	  Select2.prototype._syncAttributes = function () {
	    this.options.set('disabled', this.$element.prop('disabled'));
	
	    if (this.options.get('disabled')) {
	      if (this.isOpen()) {
	        this.close();
	      }
	
	      this.trigger('disable', {});
	    } else {
	      this.trigger('enable', {});
	    }
	  };
	
	  Select2.prototype._syncSubtree = function (evt, mutations) {
	    var changed = false;
	    var self = this;
	
	    // Ignore any mutation events raised for elements that aren't options or
	    // optgroups. This handles the case when the select element is destroyed
	    if (
	      evt && evt.target && (
	        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
	      )
	    ) {
	      return;
	    }
	
	    if (!mutations) {
	      // If mutation events aren't supported, then we can only assume that the
	      // change affected the selections
	      changed = true;
	    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
	      for (var n = 0; n < mutations.addedNodes.length; n++) {
	        var node = mutations.addedNodes[n];
	
	        if (node.selected) {
	          changed = true;
	        }
	      }
	    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
	      changed = true;
	    }
	
	    // Only re-pull the data if we think there is a change
	    if (changed) {
	      this.dataAdapter.current(function (currentData) {
	        self.trigger('selection:update', {
	          data: currentData
	        });
	      });
	    }
	  };
	
	  /**
	   * Override the trigger method to automatically trigger pre-events when
	   * there are events that can be prevented.
	   */
	  Select2.prototype.trigger = function (name, args) {
	    var actualTrigger = Select2.__super__.trigger;
	    var preTriggerMap = {
	      'open': 'opening',
	      'close': 'closing',
	      'select': 'selecting',
	      'unselect': 'unselecting'
	    };
	
	    if (args === undefined) {
	      args = {};
	    }
	
	    if (name in preTriggerMap) {
	      var preTriggerName = preTriggerMap[name];
	      var preTriggerArgs = {
	        prevented: false,
	        name: name,
	        args: args
	      };
	
	      actualTrigger.call(this, preTriggerName, preTriggerArgs);
	
	      if (preTriggerArgs.prevented) {
	        args.prevented = true;
	
	        return;
	      }
	    }
	
	    actualTrigger.call(this, name, args);
	  };
	
	  Select2.prototype.toggleDropdown = function () {
	    if (this.options.get('disabled')) {
	      return;
	    }
	
	    if (this.isOpen()) {
	      this.close();
	    } else {
	      this.open();
	    }
	  };
	
	  Select2.prototype.open = function () {
	    if (this.isOpen()) {
	      return;
	    }
	
	    this.trigger('query', {});
	  };
	
	  Select2.prototype.close = function () {
	    if (!this.isOpen()) {
	      return;
	    }
	
	    this.trigger('close', {});
	  };
	
	  Select2.prototype.isOpen = function () {
	    return this.$container.hasClass('select2-container--open');
	  };
	
	  Select2.prototype.hasFocus = function () {
	    return this.$container.hasClass('select2-container--focus');
	  };
	
	  Select2.prototype.focus = function (data) {
	    // No need to re-trigger focus events if we are already focused
	    if (this.hasFocus()) {
	      return;
	    }
	
	    this.$container.addClass('select2-container--focus');
	    this.trigger('focus', {});
	  };
	
	  Select2.prototype.enable = function (args) {
	    if (this.options.get('debug') && window.console && console.warn) {
	      console.warn(
	        'Select2: The `select2("enable")` method has been deprecated and will' +
	        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
	        ' instead.'
	      );
	    }
	
	    if (args == null || args.length === 0) {
	      args = [true];
	    }
	
	    var disabled = !args[0];
	
	    this.$element.prop('disabled', disabled);
	  };
	
	  Select2.prototype.data = function () {
	    if (this.options.get('debug') &&
	        arguments.length > 0 && window.console && console.warn) {
	      console.warn(
	        'Select2: Data can no longer be set using `select2("data")`. You ' +
	        'should consider setting the value instead using `$element.val()`.'
	      );
	    }
	
	    var data = [];
	
	    this.dataAdapter.current(function (currentData) {
	      data = currentData;
	    });
	
	    return data;
	  };
	
	  Select2.prototype.val = function (args) {
	    if (this.options.get('debug') && window.console && console.warn) {
	      console.warn(
	        'Select2: The `select2("val")` method has been deprecated and will be' +
	        ' removed in later Select2 versions. Use $element.val() instead.'
	      );
	    }
	
	    if (args == null || args.length === 0) {
	      return this.$element.val();
	    }
	
	    var newVal = args[0];
	
	    if ($.isArray(newVal)) {
	      newVal = $.map(newVal, function (obj) {
	        return obj.toString();
	      });
	    }
	
	    this.$element.val(newVal).trigger('change');
	  };
	
	  Select2.prototype.destroy = function () {
	    this.$container.remove();
	
	    if (this.$element[0].detachEvent) {
	      this.$element[0].detachEvent('onpropertychange', this._syncA);
	    }
	
	    if (this._observer != null) {
	      this._observer.disconnect();
	      this._observer = null;
	    } else if (this.$element[0].removeEventListener) {
	      this.$element[0]
	        .removeEventListener('DOMAttrModified', this._syncA, false);
	      this.$element[0]
	        .removeEventListener('DOMNodeInserted', this._syncS, false);
	      this.$element[0]
	        .removeEventListener('DOMNodeRemoved', this._syncS, false);
	    }
	
	    this._syncA = null;
	    this._syncS = null;
	
	    this.$element.off('.select2');
	    this.$element.attr('tabindex', this.$element.data('old-tabindex'));
	
	    this.$element.removeClass('select2-hidden-accessible');
	    this.$element.attr('aria-hidden', 'false');
	    this.$element.removeData('select2');
	
	    this.dataAdapter.destroy();
	    this.selection.destroy();
	    this.dropdown.destroy();
	    this.results.destroy();
	
	    this.dataAdapter = null;
	    this.selection = null;
	    this.dropdown = null;
	    this.results = null;
	  };
	
	  Select2.prototype.render = function () {
	    var $container = $(
	      '<span class="select2 select2-container">' +
	        '<span class="selection"></span>' +
	        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
	      '</span>'
	    );
	
	    $container.attr('dir', this.options.get('dir'));
	
	    this.$container = $container;
	
	    this.$container.addClass('select2-container--' + this.options.get('theme'));
	
	    $container.data('element', this.$element);
	
	    return $container;
	  };
	
	  return Select2;
	});
	
	S2.define('jquery-mousewheel',[
	  'jquery'
	], function ($) {
	  // Used to shim jQuery.mousewheel for non-full builds.
	  return $;
	});
	
	S2.define('jquery.select2',[
	  'jquery',
	  'jquery-mousewheel',
	
	  './select2/core',
	  './select2/defaults'
	], function ($, _, Select2, Defaults) {
	  if ($.fn.select2 == null) {
	    // All methods that should return the element
	    var thisMethods = ['open', 'close', 'destroy'];
	
	    $.fn.select2 = function (options) {
	      options = options || {};
	
	      if (typeof options === 'object') {
	        this.each(function () {
	          var instanceOptions = $.extend(true, {}, options);
	
	          var instance = new Select2($(this), instanceOptions);
	        });
	
	        return this;
	      } else if (typeof options === 'string') {
	        var ret;
	        var args = Array.prototype.slice.call(arguments, 1);
	
	        this.each(function () {
	          var instance = $(this).data('select2');
	
	          if (instance == null && window.console && console.error) {
	            console.error(
	              'The select2(\'' + options + '\') method was called on an ' +
	              'element that is not using Select2.'
	            );
	          }
	
	          ret = instance[options].apply(instance, args);
	        });
	
	        // Check if we should be returning `this`
	        if ($.inArray(options, thisMethods) > -1) {
	          return this;
	        }
	
	        return ret;
	      } else {
	        throw new Error('Invalid arguments for Select2: ' + options);
	      }
	    };
	  }
	
	  if ($.fn.select2.defaults == null) {
	    $.fn.select2.defaults = Defaults;
	  }
	
	  return Select2;
	});
	
	  // Return the AMD loader configuration so it can be used outside of this file
	  return {
	    define: S2.define,
	    require: S2.require
	  };
	}());
	
	  // Autoload the jQuery bindings
	  // We know that all of the modules exist above this, so we're safe
	  var select2 = S2.require('jquery.select2');
	
	  // Hold the AMD module references on the jQuery function that was just loaded
	  // This allows Select2 to use the internal loader outside of this file, such
	  // as in the language files.
	  jQuery.fn.select2.amd = S2;
	
	  // Return the Select2 instance for anyone who is importing it.
	  return select2;
	}));


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * URI.js - Mutating URLs
	 *
	 * Version: 1.18.1
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	(function (root, factory) {
	  'use strict';
	  // https://github.com/umdjs/umd/blob/master/returnExports.js
	  if (true) {
	    // Node
	    module.exports = factory(__webpack_require__(480), __webpack_require__(481), __webpack_require__(482));
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD. Register as an anonymous module.
	    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
	  } else {
	    // Browser globals (root is window)
	    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
	  }
	}(this, function (punycode, IPv6, SLD, root) {
	  'use strict';
	  /*global location, escape, unescape */
	  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
	  /*jshint camelcase: false */
	
	  // save current URI variable, if any
	  var _URI = root && root.URI;
	
	  function URI(url, base) {
	    var _urlSupplied = arguments.length >= 1;
	    var _baseSupplied = arguments.length >= 2;
	
	    // Allow instantiation without the 'new' keyword
	    if (!(this instanceof URI)) {
	      if (_urlSupplied) {
	        if (_baseSupplied) {
	          return new URI(url, base);
	        }
	
	        return new URI(url);
	      }
	
	      return new URI();
	    }
	
	    if (url === undefined) {
	      if (_urlSupplied) {
	        throw new TypeError('undefined is not a valid argument for URI');
	      }
	
	      if (typeof location !== 'undefined') {
	        url = location.href + '';
	      } else {
	        url = '';
	      }
	    }
	
	    this.href(url);
	
	    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
	    if (base !== undefined) {
	      return this.absoluteTo(base);
	    }
	
	    return this;
	  }
	
	  URI.version = '1.18.1';
	
	  var p = URI.prototype;
	  var hasOwn = Object.prototype.hasOwnProperty;
	
	  function escapeRegEx(string) {
	    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
	    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	  }
	
	  function getType(value) {
	    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
	    if (value === undefined) {
	      return 'Undefined';
	    }
	
	    return String(Object.prototype.toString.call(value)).slice(8, -1);
	  }
	
	  function isArray(obj) {
	    return getType(obj) === 'Array';
	  }
	
	  function filterArrayValues(data, value) {
	    var lookup = {};
	    var i, length;
	
	    if (getType(value) === 'RegExp') {
	      lookup = null;
	    } else if (isArray(value)) {
	      for (i = 0, length = value.length; i < length; i++) {
	        lookup[value[i]] = true;
	      }
	    } else {
	      lookup[value] = true;
	    }
	
	    for (i = 0, length = data.length; i < length; i++) {
	      /*jshint laxbreak: true */
	      var _match = lookup && lookup[data[i]] !== undefined
	        || !lookup && value.test(data[i]);
	      /*jshint laxbreak: false */
	      if (_match) {
	        data.splice(i, 1);
	        length--;
	        i--;
	      }
	    }
	
	    return data;
	  }
	
	  function arrayContains(list, value) {
	    var i, length;
	
	    // value may be string, number, array, regexp
	    if (isArray(value)) {
	      // Note: this can be optimized to O(n) (instead of current O(m * n))
	      for (i = 0, length = value.length; i < length; i++) {
	        if (!arrayContains(list, value[i])) {
	          return false;
	        }
	      }
	
	      return true;
	    }
	
	    var _type = getType(value);
	    for (i = 0, length = list.length; i < length; i++) {
	      if (_type === 'RegExp') {
	        if (typeof list[i] === 'string' && list[i].match(value)) {
	          return true;
	        }
	      } else if (list[i] === value) {
	        return true;
	      }
	    }
	
	    return false;
	  }
	
	  function arraysEqual(one, two) {
	    if (!isArray(one) || !isArray(two)) {
	      return false;
	    }
	
	    // arrays can't be equal if they have different amount of content
	    if (one.length !== two.length) {
	      return false;
	    }
	
	    one.sort();
	    two.sort();
	
	    for (var i = 0, l = one.length; i < l; i++) {
	      if (one[i] !== two[i]) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  function trimSlashes(text) {
	    var trim_expression = /^\/+|\/+$/g;
	    return text.replace(trim_expression, '');
	  }
	
	  URI._parts = function() {
	    return {
	      protocol: null,
	      username: null,
	      password: null,
	      hostname: null,
	      urn: null,
	      port: null,
	      path: null,
	      query: null,
	      fragment: null,
	      // state
	      duplicateQueryParameters: URI.duplicateQueryParameters,
	      escapeQuerySpace: URI.escapeQuerySpace
	    };
	  };
	  // state: allow duplicate query parameters (a=1&a=1)
	  URI.duplicateQueryParameters = false;
	  // state: replaces + with %20 (space in query strings)
	  URI.escapeQuerySpace = true;
	  // static properties
	  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
	  URI.idn_expression = /[^a-z0-9\.-]/i;
	  URI.punycode_expression = /(xn--)/i;
	  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
	  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
	  // credits to Rich Brown
	  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
	  // specification: http://www.ietf.org/rfc/rfc4291.txt
	  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
	  // expression used is "gruber revised" (@gruber v2) determined to be the
	  // best solution in a regex-golf we did a couple of ages ago at
	  // * http://mathiasbynens.be/demo/url-regex
	  // * http://rodneyrehm.de/t/url-regex.html
	  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
	  URI.findUri = {
	    // valid "scheme://" or "www."
	    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
	    // everything up to the next whitespace
	    end: /[\s\r\n]|$/,
	    // trim trailing punctuation captured by end RegExp
	    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
	  };
	  // http://www.iana.org/assignments/uri-schemes.html
	  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
	  URI.defaultPorts = {
	    http: '80',
	    https: '443',
	    ftp: '21',
	    gopher: '70',
	    ws: '80',
	    wss: '443'
	  };
	  // allowed hostname characters according to RFC 3986
	  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
	  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
	  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
	  // map DOM Elements to their URI attribute
	  URI.domAttributes = {
	    'a': 'href',
	    'blockquote': 'cite',
	    'link': 'href',
	    'base': 'href',
	    'script': 'src',
	    'form': 'action',
	    'img': 'src',
	    'area': 'href',
	    'iframe': 'src',
	    'embed': 'src',
	    'source': 'src',
	    'track': 'src',
	    'input': 'src', // but only if type="image"
	    'audio': 'src',
	    'video': 'src'
	  };
	  URI.getDomAttribute = function(node) {
	    if (!node || !node.nodeName) {
	      return undefined;
	    }
	
	    var nodeName = node.nodeName.toLowerCase();
	    // <input> should only expose src for type="image"
	    if (nodeName === 'input' && node.type !== 'image') {
	      return undefined;
	    }
	
	    return URI.domAttributes[nodeName];
	  };
	
	  function escapeForDumbFirefox36(value) {
	    // https://github.com/medialize/URI.js/issues/91
	    return escape(value);
	  }
	
	  // encoding / decoding according to RFC3986
	  function strictEncodeURIComponent(string) {
	    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
	    return encodeURIComponent(string)
	      .replace(/[!'()*]/g, escapeForDumbFirefox36)
	      .replace(/\*/g, '%2A');
	  }
	  URI.encode = strictEncodeURIComponent;
	  URI.decode = decodeURIComponent;
	  URI.iso8859 = function() {
	    URI.encode = escape;
	    URI.decode = unescape;
	  };
	  URI.unicode = function() {
	    URI.encode = strictEncodeURIComponent;
	    URI.decode = decodeURIComponent;
	  };
	  URI.characters = {
	    pathname: {
	      encode: {
	        // RFC3986 2.1: For consistency, URI producers and normalizers should
	        // use uppercase hexadecimal digits for all percent-encodings.
	        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
	        map: {
	          // -._~!'()*
	          '%24': '$',
	          '%26': '&',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '=',
	          '%3A': ':',
	          '%40': '@'
	        }
	      },
	      decode: {
	        expression: /[\/\?#]/g,
	        map: {
	          '/': '%2F',
	          '?': '%3F',
	          '#': '%23'
	        }
	      }
	    },
	    reserved: {
	      encode: {
	        // RFC3986 2.1: For consistency, URI producers and normalizers should
	        // use uppercase hexadecimal digits for all percent-encodings.
	        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
	        map: {
	          // gen-delims
	          '%3A': ':',
	          '%2F': '/',
	          '%3F': '?',
	          '%23': '#',
	          '%5B': '[',
	          '%5D': ']',
	          '%40': '@',
	          // sub-delims
	          '%21': '!',
	          '%24': '$',
	          '%26': '&',
	          '%27': '\'',
	          '%28': '(',
	          '%29': ')',
	          '%2A': '*',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '='
	        }
	      }
	    },
	    urnpath: {
	      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
	      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
	      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
	      // note that the colon character is not featured in the encoding map; this is because URI.js
	      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
	      // should not appear unencoded in a segment itself.
	      // See also the note above about RFC3986 and capitalalized hex digits.
	      encode: {
	        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
	        map: {
	          '%21': '!',
	          '%24': '$',
	          '%27': '\'',
	          '%28': '(',
	          '%29': ')',
	          '%2A': '*',
	          '%2B': '+',
	          '%2C': ',',
	          '%3B': ';',
	          '%3D': '=',
	          '%40': '@'
	        }
	      },
	      // These characters are the characters called out by RFC2141 as "reserved" characters that
	      // should never appear in a URN, plus the colon character (see note above).
	      decode: {
	        expression: /[\/\?#:]/g,
	        map: {
	          '/': '%2F',
	          '?': '%3F',
	          '#': '%23',
	          ':': '%3A'
	        }
	      }
	    }
	  };
	  URI.encodeQuery = function(string, escapeQuerySpace) {
	    var escaped = URI.encode(string + '');
	    if (escapeQuerySpace === undefined) {
	      escapeQuerySpace = URI.escapeQuerySpace;
	    }
	
	    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
	  };
	  URI.decodeQuery = function(string, escapeQuerySpace) {
	    string += '';
	    if (escapeQuerySpace === undefined) {
	      escapeQuerySpace = URI.escapeQuerySpace;
	    }
	
	    try {
	      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
	    } catch(e) {
	      // we're not going to mess with weird encodings,
	      // give up and return the undecoded original string
	      // see https://github.com/medialize/URI.js/issues/87
	      // see https://github.com/medialize/URI.js/issues/92
	      return string;
	    }
	  };
	  // generate encode/decode path functions
	  var _parts = {'encode':'encode', 'decode':'decode'};
	  var _part;
	  var generateAccessor = function(_group, _part) {
	    return function(string) {
	      try {
	        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
	          return URI.characters[_group][_part].map[c];
	        });
	      } catch (e) {
	        // we're not going to mess with weird encodings,
	        // give up and return the undecoded original string
	        // see https://github.com/medialize/URI.js/issues/87
	        // see https://github.com/medialize/URI.js/issues/92
	        return string;
	      }
	    };
	  };
	
	  for (_part in _parts) {
	    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
	    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
	  }
	
	  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
	    return function(string) {
	      // Why pass in names of functions, rather than the function objects themselves? The
	      // definitions of some functions (but in particular, URI.decode) will occasionally change due
	      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
	      // that the functions we use here are "fresh".
	      var actualCodingFunc;
	      if (!_innerCodingFuncName) {
	        actualCodingFunc = URI[_codingFuncName];
	      } else {
	        actualCodingFunc = function(string) {
	          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
	        };
	      }
	
	      var segments = (string + '').split(_sep);
	
	      for (var i = 0, length = segments.length; i < length; i++) {
	        segments[i] = actualCodingFunc(segments[i]);
	      }
	
	      return segments.join(_sep);
	    };
	  };
	
	  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
	  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
	  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
	  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
	  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');
	
	  URI.encodeReserved = generateAccessor('reserved', 'encode');
	
	  URI.parse = function(string, parts) {
	    var pos;
	    if (!parts) {
	      parts = {};
	    }
	    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]
	
	    // extract fragment
	    pos = string.indexOf('#');
	    if (pos > -1) {
	      // escaping?
	      parts.fragment = string.substring(pos + 1) || null;
	      string = string.substring(0, pos);
	    }
	
	    // extract query
	    pos = string.indexOf('?');
	    if (pos > -1) {
	      // escaping?
	      parts.query = string.substring(pos + 1) || null;
	      string = string.substring(0, pos);
	    }
	
	    // extract protocol
	    if (string.substring(0, 2) === '//') {
	      // relative-scheme
	      parts.protocol = null;
	      string = string.substring(2);
	      // extract "user:pass@host:port"
	      string = URI.parseAuthority(string, parts);
	    } else {
	      pos = string.indexOf(':');
	      if (pos > -1) {
	        parts.protocol = string.substring(0, pos) || null;
	        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
	          // : may be within the path
	          parts.protocol = undefined;
	        } else if (string.substring(pos + 1, pos + 3) === '//') {
	          string = string.substring(pos + 3);
	
	          // extract "user:pass@host:port"
	          string = URI.parseAuthority(string, parts);
	        } else {
	          string = string.substring(pos + 1);
	          parts.urn = true;
	        }
	      }
	    }
	
	    // what's left must be the path
	    parts.path = string;
	
	    // and we're done
	    return parts;
	  };
	  URI.parseHost = function(string, parts) {
	    // Copy chrome, IE, opera backslash-handling behavior.
	    // Back slashes before the query string get converted to forward slashes
	    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
	    // See: https://code.google.com/p/chromium/issues/detail?id=25916
	    // https://github.com/medialize/URI.js/pull/233
	    string = string.replace(/\\/g, '/');
	
	    // extract host:port
	    var pos = string.indexOf('/');
	    var bracketPos;
	    var t;
	
	    if (pos === -1) {
	      pos = string.length;
	    }
	
	    if (string.charAt(0) === '[') {
	      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
	      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
	      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
	      bracketPos = string.indexOf(']');
	      parts.hostname = string.substring(1, bracketPos) || null;
	      parts.port = string.substring(bracketPos + 2, pos) || null;
	      if (parts.port === '/') {
	        parts.port = null;
	      }
	    } else {
	      var firstColon = string.indexOf(':');
	      var firstSlash = string.indexOf('/');
	      var nextColon = string.indexOf(':', firstColon + 1);
	      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
	        // IPv6 host contains multiple colons - but no port
	        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
	        parts.hostname = string.substring(0, pos) || null;
	        parts.port = null;
	      } else {
	        t = string.substring(0, pos).split(':');
	        parts.hostname = t[0] || null;
	        parts.port = t[1] || null;
	      }
	    }
	
	    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
	      pos++;
	      string = '/' + string;
	    }
	
	    return string.substring(pos) || '/';
	  };
	  URI.parseAuthority = function(string, parts) {
	    string = URI.parseUserinfo(string, parts);
	    return URI.parseHost(string, parts);
	  };
	  URI.parseUserinfo = function(string, parts) {
	    // extract username:password
	    var firstSlash = string.indexOf('/');
	    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
	    var t;
	
	    // authority@ must come before /path
	    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
	      t = string.substring(0, pos).split(':');
	      parts.username = t[0] ? URI.decode(t[0]) : null;
	      t.shift();
	      parts.password = t[0] ? URI.decode(t.join(':')) : null;
	      string = string.substring(pos + 1);
	    } else {
	      parts.username = null;
	      parts.password = null;
	    }
	
	    return string;
	  };
	  URI.parseQuery = function(string, escapeQuerySpace) {
	    if (!string) {
	      return {};
	    }
	
	    // throw out the funky business - "?"[name"="value"&"]+
	    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');
	
	    if (!string) {
	      return {};
	    }
	
	    var items = {};
	    var splits = string.split('&');
	    var length = splits.length;
	    var v, name, value;
	
	    for (var i = 0; i < length; i++) {
	      v = splits[i].split('=');
	      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
	      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
	      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;
	
	      if (hasOwn.call(items, name)) {
	        if (typeof items[name] === 'string' || items[name] === null) {
	          items[name] = [items[name]];
	        }
	
	        items[name].push(value);
	      } else {
	        items[name] = value;
	      }
	    }
	
	    return items;
	  };
	
	  URI.build = function(parts) {
	    var t = '';
	
	    if (parts.protocol) {
	      t += parts.protocol + ':';
	    }
	
	    if (!parts.urn && (t || parts.hostname)) {
	      t += '//';
	    }
	
	    t += (URI.buildAuthority(parts) || '');
	
	    if (typeof parts.path === 'string') {
	      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
	        t += '/';
	      }
	
	      t += parts.path;
	    }
	
	    if (typeof parts.query === 'string' && parts.query) {
	      t += '?' + parts.query;
	    }
	
	    if (typeof parts.fragment === 'string' && parts.fragment) {
	      t += '#' + parts.fragment;
	    }
	    return t;
	  };
	  URI.buildHost = function(parts) {
	    var t = '';
	
	    if (!parts.hostname) {
	      return '';
	    } else if (URI.ip6_expression.test(parts.hostname)) {
	      t += '[' + parts.hostname + ']';
	    } else {
	      t += parts.hostname;
	    }
	
	    if (parts.port) {
	      t += ':' + parts.port;
	    }
	
	    return t;
	  };
	  URI.buildAuthority = function(parts) {
	    return URI.buildUserinfo(parts) + URI.buildHost(parts);
	  };
	  URI.buildUserinfo = function(parts) {
	    var t = '';
	
	    if (parts.username) {
	      t += URI.encode(parts.username);
	    }
	
	    if (parts.password) {
	      t += ':' + URI.encode(parts.password);
	    }
	
	    if (t) {
	      t += '@';
	    }
	
	    return t;
	  };
	  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
	    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
	    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
	    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
	    // URI.js treats the query string as being application/x-www-form-urlencoded
	    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type
	
	    var t = '';
	    var unique, key, i, length;
	    for (key in data) {
	      if (hasOwn.call(data, key) && key) {
	        if (isArray(data[key])) {
	          unique = {};
	          for (i = 0, length = data[key].length; i < length; i++) {
	            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
	              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
	              if (duplicateQueryParameters !== true) {
	                unique[data[key][i] + ''] = true;
	              }
	            }
	          }
	        } else if (data[key] !== undefined) {
	          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
	        }
	      }
	    }
	
	    return t.substring(1);
	  };
	  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
	    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
	    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
	    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
	  };
	
	  URI.addQuery = function(data, name, value) {
	    if (typeof name === 'object') {
	      for (var key in name) {
	        if (hasOwn.call(name, key)) {
	          URI.addQuery(data, key, name[key]);
	        }
	      }
	    } else if (typeof name === 'string') {
	      if (data[name] === undefined) {
	        data[name] = value;
	        return;
	      } else if (typeof data[name] === 'string') {
	        data[name] = [data[name]];
	      }
	
	      if (!isArray(value)) {
	        value = [value];
	      }
	
	      data[name] = (data[name] || []).concat(value);
	    } else {
	      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
	    }
	  };
	  URI.removeQuery = function(data, name, value) {
	    var i, length, key;
	
	    if (isArray(name)) {
	      for (i = 0, length = name.length; i < length; i++) {
	        data[name[i]] = undefined;
	      }
	    } else if (getType(name) === 'RegExp') {
	      for (key in data) {
	        if (name.test(key)) {
	          data[key] = undefined;
	        }
	      }
	    } else if (typeof name === 'object') {
	      for (key in name) {
	        if (hasOwn.call(name, key)) {
	          URI.removeQuery(data, key, name[key]);
	        }
	      }
	    } else if (typeof name === 'string') {
	      if (value !== undefined) {
	        if (getType(value) === 'RegExp') {
	          if (!isArray(data[name]) && value.test(data[name])) {
	            data[name] = undefined;
	          } else {
	            data[name] = filterArrayValues(data[name], value);
	          }
	        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
	          data[name] = undefined;
	        } else if (isArray(data[name])) {
	          data[name] = filterArrayValues(data[name], value);
	        }
	      } else {
	        data[name] = undefined;
	      }
	    } else {
	      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
	    }
	  };
	  URI.hasQuery = function(data, name, value, withinArray) {
	    switch (getType(name)) {
	      case 'String':
	        // Nothing to do here
	        break;
	
	      case 'RegExp':
	        for (var key in data) {
	          if (hasOwn.call(data, key)) {
	            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
	              return true;
	            }
	          }
	        }
	
	        return false;
	
	      case 'Object':
	        for (var _key in name) {
	          if (hasOwn.call(name, _key)) {
	            if (!URI.hasQuery(data, _key, name[_key])) {
	              return false;
	            }
	          }
	        }
	
	        return true;
	
	      default:
	        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
	    }
	
	    switch (getType(value)) {
	      case 'Undefined':
	        // true if exists (but may be empty)
	        return name in data; // data[name] !== undefined;
	
	      case 'Boolean':
	        // true if exists and non-empty
	        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
	        return value === _booly;
	
	      case 'Function':
	        // allow complex comparison
	        return !!value(data[name], name, data);
	
	      case 'Array':
	        if (!isArray(data[name])) {
	          return false;
	        }
	
	        var op = withinArray ? arrayContains : arraysEqual;
	        return op(data[name], value);
	
	      case 'RegExp':
	        if (!isArray(data[name])) {
	          return Boolean(data[name] && data[name].match(value));
	        }
	
	        if (!withinArray) {
	          return false;
	        }
	
	        return arrayContains(data[name], value);
	
	      case 'Number':
	        value = String(value);
	        /* falls through */
	      case 'String':
	        if (!isArray(data[name])) {
	          return data[name] === value;
	        }
	
	        if (!withinArray) {
	          return false;
	        }
	
	        return arrayContains(data[name], value);
	
	      default:
	        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
	    }
	  };
	
	
	  URI.joinPaths = function() {
	    var input = [];
	    var segments = [];
	    var nonEmptySegments = 0;
	
	    for (var i = 0; i < arguments.length; i++) {
	      var url = new URI(arguments[i]);
	      input.push(url);
	      var _segments = url.segment();
	      for (var s = 0; s < _segments.length; s++) {
	        if (typeof _segments[s] === 'string') {
	          segments.push(_segments[s]);
	        }
	
	        if (_segments[s]) {
	          nonEmptySegments++;
	        }
	      }
	    }
	
	    if (!segments.length || !nonEmptySegments) {
	      return new URI('');
	    }
	
	    var uri = new URI('').segment(segments);
	
	    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
	      uri.path('/' + uri.path());
	    }
	
	    return uri.normalize();
	  };
	
	  URI.commonPath = function(one, two) {
	    var length = Math.min(one.length, two.length);
	    var pos;
	
	    // find first non-matching character
	    for (pos = 0; pos < length; pos++) {
	      if (one.charAt(pos) !== two.charAt(pos)) {
	        pos--;
	        break;
	      }
	    }
	
	    if (pos < 1) {
	      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
	    }
	
	    // revert to last /
	    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
	      pos = one.substring(0, pos).lastIndexOf('/');
	    }
	
	    return one.substring(0, pos + 1);
	  };
	
	  URI.withinString = function(string, callback, options) {
	    options || (options = {});
	    var _start = options.start || URI.findUri.start;
	    var _end = options.end || URI.findUri.end;
	    var _trim = options.trim || URI.findUri.trim;
	    var _attributeOpen = /[a-z0-9-]=["']?$/i;
	
	    _start.lastIndex = 0;
	    while (true) {
	      var match = _start.exec(string);
	      if (!match) {
	        break;
	      }
	
	      var start = match.index;
	      if (options.ignoreHtml) {
	        // attribut(e=["']?$)
	        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
	        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
	          continue;
	        }
	      }
	
	      var end = start + string.slice(start).search(_end);
	      var slice = string.slice(start, end).replace(_trim, '');
	      if (options.ignore && options.ignore.test(slice)) {
	        continue;
	      }
	
	      end = start + slice.length;
	      var result = callback(slice, start, end, string);
	      string = string.slice(0, start) + result + string.slice(end);
	      _start.lastIndex = start + result.length;
	    }
	
	    _start.lastIndex = 0;
	    return string;
	  };
	
	  URI.ensureValidHostname = function(v) {
	    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
	    // they are not part of DNS and therefore ignored by URI.js
	
	    if (v.match(URI.invalid_hostname_characters)) {
	      // test punycode
	      if (!punycode) {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
	      }
	
	      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	    }
	  };
	
	  // noConflict
	  URI.noConflict = function(removeAll) {
	    if (removeAll) {
	      var unconflicted = {
	        URI: this.noConflict()
	      };
	
	      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
	        unconflicted.URITemplate = root.URITemplate.noConflict();
	      }
	
	      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
	        unconflicted.IPv6 = root.IPv6.noConflict();
	      }
	
	      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
	        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
	      }
	
	      return unconflicted;
	    } else if (root.URI === this) {
	      root.URI = _URI;
	    }
	
	    return this;
	  };
	
	  p.build = function(deferBuild) {
	    if (deferBuild === true) {
	      this._deferred_build = true;
	    } else if (deferBuild === undefined || this._deferred_build) {
	      this._string = URI.build(this._parts);
	      this._deferred_build = false;
	    }
	
	    return this;
	  };
	
	  p.clone = function() {
	    return new URI(this);
	  };
	
	  p.valueOf = p.toString = function() {
	    return this.build(false)._string;
	  };
	
	
	  function generateSimpleAccessor(_part){
	    return function(v, build) {
	      if (v === undefined) {
	        return this._parts[_part] || '';
	      } else {
	        this._parts[_part] = v || null;
	        this.build(!build);
	        return this;
	      }
	    };
	  }
	
	  function generatePrefixAccessor(_part, _key){
	    return function(v, build) {
	      if (v === undefined) {
	        return this._parts[_part] || '';
	      } else {
	        if (v !== null) {
	          v = v + '';
	          if (v.charAt(0) === _key) {
	            v = v.substring(1);
	          }
	        }
	
	        this._parts[_part] = v;
	        this.build(!build);
	        return this;
	      }
	    };
	  }
	
	  p.protocol = generateSimpleAccessor('protocol');
	  p.username = generateSimpleAccessor('username');
	  p.password = generateSimpleAccessor('password');
	  p.hostname = generateSimpleAccessor('hostname');
	  p.port = generateSimpleAccessor('port');
	  p.query = generatePrefixAccessor('query', '?');
	  p.fragment = generatePrefixAccessor('fragment', '#');
	
	  p.search = function(v, build) {
	    var t = this.query(v, build);
	    return typeof t === 'string' && t.length ? ('?' + t) : t;
	  };
	  p.hash = function(v, build) {
	    var t = this.fragment(v, build);
	    return typeof t === 'string' && t.length ? ('#' + t) : t;
	  };
	
	  p.pathname = function(v, build) {
	    if (v === undefined || v === true) {
	      var res = this._parts.path || (this._parts.hostname ? '/' : '');
	      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
	    } else {
	      if (this._parts.urn) {
	        this._parts.path = v ? URI.recodeUrnPath(v) : '';
	      } else {
	        this._parts.path = v ? URI.recodePath(v) : '/';
	      }
	      this.build(!build);
	      return this;
	    }
	  };
	  p.path = p.pathname;
	  p.href = function(href, build) {
	    var key;
	
	    if (href === undefined) {
	      return this.toString();
	    }
	
	    this._string = '';
	    this._parts = URI._parts();
	
	    var _URI = href instanceof URI;
	    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
	    if (href.nodeName) {
	      var attribute = URI.getDomAttribute(href);
	      href = href[attribute] || '';
	      _object = false;
	    }
	
	    // window.location is reported to be an object, but it's not the sort
	    // of object we're looking for:
	    // * location.protocol ends with a colon
	    // * location.query != object.search
	    // * location.hash != object.fragment
	    // simply serializing the unknown object should do the trick
	    // (for location, not for everything...)
	    if (!_URI && _object && href.pathname !== undefined) {
	      href = href.toString();
	    }
	
	    if (typeof href === 'string' || href instanceof String) {
	      this._parts = URI.parse(String(href), this._parts);
	    } else if (_URI || _object) {
	      var src = _URI ? href._parts : href;
	      for (key in src) {
	        if (hasOwn.call(this._parts, key)) {
	          this._parts[key] = src[key];
	        }
	      }
	    } else {
	      throw new TypeError('invalid input');
	    }
	
	    this.build(!build);
	    return this;
	  };
	
	  // identification accessors
	  p.is = function(what) {
	    var ip = false;
	    var ip4 = false;
	    var ip6 = false;
	    var name = false;
	    var sld = false;
	    var idn = false;
	    var punycode = false;
	    var relative = !this._parts.urn;
	
	    if (this._parts.hostname) {
	      relative = false;
	      ip4 = URI.ip4_expression.test(this._parts.hostname);
	      ip6 = URI.ip6_expression.test(this._parts.hostname);
	      ip = ip4 || ip6;
	      name = !ip;
	      sld = name && SLD && SLD.has(this._parts.hostname);
	      idn = name && URI.idn_expression.test(this._parts.hostname);
	      punycode = name && URI.punycode_expression.test(this._parts.hostname);
	    }
	
	    switch (what.toLowerCase()) {
	      case 'relative':
	        return relative;
	
	      case 'absolute':
	        return !relative;
	
	      // hostname identification
	      case 'domain':
	      case 'name':
	        return name;
	
	      case 'sld':
	        return sld;
	
	      case 'ip':
	        return ip;
	
	      case 'ip4':
	      case 'ipv4':
	      case 'inet4':
	        return ip4;
	
	      case 'ip6':
	      case 'ipv6':
	      case 'inet6':
	        return ip6;
	
	      case 'idn':
	        return idn;
	
	      case 'url':
	        return !this._parts.urn;
	
	      case 'urn':
	        return !!this._parts.urn;
	
	      case 'punycode':
	        return punycode;
	    }
	
	    return null;
	  };
	
	  // component specific input validation
	  var _protocol = p.protocol;
	  var _port = p.port;
	  var _hostname = p.hostname;
	
	  p.protocol = function(v, build) {
	    if (v !== undefined) {
	      if (v) {
	        // accept trailing ://
	        v = v.replace(/:(\/\/)?$/, '');
	
	        if (!v.match(URI.protocol_expression)) {
	          throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
	        }
	      }
	    }
	    return _protocol.call(this, v, build);
	  };
	  p.scheme = p.protocol;
	  p.port = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v !== undefined) {
	      if (v === 0) {
	        v = null;
	      }
	
	      if (v) {
	        v += '';
	        if (v.charAt(0) === ':') {
	          v = v.substring(1);
	        }
	
	        if (v.match(/[^0-9]/)) {
	          throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
	        }
	      }
	    }
	    return _port.call(this, v, build);
	  };
	  p.hostname = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v !== undefined) {
	      var x = {};
	      var res = URI.parseHost(v, x);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	
	      v = x.hostname;
	    }
	    return _hostname.call(this, v, build);
	  };
	
	  // compound accessors
	  p.origin = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined) {
	      var protocol = this.protocol();
	      var authority = this.authority();
	      if (!authority) {
	        return '';
	      }
	
	      return (protocol ? protocol + '://' : '') + this.authority();
	    } else {
	      var origin = URI(v);
	      this
	        .protocol(origin.protocol())
	        .authority(origin.authority())
	        .build(!build);
	      return this;
	    }
	  };
	  p.host = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined) {
	      return this._parts.hostname ? URI.buildHost(this._parts) : '';
	    } else {
	      var res = URI.parseHost(v, this._parts);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	
	      this.build(!build);
	      return this;
	    }
	  };
	  p.authority = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined) {
	      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
	    } else {
	      var res = URI.parseAuthority(v, this._parts);
	      if (res !== '/') {
	        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
	      }
	
	      this.build(!build);
	      return this;
	    }
	  };
	  p.userinfo = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined) {
	      var t = URI.buildUserinfo(this._parts);
	      return t ? t.substring(0, t.length -1) : t;
	    } else {
	      if (v[v.length-1] !== '@') {
	        v += '@';
	      }
	
	      URI.parseUserinfo(v, this._parts);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.resource = function(v, build) {
	    var parts;
	
	    if (v === undefined) {
	      return this.path() + this.search() + this.hash();
	    }
	
	    parts = URI.parse(v);
	    this._parts.path = parts.path;
	    this._parts.query = parts.query;
	    this._parts.fragment = parts.fragment;
	    this.build(!build);
	    return this;
	  };
	
	  // fraction accessors
	  p.subdomain = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    // convenience, return "www" from "www.example.org"
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	
	      // grab domain and add another segment
	      var end = this._parts.hostname.length - this.domain().length - 1;
	      return this._parts.hostname.substring(0, end) || '';
	    } else {
	      var e = this._parts.hostname.length - this.domain().length;
	      var sub = this._parts.hostname.substring(0, e);
	      var replace = new RegExp('^' + escapeRegEx(sub));
	
	      if (v && v.charAt(v.length - 1) !== '.') {
	        v += '.';
	      }
	
	      if (v) {
	        URI.ensureValidHostname(v);
	      }
	
	      this._parts.hostname = this._parts.hostname.replace(replace, v);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.domain = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (typeof v === 'boolean') {
	      build = v;
	      v = undefined;
	    }
	
	    // convenience, return "example.org" from "www.example.org"
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	
	      // if hostname consists of 1 or 2 segments, it must be the domain
	      var t = this._parts.hostname.match(/\./g);
	      if (t && t.length < 2) {
	        return this._parts.hostname;
	      }
	
	      // grab tld and add another segment
	      var end = this._parts.hostname.length - this.tld(build).length - 1;
	      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
	      return this._parts.hostname.substring(end) || '';
	    } else {
	      if (!v) {
	        throw new TypeError('cannot set domain empty');
	      }
	
	      URI.ensureValidHostname(v);
	
	      if (!this._parts.hostname || this.is('IP')) {
	        this._parts.hostname = v;
	      } else {
	        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
	        this._parts.hostname = this._parts.hostname.replace(replace, v);
	      }
	
	      this.build(!build);
	      return this;
	    }
	  };
	  p.tld = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (typeof v === 'boolean') {
	      build = v;
	      v = undefined;
	    }
	
	    // return "org" from "www.example.org"
	    if (v === undefined) {
	      if (!this._parts.hostname || this.is('IP')) {
	        return '';
	      }
	
	      var pos = this._parts.hostname.lastIndexOf('.');
	      var tld = this._parts.hostname.substring(pos + 1);
	
	      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
	        return SLD.get(this._parts.hostname) || tld;
	      }
	
	      return tld;
	    } else {
	      var replace;
	
	      if (!v) {
	        throw new TypeError('cannot set TLD empty');
	      } else if (v.match(/[^a-zA-Z0-9-]/)) {
	        if (SLD && SLD.is(v)) {
	          replace = new RegExp(escapeRegEx(this.tld()) + '$');
	          this._parts.hostname = this._parts.hostname.replace(replace, v);
	        } else {
	          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
	        }
	      } else if (!this._parts.hostname || this.is('IP')) {
	        throw new ReferenceError('cannot set TLD on non-domain host');
	      } else {
	        replace = new RegExp(escapeRegEx(this.tld()) + '$');
	        this._parts.hostname = this._parts.hostname.replace(replace, v);
	      }
	
	      this.build(!build);
	      return this;
	    }
	  };
	  p.directory = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined || v === true) {
	      if (!this._parts.path && !this._parts.hostname) {
	        return '';
	      }
	
	      if (this._parts.path === '/') {
	        return '/';
	      }
	
	      var end = this._parts.path.length - this.filename().length - 1;
	      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');
	
	      return v ? URI.decodePath(res) : res;
	
	    } else {
	      var e = this._parts.path.length - this.filename().length;
	      var directory = this._parts.path.substring(0, e);
	      var replace = new RegExp('^' + escapeRegEx(directory));
	
	      // fully qualifier directories begin with a slash
	      if (!this.is('relative')) {
	        if (!v) {
	          v = '/';
	        }
	
	        if (v.charAt(0) !== '/') {
	          v = '/' + v;
	        }
	      }
	
	      // directories always end with a slash
	      if (v && v.charAt(v.length - 1) !== '/') {
	        v += '/';
	      }
	
	      v = URI.recodePath(v);
	      this._parts.path = this._parts.path.replace(replace, v);
	      this.build(!build);
	      return this;
	    }
	  };
	  p.filename = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined || v === true) {
	      if (!this._parts.path || this._parts.path === '/') {
	        return '';
	      }
	
	      var pos = this._parts.path.lastIndexOf('/');
	      var res = this._parts.path.substring(pos+1);
	
	      return v ? URI.decodePathSegment(res) : res;
	    } else {
	      var mutatedDirectory = false;
	
	      if (v.charAt(0) === '/') {
	        v = v.substring(1);
	      }
	
	      if (v.match(/\.?\//)) {
	        mutatedDirectory = true;
	      }
	
	      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
	      v = URI.recodePath(v);
	      this._parts.path = this._parts.path.replace(replace, v);
	
	      if (mutatedDirectory) {
	        this.normalizePath(build);
	      } else {
	        this.build(!build);
	      }
	
	      return this;
	    }
	  };
	  p.suffix = function(v, build) {
	    if (this._parts.urn) {
	      return v === undefined ? '' : this;
	    }
	
	    if (v === undefined || v === true) {
	      if (!this._parts.path || this._parts.path === '/') {
	        return '';
	      }
	
	      var filename = this.filename();
	      var pos = filename.lastIndexOf('.');
	      var s, res;
	
	      if (pos === -1) {
	        return '';
	      }
	
	      // suffix may only contain alnum characters (yup, I made this up.)
	      s = filename.substring(pos+1);
	      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
	      return v ? URI.decodePathSegment(res) : res;
	    } else {
	      if (v.charAt(0) === '.') {
	        v = v.substring(1);
	      }
	
	      var suffix = this.suffix();
	      var replace;
	
	      if (!suffix) {
	        if (!v) {
	          return this;
	        }
	
	        this._parts.path += '.' + URI.recodePath(v);
	      } else if (!v) {
	        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
	      } else {
	        replace = new RegExp(escapeRegEx(suffix) + '$');
	      }
	
	      if (replace) {
	        v = URI.recodePath(v);
	        this._parts.path = this._parts.path.replace(replace, v);
	      }
	
	      this.build(!build);
	      return this;
	    }
	  };
	  p.segment = function(segment, v, build) {
	    var separator = this._parts.urn ? ':' : '/';
	    var path = this.path();
	    var absolute = path.substring(0, 1) === '/';
	    var segments = path.split(separator);
	
	    if (segment !== undefined && typeof segment !== 'number') {
	      build = v;
	      v = segment;
	      segment = undefined;
	    }
	
	    if (segment !== undefined && typeof segment !== 'number') {
	      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
	    }
	
	    if (absolute) {
	      segments.shift();
	    }
	
	    if (segment < 0) {
	      // allow negative indexes to address from the end
	      segment = Math.max(segments.length + segment, 0);
	    }
	
	    if (v === undefined) {
	      /*jshint laxbreak: true */
	      return segment === undefined
	        ? segments
	        : segments[segment];
	      /*jshint laxbreak: false */
	    } else if (segment === null || segments[segment] === undefined) {
	      if (isArray(v)) {
	        segments = [];
	        // collapse empty elements within array
	        for (var i=0, l=v.length; i < l; i++) {
	          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
	            continue;
	          }
	
	          if (segments.length && !segments[segments.length -1].length) {
	            segments.pop();
	          }
	
	          segments.push(trimSlashes(v[i]));
	        }
	      } else if (v || typeof v === 'string') {
	        v = trimSlashes(v);
	        if (segments[segments.length -1] === '') {
	          // empty trailing elements have to be overwritten
	          // to prevent results such as /foo//bar
	          segments[segments.length -1] = v;
	        } else {
	          segments.push(v);
	        }
	      }
	    } else {
	      if (v) {
	        segments[segment] = trimSlashes(v);
	      } else {
	        segments.splice(segment, 1);
	      }
	    }
	
	    if (absolute) {
	      segments.unshift('');
	    }
	
	    return this.path(segments.join(separator), build);
	  };
	  p.segmentCoded = function(segment, v, build) {
	    var segments, i, l;
	
	    if (typeof segment !== 'number') {
	      build = v;
	      v = segment;
	      segment = undefined;
	    }
	
	    if (v === undefined) {
	      segments = this.segment(segment, v, build);
	      if (!isArray(segments)) {
	        segments = segments !== undefined ? URI.decode(segments) : undefined;
	      } else {
	        for (i = 0, l = segments.length; i < l; i++) {
	          segments[i] = URI.decode(segments[i]);
	        }
	      }
	
	      return segments;
	    }
	
	    if (!isArray(v)) {
	      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
	    } else {
	      for (i = 0, l = v.length; i < l; i++) {
	        v[i] = URI.encode(v[i]);
	      }
	    }
	
	    return this.segment(segment, v, build);
	  };
	
	  // mutating query string
	  var q = p.query;
	  p.query = function(v, build) {
	    if (v === true) {
	      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    } else if (typeof v === 'function') {
	      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	      var result = v.call(this, data);
	      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	      this.build(!build);
	      return this;
	    } else if (v !== undefined && typeof v !== 'string') {
	      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	      this.build(!build);
	      return this;
	    } else {
	      return q.call(this, v, build);
	    }
	  };
	  p.setQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	
	    if (typeof name === 'string' || name instanceof String) {
	      data[name] = value !== undefined ? value : null;
	    } else if (typeof name === 'object') {
	      for (var key in name) {
	        if (hasOwn.call(name, key)) {
	          data[key] = name[key];
	        }
	      }
	    } else {
	      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
	    }
	
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	
	    this.build(!build);
	    return this;
	  };
	  p.addQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    URI.addQuery(data, name, value === undefined ? null : value);
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	
	    this.build(!build);
	    return this;
	  };
	  p.removeQuery = function(name, value, build) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    URI.removeQuery(data, name, value);
	    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
	    if (typeof name !== 'string') {
	      build = value;
	    }
	
	    this.build(!build);
	    return this;
	  };
	  p.hasQuery = function(name, value, withinArray) {
	    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
	    return URI.hasQuery(data, name, value, withinArray);
	  };
	  p.setSearch = p.setQuery;
	  p.addSearch = p.addQuery;
	  p.removeSearch = p.removeQuery;
	  p.hasSearch = p.hasQuery;
	
	  // sanitizing URLs
	  p.normalize = function() {
	    if (this._parts.urn) {
	      return this
	        .normalizeProtocol(false)
	        .normalizePath(false)
	        .normalizeQuery(false)
	        .normalizeFragment(false)
	        .build();
	    }
	
	    return this
	      .normalizeProtocol(false)
	      .normalizeHostname(false)
	      .normalizePort(false)
	      .normalizePath(false)
	      .normalizeQuery(false)
	      .normalizeFragment(false)
	      .build();
	  };
	  p.normalizeProtocol = function(build) {
	    if (typeof this._parts.protocol === 'string') {
	      this._parts.protocol = this._parts.protocol.toLowerCase();
	      this.build(!build);
	    }
	
	    return this;
	  };
	  p.normalizeHostname = function(build) {
	    if (this._parts.hostname) {
	      if (this.is('IDN') && punycode) {
	        this._parts.hostname = punycode.toASCII(this._parts.hostname);
	      } else if (this.is('IPv6') && IPv6) {
	        this._parts.hostname = IPv6.best(this._parts.hostname);
	      }
	
	      this._parts.hostname = this._parts.hostname.toLowerCase();
	      this.build(!build);
	    }
	
	    return this;
	  };
	  p.normalizePort = function(build) {
	    // remove port of it's the protocol's default
	    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
	      this._parts.port = null;
	      this.build(!build);
	    }
	
	    return this;
	  };
	  p.normalizePath = function(build) {
	    var _path = this._parts.path;
	    if (!_path) {
	      return this;
	    }
	
	    if (this._parts.urn) {
	      this._parts.path = URI.recodeUrnPath(this._parts.path);
	      this.build(!build);
	      return this;
	    }
	
	    if (this._parts.path === '/') {
	      return this;
	    }
	
	    _path = URI.recodePath(_path);
	
	    var _was_relative;
	    var _leadingParents = '';
	    var _parent, _pos;
	
	    // handle relative paths
	    if (_path.charAt(0) !== '/') {
	      _was_relative = true;
	      _path = '/' + _path;
	    }
	
	    // handle relative files (as opposed to directories)
	    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
	      _path += '/';
	    }
	
	    // resolve simples
	    _path = _path
	      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
	      .replace(/\/{2,}/g, '/');
	
	    // remember leading parents
	    if (_was_relative) {
	      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
	      if (_leadingParents) {
	        _leadingParents = _leadingParents[0];
	      }
	    }
	
	    // resolve parents
	    while (true) {
	      _parent = _path.search(/\/\.\.(\/|$)/);
	      if (_parent === -1) {
	        // no more ../ to resolve
	        break;
	      } else if (_parent === 0) {
	        // top level cannot be relative, skip it
	        _path = _path.substring(3);
	        continue;
	      }
	
	      _pos = _path.substring(0, _parent).lastIndexOf('/');
	      if (_pos === -1) {
	        _pos = _parent;
	      }
	      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
	    }
	
	    // revert to relative
	    if (_was_relative && this.is('relative')) {
	      _path = _leadingParents + _path.substring(1);
	    }
	
	    this._parts.path = _path;
	    this.build(!build);
	    return this;
	  };
	  p.normalizePathname = p.normalizePath;
	  p.normalizeQuery = function(build) {
	    if (typeof this._parts.query === 'string') {
	      if (!this._parts.query.length) {
	        this._parts.query = null;
	      } else {
	        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
	      }
	
	      this.build(!build);
	    }
	
	    return this;
	  };
	  p.normalizeFragment = function(build) {
	    if (!this._parts.fragment) {
	      this._parts.fragment = null;
	      this.build(!build);
	    }
	
	    return this;
	  };
	  p.normalizeSearch = p.normalizeQuery;
	  p.normalizeHash = p.normalizeFragment;
	
	  p.iso8859 = function() {
	    // expect unicode input, iso8859 output
	    var e = URI.encode;
	    var d = URI.decode;
	
	    URI.encode = escape;
	    URI.decode = decodeURIComponent;
	    try {
	      this.normalize();
	    } finally {
	      URI.encode = e;
	      URI.decode = d;
	    }
	    return this;
	  };
	
	  p.unicode = function() {
	    // expect iso8859 input, unicode output
	    var e = URI.encode;
	    var d = URI.decode;
	
	    URI.encode = strictEncodeURIComponent;
	    URI.decode = unescape;
	    try {
	      this.normalize();
	    } finally {
	      URI.encode = e;
	      URI.decode = d;
	    }
	    return this;
	  };
	
	  p.readable = function() {
	    var uri = this.clone();
	    // removing username, password, because they shouldn't be displayed according to RFC 3986
	    uri.username('').password('').normalize();
	    var t = '';
	    if (uri._parts.protocol) {
	      t += uri._parts.protocol + '://';
	    }
	
	    if (uri._parts.hostname) {
	      if (uri.is('punycode') && punycode) {
	        t += punycode.toUnicode(uri._parts.hostname);
	        if (uri._parts.port) {
	          t += ':' + uri._parts.port;
	        }
	      } else {
	        t += uri.host();
	      }
	    }
	
	    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
	      t += '/';
	    }
	
	    t += uri.path(true);
	    if (uri._parts.query) {
	      var q = '';
	      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
	        var kv = (qp[i] || '').split('=');
	        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
	          .replace(/&/g, '%26');
	
	        if (kv[1] !== undefined) {
	          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
	            .replace(/&/g, '%26');
	        }
	      }
	      t += '?' + q.substring(1);
	    }
	
	    t += URI.decodeQuery(uri.hash(), true);
	    return t;
	  };
	
	  // resolving relative and absolute URLs
	  p.absoluteTo = function(base) {
	    var resolved = this.clone();
	    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
	    var basedir, i, p;
	
	    if (this._parts.urn) {
	      throw new Error('URNs do not have any generally defined hierarchical components');
	    }
	
	    if (!(base instanceof URI)) {
	      base = new URI(base);
	    }
	
	    if (!resolved._parts.protocol) {
	      resolved._parts.protocol = base._parts.protocol;
	    }
	
	    if (this._parts.hostname) {
	      return resolved;
	    }
	
	    for (i = 0; (p = properties[i]); i++) {
	      resolved._parts[p] = base._parts[p];
	    }
	
	    if (!resolved._parts.path) {
	      resolved._parts.path = base._parts.path;
	      if (!resolved._parts.query) {
	        resolved._parts.query = base._parts.query;
	      }
	    } else if (resolved._parts.path.substring(-2) === '..') {
	      resolved._parts.path += '/';
	    }
	
	    if (resolved.path().charAt(0) !== '/') {
	      basedir = base.directory();
	      basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
	      resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
	      resolved.normalizePath();
	    }
	
	    resolved.build();
	    return resolved;
	  };
	  p.relativeTo = function(base) {
	    var relative = this.clone().normalize();
	    var relativeParts, baseParts, common, relativePath, basePath;
	
	    if (relative._parts.urn) {
	      throw new Error('URNs do not have any generally defined hierarchical components');
	    }
	
	    base = new URI(base).normalize();
	    relativeParts = relative._parts;
	    baseParts = base._parts;
	    relativePath = relative.path();
	    basePath = base.path();
	
	    if (relativePath.charAt(0) !== '/') {
	      throw new Error('URI is already relative');
	    }
	
	    if (basePath.charAt(0) !== '/') {
	      throw new Error('Cannot calculate a URI relative to another relative URI');
	    }
	
	    if (relativeParts.protocol === baseParts.protocol) {
	      relativeParts.protocol = null;
	    }
	
	    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
	      return relative.build();
	    }
	
	    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
	      return relative.build();
	    }
	
	    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
	      relativeParts.hostname = null;
	      relativeParts.port = null;
	    } else {
	      return relative.build();
	    }
	
	    if (relativePath === basePath) {
	      relativeParts.path = '';
	      return relative.build();
	    }
	
	    // determine common sub path
	    common = URI.commonPath(relativePath, basePath);
	
	    // If the paths have nothing in common, return a relative URL with the absolute path.
	    if (!common) {
	      return relative.build();
	    }
	
	    var parents = baseParts.path
	      .substring(common.length)
	      .replace(/[^\/]*$/, '')
	      .replace(/.*?\//g, '../');
	
	    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';
	
	    return relative.build();
	  };
	
	  // comparing URIs
	  p.equals = function(uri) {
	    var one = this.clone();
	    var two = new URI(uri);
	    var one_map = {};
	    var two_map = {};
	    var checked = {};
	    var one_query, two_query, key;
	
	    one.normalize();
	    two.normalize();
	
	    // exact match
	    if (one.toString() === two.toString()) {
	      return true;
	    }
	
	    // extract query string
	    one_query = one.query();
	    two_query = two.query();
	    one.query('');
	    two.query('');
	
	    // definitely not equal if not even non-query parts match
	    if (one.toString() !== two.toString()) {
	      return false;
	    }
	
	    // query parameters have the same length, even if they're permuted
	    if (one_query.length !== two_query.length) {
	      return false;
	    }
	
	    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
	    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
	
	    for (key in one_map) {
	      if (hasOwn.call(one_map, key)) {
	        if (!isArray(one_map[key])) {
	          if (one_map[key] !== two_map[key]) {
	            return false;
	          }
	        } else if (!arraysEqual(one_map[key], two_map[key])) {
	          return false;
	        }
	
	        checked[key] = true;
	      }
	    }
	
	    for (key in two_map) {
	      if (hasOwn.call(two_map, key)) {
	        if (!checked[key]) {
	          // two contains a parameter not present in one
	          return false;
	        }
	      }
	    }
	
	    return true;
	  };
	
	  // state
	  p.duplicateQueryParameters = function(v) {
	    this._parts.duplicateQueryParameters = !!v;
	    return this;
	  };
	
	  p.escapeQuerySpace = function(v) {
	    this._parts.escapeQuerySpace = !!v;
	    return this;
	  };
	
	  return URI;
	}));


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.0 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(306)(module), (function() { return this; }())))

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * URI.js - Mutating URLs
	 * IPv6 Support
	 *
	 * Version: 1.18.1
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	
	(function (root, factory) {
	  'use strict';
	  // https://github.com/umdjs/umd/blob/master/returnExports.js
	  if (true) {
	    // Node
	    module.exports = factory();
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD. Register as an anonymous module.
	    define(factory);
	  } else {
	    // Browser globals (root is window)
	    root.IPv6 = factory(root);
	  }
	}(this, function (root) {
	  'use strict';
	
	  /*
	  var _in = "fe80:0000:0000:0000:0204:61ff:fe9d:f156";
	  var _out = IPv6.best(_in);
	  var _expected = "fe80::204:61ff:fe9d:f156";
	
	  console.log(_in, _out, _expected, _out === _expected);
	  */
	
	  // save current IPv6 variable, if any
	  var _IPv6 = root && root.IPv6;
	
	  function bestPresentation(address) {
	    // based on:
	    // Javascript to test an IPv6 address for proper format, and to
	    // present the "best text representation" according to IETF Draft RFC at
	    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04
	    // 8 Feb 2010 Rich Brown, Dartware, LLC
	    // Please feel free to use this code as long as you provide a link to
	    // http://www.intermapper.com
	    // http://intermapper.com/support/tools/IPV6-Validator.aspx
	    // http://download.dartware.com/thirdparty/ipv6validator.js
	
	    var _address = address.toLowerCase();
	    var segments = _address.split(':');
	    var length = segments.length;
	    var total = 8;
	
	    // trim colons (:: or ::a:b:c… or …a:b:c::)
	    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
	      // must have been ::
	      // remove first two items
	      segments.shift();
	      segments.shift();
	    } else if (segments[0] === '' && segments[1] === '') {
	      // must have been ::xxxx
	      // remove the first item
	      segments.shift();
	    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
	      // must have been xxxx::
	      segments.pop();
	    }
	
	    length = segments.length;
	
	    // adjust total segments for IPv4 trailer
	    if (segments[length - 1].indexOf('.') !== -1) {
	      // found a "." which means IPv4
	      total = 7;
	    }
	
	    // fill empty segments them with "0000"
	    var pos;
	    for (pos = 0; pos < length; pos++) {
	      if (segments[pos] === '') {
	        break;
	      }
	    }
	
	    if (pos < total) {
	      segments.splice(pos, 1, '0000');
	      while (segments.length < total) {
	        segments.splice(pos, 0, '0000');
	      }
	    }
	
	    // strip leading zeros
	    var _segments;
	    for (var i = 0; i < total; i++) {
	      _segments = segments[i].split('');
	      for (var j = 0; j < 3 ; j++) {
	        if (_segments[0] === '0' && _segments.length > 1) {
	          _segments.splice(0,1);
	        } else {
	          break;
	        }
	      }
	
	      segments[i] = _segments.join('');
	    }
	
	    // find longest sequence of zeroes and coalesce them into one segment
	    var best = -1;
	    var _best = 0;
	    var _current = 0;
	    var current = -1;
	    var inzeroes = false;
	    // i; already declared
	
	    for (i = 0; i < total; i++) {
	      if (inzeroes) {
	        if (segments[i] === '0') {
	          _current += 1;
	        } else {
	          inzeroes = false;
	          if (_current > _best) {
	            best = current;
	            _best = _current;
	          }
	        }
	      } else {
	        if (segments[i] === '0') {
	          inzeroes = true;
	          current = i;
	          _current = 1;
	        }
	      }
	    }
	
	    if (_current > _best) {
	      best = current;
	      _best = _current;
	    }
	
	    if (_best > 1) {
	      segments.splice(best, _best, '');
	    }
	
	    length = segments.length;
	
	    // assemble remaining segments
	    var result = '';
	    if (segments[0] === '')  {
	      result = ':';
	    }
	
	    for (i = 0; i < length; i++) {
	      result += segments[i];
	      if (i === length - 1) {
	        break;
	      }
	
	      result += ':';
	    }
	
	    if (segments[length - 1] === '') {
	      result += ':';
	    }
	
	    return result;
	  }
	
	  function noConflict() {
	    /*jshint validthis: true */
	    if (root.IPv6 === this) {
	      root.IPv6 = _IPv6;
	    }
	  
	    return this;
	  }
	
	  return {
	    best: bestPresentation,
	    noConflict: noConflict
	  };
	}));


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * URI.js - Mutating URLs
	 * Second Level Domain (SLD) Support
	 *
	 * Version: 1.18.1
	 *
	 * Author: Rodney Rehm
	 * Web: http://medialize.github.io/URI.js/
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *
	 */
	
	(function (root, factory) {
	  'use strict';
	  // https://github.com/umdjs/umd/blob/master/returnExports.js
	  if (true) {
	    // Node
	    module.exports = factory();
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD. Register as an anonymous module.
	    define(factory);
	  } else {
	    // Browser globals (root is window)
	    root.SecondLevelDomains = factory(root);
	  }
	}(this, function (root) {
	  'use strict';
	
	  // save current SecondLevelDomains variable, if any
	  var _SecondLevelDomains = root && root.SecondLevelDomains;
	
	  var SLD = {
	    // list of known Second Level Domains
	    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
	    // ----
	    // publicsuffix.org is more current and actually used by a couple of browsers internally.
	    // downside is it also contains domains like "dyndns.org" - which is fine for the security
	    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
	    // ----
	    list: {
	      'ac':' com gov mil net org ',
	      'ae':' ac co gov mil name net org pro sch ',
	      'af':' com edu gov net org ',
	      'al':' com edu gov mil net org ',
	      'ao':' co ed gv it og pb ',
	      'ar':' com edu gob gov int mil net org tur ',
	      'at':' ac co gv or ',
	      'au':' asn com csiro edu gov id net org ',
	      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',
	      'bb':' biz co com edu gov info net org store tv ',
	      'bh':' biz cc com edu gov info net org ',
	      'bn':' com edu gov net org ',
	      'bo':' com edu gob gov int mil net org tv ',
	      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
	      'bs':' com edu gov net org ',
	      'bz':' du et om ov rg ',
	      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
	      'ck':' biz co edu gen gov info net org ',
	      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
	      'co':' com edu gov mil net nom org ',
	      'cr':' ac c co ed fi go or sa ',
	      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',
	      'do':' art com edu gob gov mil net org sld web ',
	      'dz':' art asso com edu gov net org pol ',
	      'ec':' com edu fin gov info med mil net org pro ',
	      'eg':' com edu eun gov mil name net org sci ',
	      'er':' com edu gov ind mil net org rochest w ',
	      'es':' com edu gob nom org ',
	      'et':' biz com edu gov info name net org ',
	      'fj':' ac biz com info mil name net org pro ',
	      'fk':' ac co gov net nom org ',
	      'fr':' asso com f gouv nom prd presse tm ',
	      'gg':' co net org ',
	      'gh':' com edu gov mil org ',
	      'gn':' ac com gov net org ',
	      'gr':' com edu gov mil net org ',
	      'gt':' com edu gob ind mil net org ',
	      'gu':' com edu gov net org ',
	      'hk':' com edu gov idv net org ',
	      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
	      'id':' ac co go mil net or sch web ',
	      'il':' ac co gov idf k12 muni net org ',
	      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',
	      'iq':' com edu gov i mil net org ',
	      'ir':' ac co dnssec gov i id net org sch ',
	      'it':' edu gov ',
	      'je':' co net org ',
	      'jo':' com edu gov mil name net org sch ',
	      'jp':' ac ad co ed go gr lg ne or ',
	      'ke':' ac co go info me mobi ne or sc ',
	      'kh':' com edu gov mil net org per ',
	      'ki':' biz com de edu gov info mob net org tel ',
	      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
	      'kn':' edu gov net org ',
	      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
	      'kw':' com edu gov net org ',
	      'ky':' com edu gov net org ',
	      'kz':' com edu gov mil net org ',
	      'lb':' com edu gov net org ',
	      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
	      'lr':' com edu gov net org ',
	      'lv':' asn com conf edu gov id mil net org ',
	      'ly':' com edu gov id med net org plc sch ',
	      'ma':' ac co gov m net org press ',
	      'mc':' asso tm ',
	      'me':' ac co edu gov its net org priv ',
	      'mg':' com edu gov mil nom org prd tm ',
	      'mk':' com edu gov inf name net org pro ',
	      'ml':' com edu gov net org presse ',
	      'mn':' edu gov org ',
	      'mo':' com edu gov net org ',
	      'mt':' com edu gov net org ',
	      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',
	      'mw':' ac co com coop edu gov int museum net org ',
	      'mx':' com edu gob net org ',
	      'my':' com edu gov mil name net org sch ',
	      'nf':' arts com firm info net other per rec store web ',
	      'ng':' biz com edu gov mil mobi name net org sch ',
	      'ni':' ac co com edu gob mil net nom org ',
	      'np':' com edu gov mil net org ',
	      'nr':' biz com edu gov info net org ',
	      'om':' ac biz co com edu gov med mil museum net org pro sch ',
	      'pe':' com edu gob mil net nom org sld ',
	      'ph':' com edu gov i mil net ngo org ',
	      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',
	      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
	      'pr':' ac biz com edu est gov info isla name net org pro prof ',
	      'ps':' com edu gov net org plo sec ',
	      'pw':' belau co ed go ne or ',
	      'ro':' arts com firm info nom nt org rec store tm www ',
	      'rs':' ac co edu gov in org ',
	      'sb':' com edu gov net org ',
	      'sc':' com edu gov net org ',
	      'sh':' co com edu gov net nom org ',
	      'sl':' com edu gov net org ',
	      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',
	      'sv':' com edu gob org red ',
	      'sz':' ac co org ',
	      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
	      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
	      'tw':' club com ebiz edu game gov idv mil net org ',
	      'mu':' ac co com gov net or org ',
	      'mz':' ac co edu gov org ',
	      'na':' co com ',
	      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',
	      'pa':' abo ac com edu gob ing med net nom org sld ',
	      'pt':' com edu gov int net nome org publ ',
	      'py':' com edu gov mil net org ',
	      'qa':' com edu gov mil net org ',
	      're':' asso com nom ',
	      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
	      'rw':' ac co com edu gouv gov int mil net ',
	      'sa':' com edu gov med net org pub sch ',
	      'sd':' com edu gov info med net org tv ',
	      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
	      'sg':' com edu gov idn net org per ',
	      'sn':' art com edu gouv org perso univ ',
	      'sy':' com edu gov mil net news org ',
	      'th':' ac co go in mi net or ',
	      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',
	      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
	      'tz':' ac co go ne or ',
	      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
	      'ug':' ac co go ne or org sc ',
	      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
	      'us':' dni fed isa kids nsn ',
	      'uy':' com edu gub mil net org ',
	      've':' co com edu gob info mil net org web ',
	      'vi':' co com k12 net org ',
	      'vn':' ac biz com edu gov health info int name net org pro ',
	      'ye':' co com gov ltd me net org plc ',
	      'yu':' ac co edu gov org ',
	      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
	      'zm':' ac co com edu gov net org sch '
	    },
	    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
	    // in both performance and memory footprint. No initialization required.
	    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
	    // Following methods use lastIndexOf() rather than array.split() in order
	    // to avoid any memory allocations.
	    has: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
	        return false;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
	      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
	        return false;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset+1)];
	      if (!sldList) {
	        return false;
	      }
	      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;
	    },
	    is: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
	        return false;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
	      if (sldOffset >= 0) {
	        return false;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset+1)];
	      if (!sldList) {
	        return false;
	      }
	      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
	    },
	    get: function(domain) {
	      var tldOffset = domain.lastIndexOf('.');
	      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
	        return null;
	      }
	      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
	      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
	        return null;
	      }
	      var sldList = SLD.list[domain.slice(tldOffset+1)];
	      if (!sldList) {
	        return null;
	      }
	      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {
	        return null;
	      }
	      return domain.slice(sldOffset+1);
	    },
	    noConflict: function(){
	      if (root.SecondLevelDomains === this) {
	        root.SecondLevelDomains = _SecondLevelDomains;
	      }
	      return this;
	    }
	  };
	
	  return SLD;
	}));


/***/ },
/* 483 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 488 */,
/* 489 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map